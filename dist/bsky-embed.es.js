function rb(t) {
  return Object.keys(t).reduce((r, i) => {
    const a = t[i];
    return r[i] = Object.assign({}, a), If(a.value) && !ob(a.value) && !Array.isArray(a.value) && (r[i].value = Object.assign({}, a.value)), Array.isArray(a.value) && (r[i].value = a.value.slice(0)), r;
  }, {});
}
function ib(t) {
  return t ? Object.keys(t).reduce((r, i) => {
    const a = t[i];
    return r[i] = If(a) && "value" in a ? a : {
      value: a
    }, r[i].attribute || (r[i].attribute = ab(i)), r[i].parse = "parse" in r[i] ? r[i].parse : typeof r[i].value != "string", r;
  }, {}) : {};
}
function nb(t) {
  return Object.keys(t).reduce((r, i) => (r[i] = t[i].value, r), {});
}
function sb(t, e) {
  const r = rb(e);
  return Object.keys(e).forEach((a) => {
    const c = r[a], h = t.getAttribute(c.attribute), m = t[a];
    h != null && (c.value = c.parse ? Bf(h) : h), m != null && (c.value = Array.isArray(m) ? m.slice(0) : m), c.reflect && Ad(t, c.attribute, c.value, !!c.parse), Object.defineProperty(t, a, {
      get() {
        return c.value;
      },
      set(p) {
        const y = c.value;
        c.value = p, c.reflect && Ad(this, c.attribute, c.value, !!c.parse);
        for (let d = 0, A = this.__propertyChangedCallbacks.length; d < A; d++)
          this.__propertyChangedCallbacks[d](a, p, y);
      },
      enumerable: !0,
      configurable: !0
    });
  }), r;
}
function Bf(t) {
  if (t)
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
}
function Ad(t, e, r, i) {
  if (r == null || r === !1) return t.removeAttribute(e);
  let a = i ? JSON.stringify(r) : r;
  t.__updating[e] = !0, a === "true" && (a = ""), t.setAttribute(e, a), Promise.resolve().then(() => delete t.__updating[e]);
}
function ab(t) {
  return t.replace(/\.?([A-Z]+)/g, (e, r) => "-" + r.toLowerCase()).replace("_", "-").replace(/^-/, "");
}
function If(t) {
  return t != null && (typeof t == "object" || typeof t == "function");
}
function ob(t) {
  return Object.prototype.toString.call(t) === "[object Function]";
}
function lb(t) {
  return typeof t == "function" && t.toString().indexOf("class") === 0;
}
let ac;
function ub(t, e) {
  const r = Object.keys(e);
  return class extends t {
    static get observedAttributes() {
      return r.map((a) => e[a].attribute);
    }
    constructor() {
      super(), this.__initialized = !1, this.__released = !1, this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = {};
    }
    connectedCallback() {
      if (this.__initialized) return;
      this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = sb(this, e);
      const a = nb(this.props), c = this.Component, h = ac;
      try {
        ac = this, this.__initialized = !0, lb(c) ? new c(a, {
          element: this
        }) : c(a, {
          element: this
        });
      } finally {
        ac = h;
      }
    }
    async disconnectedCallback() {
      if (await Promise.resolve(), this.isConnected) return;
      this.__propertyChangedCallbacks.length = 0;
      let a = null;
      for (; a = this.__releaseCallbacks.pop(); ) a(this);
      delete this.__initialized, this.__released = !0;
    }
    attributeChangedCallback(a, c, h) {
      if (this.__initialized && !this.__updating[a] && (a = this.lookupProp(a), a in e)) {
        if (h == null && !this[a]) return;
        this[a] = e[a].parse ? Bf(h) : h;
      }
    }
    lookupProp(a) {
      if (e)
        return r.find((c) => a === c || a === e[c].attribute);
    }
    get renderRoot() {
      return this.shadowRoot || this.attachShadow({
        mode: "open"
      });
    }
    addReleaseCallback(a) {
      this.__releaseCallbacks.push(a);
    }
    addPropertyChangedCallback(a) {
      this.__propertyChangedCallbacks.push(a);
    }
  };
}
function cb(t, e = {}, r = {}) {
  const {
    BaseElement: i = HTMLElement,
    extension: a,
    customElements: c = window.customElements
  } = r;
  return (h) => {
    let m = c.get(t);
    return m ? (m.prototype.Component = h, m) : (m = ub(i, ib(e)), m.prototype.Component = h, m.prototype.registeredTag = t, c.define(t, m, a), m);
  };
}
const db = (t, e) => t === e, Rc = Symbol("solid-proxy"), fb = typeof Proxy == "function", ou = {
  equals: db
};
let Uf = Vf;
const vn = 1, lu = 2, Of = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var sr = null;
let oc = null, pb = null, _t = null, Jt = null, Oi = null, Lu = 0;
function hb(t, e) {
  const r = _t, i = sr, a = t.length === 0, c = e === void 0 ? i : e, h = a ? Of : {
    owned: null,
    cleanups: null,
    context: c ? c.context : null,
    owner: c
  }, m = a ? t : () => t(() => va(() => aa(h)));
  sr = h, _t = null;
  try {
    return Aa(m, !0);
  } finally {
    _t = r, sr = i;
  }
}
function ra(t, e) {
  e = e ? Object.assign({}, ou, e) : ou;
  const r = {
    value: t,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, i = (a) => (typeof a == "function" && (a = a(r.value)), Nf(r, a));
  return [Mf.bind(r), i];
}
function Er(t, e, r) {
  const i = Dc(t, e, !1, vn);
  Ra(i);
}
function Kf(t, e, r) {
  Uf = gb;
  const i = Dc(t, e, !1, vn);
  i.user = !0, Oi ? Oi.push(i) : Ra(i);
}
function Kr(t, e, r) {
  r = r ? Object.assign({}, ou, r) : ou;
  const i = Dc(t, e, !0, 0);
  return i.observers = null, i.observerSlots = null, i.comparator = r.equals || void 0, Ra(i), Mf.bind(i);
}
function va(t) {
  if (_t === null) return t();
  const e = _t;
  _t = null;
  try {
    return t();
  } finally {
    _t = e;
  }
}
function mb(t) {
  Kf(() => va(t));
}
function Mf() {
  if (this.sources && this.state)
    if (this.state === vn) Ra(this);
    else {
      const t = Jt;
      Jt = null, Aa(() => cu(this), !1), Jt = t;
    }
  if (_t) {
    const t = this.observers ? this.observers.length : 0;
    _t.sources ? (_t.sources.push(this), _t.sourceSlots.push(t)) : (_t.sources = [this], _t.sourceSlots = [t]), this.observers ? (this.observers.push(_t), this.observerSlots.push(_t.sources.length - 1)) : (this.observers = [_t], this.observerSlots = [_t.sources.length - 1]);
  }
  return this.value;
}
function Nf(t, e, r) {
  let i = t.value;
  return (!t.comparator || !t.comparator(i, e)) && (t.value = e, t.observers && t.observers.length && Aa(() => {
    for (let a = 0; a < t.observers.length; a += 1) {
      const c = t.observers[a], h = oc && oc.running;
      h && oc.disposed.has(c), (h ? !c.tState : !c.state) && (c.pure ? Jt.push(c) : Oi.push(c), c.observers && jf(c)), h || (c.state = vn);
    }
    if (Jt.length > 1e6)
      throw Jt = [], new Error();
  }, !1)), e;
}
function Ra(t) {
  if (!t.fn) return;
  aa(t);
  const e = Lu;
  yb(
    t,
    t.value,
    e
  );
}
function yb(t, e, r) {
  let i;
  const a = sr, c = _t;
  _t = sr = t;
  try {
    i = t.fn(e);
  } catch (h) {
    return t.pure && (t.state = vn, t.owned && t.owned.forEach(aa), t.owned = null), t.updatedAt = r + 1, Ff(h);
  } finally {
    _t = c, sr = a;
  }
  (!t.updatedAt || t.updatedAt <= r) && (t.updatedAt != null && "observers" in t ? Nf(t, i) : t.value = i, t.updatedAt = r);
}
function Dc(t, e, r, i = vn, a) {
  const c = {
    fn: t,
    state: i,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: sr,
    context: sr ? sr.context : null,
    pure: r
  };
  return sr === null || sr !== Of && (sr.owned ? sr.owned.push(c) : sr.owned = [c]), c;
}
function uu(t) {
  if (t.state === 0) return;
  if (t.state === lu) return cu(t);
  if (t.suspense && va(t.suspense.inFallback)) return t.suspense.effects.push(t);
  const e = [t];
  for (; (t = t.owner) && (!t.updatedAt || t.updatedAt < Lu); )
    t.state && e.push(t);
  for (let r = e.length - 1; r >= 0; r--)
    if (t = e[r], t.state === vn)
      Ra(t);
    else if (t.state === lu) {
      const i = Jt;
      Jt = null, Aa(() => cu(t, e[0]), !1), Jt = i;
    }
}
function Aa(t, e) {
  if (Jt) return t();
  let r = !1;
  e || (Jt = []), Oi ? r = !0 : Oi = [], Lu++;
  try {
    const i = t();
    return bb(r), i;
  } catch (i) {
    r || (Oi = null), Jt = null, Ff(i);
  }
}
function bb(t) {
  if (Jt && (Vf(Jt), Jt = null), t) return;
  const e = Oi;
  Oi = null, e.length && Aa(() => Uf(e), !1);
}
function Vf(t) {
  for (let e = 0; e < t.length; e++) uu(t[e]);
}
function gb(t) {
  let e, r = 0;
  for (e = 0; e < t.length; e++) {
    const i = t[e];
    i.user ? t[r++] = i : uu(i);
  }
  for (e = 0; e < r; e++) uu(t[e]);
}
function cu(t, e) {
  t.state = 0;
  for (let r = 0; r < t.sources.length; r += 1) {
    const i = t.sources[r];
    if (i.sources) {
      const a = i.state;
      a === vn ? i !== e && (!i.updatedAt || i.updatedAt < Lu) && uu(i) : a === lu && cu(i, e);
    }
  }
}
function jf(t) {
  for (let e = 0; e < t.observers.length; e += 1) {
    const r = t.observers[e];
    r.state || (r.state = lu, r.pure ? Jt.push(r) : Oi.push(r), r.observers && jf(r));
  }
}
function aa(t) {
  let e;
  if (t.sources)
    for (; t.sources.length; ) {
      const r = t.sources.pop(), i = t.sourceSlots.pop(), a = r.observers;
      if (a && a.length) {
        const c = a.pop(), h = r.observerSlots.pop();
        i < a.length && (c.sourceSlots[h] = i, a[i] = c, r.observerSlots[i] = h);
      }
    }
  if (t.tOwned) {
    for (e = t.tOwned.length - 1; e >= 0; e--) aa(t.tOwned[e]);
    delete t.tOwned;
  }
  if (t.owned) {
    for (e = t.owned.length - 1; e >= 0; e--) aa(t.owned[e]);
    t.owned = null;
  }
  if (t.cleanups) {
    for (e = t.cleanups.length - 1; e >= 0; e--) t.cleanups[e]();
    t.cleanups = null;
  }
  t.state = 0;
}
function xb(t) {
  return t instanceof Error ? t : new Error(typeof t == "string" ? t : "Unknown error", {
    cause: t
  });
}
function Ff(t, e = sr) {
  throw xb(t);
}
function $f(t, e) {
  return va(() => t(e || {}));
}
function Yl() {
  return !0;
}
const Eb = {
  get(t, e, r) {
    return e === Rc ? r : t.get(e);
  },
  has(t, e) {
    return e === Rc ? !0 : t.has(e);
  },
  set: Yl,
  deleteProperty: Yl,
  getOwnPropertyDescriptor(t, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return t.get(e);
      },
      set: Yl,
      deleteProperty: Yl
    };
  },
  ownKeys(t) {
    return t.keys();
  }
};
function lc(t) {
  return (t = typeof t == "function" ? t() : t) ? t : {};
}
function vb() {
  for (let t = 0, e = this.length; t < e; ++t) {
    const r = this[t]();
    if (r !== void 0) return r;
  }
}
function Rb(...t) {
  let e = !1;
  for (let h = 0; h < t.length; h++) {
    const m = t[h];
    e = e || !!m && Rc in m, t[h] = typeof m == "function" ? (e = !0, Kr(m)) : m;
  }
  if (fb && e)
    return new Proxy(
      {
        get(h) {
          for (let m = t.length - 1; m >= 0; m--) {
            const p = lc(t[m])[h];
            if (p !== void 0) return p;
          }
        },
        has(h) {
          for (let m = t.length - 1; m >= 0; m--)
            if (h in lc(t[m])) return !0;
          return !1;
        },
        keys() {
          const h = [];
          for (let m = 0; m < t.length; m++)
            h.push(...Object.keys(lc(t[m])));
          return [...new Set(h)];
        }
      },
      Eb
    );
  const r = {}, i = /* @__PURE__ */ Object.create(null);
  for (let h = t.length - 1; h >= 0; h--) {
    const m = t[h];
    if (!m) continue;
    const p = Object.getOwnPropertyNames(m);
    for (let y = p.length - 1; y >= 0; y--) {
      const d = p[y];
      if (d === "__proto__" || d === "constructor") continue;
      const A = Object.getOwnPropertyDescriptor(m, d);
      if (!i[d])
        i[d] = A.get ? {
          enumerable: !0,
          configurable: !0,
          get: vb.bind(r[d] = [A.get.bind(m)])
        } : A.value !== void 0 ? A : void 0;
      else {
        const B = r[d];
        B && (A.get ? B.push(A.get.bind(m)) : A.value !== void 0 && B.push(() => A.value));
      }
    }
  }
  const a = {}, c = Object.keys(i);
  for (let h = c.length - 1; h >= 0; h--) {
    const m = c[h], p = i[m];
    p && p.get ? Object.defineProperty(a, m, p) : a[m] = p ? p.value : void 0;
  }
  return a;
}
function Ab(t, e, r) {
  let i = r.length, a = e.length, c = i, h = 0, m = 0, p = e[a - 1].nextSibling, y = null;
  for (; h < a || m < c; ) {
    if (e[h] === r[m]) {
      h++, m++;
      continue;
    }
    for (; e[a - 1] === r[c - 1]; )
      a--, c--;
    if (a === h) {
      const d = c < i ? m ? r[m - 1].nextSibling : r[c - m] : p;
      for (; m < c; ) t.insertBefore(r[m++], d);
    } else if (c === m)
      for (; h < a; )
        (!y || !y.has(e[h])) && e[h].remove(), h++;
    else if (e[h] === r[c - 1] && r[m] === e[a - 1]) {
      const d = e[--a].nextSibling;
      t.insertBefore(r[m++], e[h++].nextSibling), t.insertBefore(r[--c], d), e[a] = r[c];
    } else {
      if (!y) {
        y = /* @__PURE__ */ new Map();
        let A = m;
        for (; A < c; ) y.set(r[A], A++);
      }
      const d = y.get(e[h]);
      if (d != null)
        if (m < d && d < c) {
          let A = h, B = 1, K;
          for (; ++A < a && A < c && !((K = y.get(e[A])) == null || K !== d + B); )
            B++;
          if (B > d - m) {
            const O = e[h];
            for (; m < d; ) t.insertBefore(r[m++], O);
          } else t.replaceChild(r[m++], e[h++]);
        } else h++;
      else e[h++].remove();
    }
  }
}
const _d = "_$DX_DELEGATE";
function tr(t, e, r) {
  let i;
  const a = () => {
    const h = document.createElement("template");
    return h.innerHTML = t, h.content.firstChild;
  }, c = () => (i || (i = a())).cloneNode(!0);
  return c.cloneNode = c, c;
}
function Gf(t, e = window.document) {
  const r = e[_d] || (e[_d] = /* @__PURE__ */ new Set());
  for (let i = 0, a = t.length; i < a; i++) {
    const c = t[i];
    r.has(c) || (r.add(c), e.addEventListener(c, _b));
  }
}
function Bt(t, e, r) {
  r == null ? t.removeAttribute(e) : t.setAttribute(e, r);
}
function qf(t, e) {
  e == null ? t.removeAttribute("class") : t.className = e;
}
function zf(t, e, r) {
  return va(() => t(e, r));
}
function et(t, e, r, i) {
  if (r !== void 0 && !i && (i = []), typeof e != "function") return du(t, e, i, r);
  Er((a) => du(t, e(), a, r), i);
}
function _b(t) {
  let e = t.target;
  const r = `$$${t.type}`, i = t.target, a = t.currentTarget, c = (p) => Object.defineProperty(t, "target", {
    configurable: !0,
    value: p
  }), h = () => {
    const p = e[r];
    if (p && !e.disabled) {
      const y = e[`${r}Data`];
      if (y !== void 0 ? p.call(e, y, t) : p.call(e, t), t.cancelBubble) return;
    }
    return e.host && typeof e.host != "string" && !e.host._$host && e.contains(t.target) && c(e.host), !0;
  }, m = () => {
    for (; h() && (e = e._$host || e.parentNode || e.host); ) ;
  };
  if (Object.defineProperty(t, "currentTarget", {
    configurable: !0,
    get() {
      return e || document;
    }
  }), t.composedPath) {
    const p = t.composedPath();
    c(p[0]);
    for (let y = 0; y < p.length - 2 && (e = p[y], !!h()); y++) {
      if (e._$host) {
        e = e._$host, m();
        break;
      }
      if (e.parentNode === a)
        break;
    }
  } else m();
  c(i);
}
function du(t, e, r, i, a) {
  for (; typeof r == "function"; ) r = r();
  if (e === r) return r;
  const c = typeof e, h = i !== void 0;
  if (t = h && r[0] && r[0].parentNode || t, c === "string" || c === "number") {
    if (c === "number" && (e = e.toString(), e === r))
      return r;
    if (h) {
      let m = r[0];
      m && m.nodeType === 3 ? m.data !== e && (m.data = e) : m = document.createTextNode(e), r = ps(t, r, i, m);
    } else
      r !== "" && typeof r == "string" ? r = t.firstChild.data = e : r = t.textContent = e;
  } else if (e == null || c === "boolean")
    r = ps(t, r, i);
  else {
    if (c === "function")
      return Er(() => {
        let m = e();
        for (; typeof m == "function"; ) m = m();
        r = du(t, m, r, i);
      }), () => r;
    if (Array.isArray(e)) {
      const m = [], p = r && Array.isArray(r);
      if (Ac(m, e, r, a))
        return Er(() => r = du(t, m, r, i, !0)), () => r;
      if (m.length === 0) {
        if (r = ps(t, r, i), h) return r;
      } else p ? r.length === 0 ? wd(t, m, i) : Ab(t, r, m) : (r && ps(t), wd(t, m));
      r = m;
    } else if (e.nodeType) {
      if (Array.isArray(r)) {
        if (h) return r = ps(t, r, i, e);
        ps(t, r, null, e);
      } else r == null || r === "" || !t.firstChild ? t.appendChild(e) : t.replaceChild(e, t.firstChild);
      r = e;
    }
  }
  return r;
}
function Ac(t, e, r, i) {
  let a = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    let m = e[c], p = r && r[t.length], y;
    if (!(m == null || m === !0 || m === !1)) if ((y = typeof m) == "object" && m.nodeType)
      t.push(m);
    else if (Array.isArray(m))
      a = Ac(t, m, p) || a;
    else if (y === "function")
      if (i) {
        for (; typeof m == "function"; ) m = m();
        a = Ac(
          t,
          Array.isArray(m) ? m : [m],
          Array.isArray(p) ? p : [p]
        ) || a;
      } else
        t.push(m), a = !0;
    else {
      const d = String(m);
      p && p.nodeType === 3 && p.data === d ? t.push(p) : t.push(document.createTextNode(d));
    }
  }
  return a;
}
function wd(t, e, r = null) {
  for (let i = 0, a = e.length; i < a; i++) t.insertBefore(e[i], r);
}
function ps(t, e, r, i) {
  if (r === void 0) return t.textContent = "";
  const a = i || document.createTextNode("");
  if (e.length) {
    let c = !1;
    for (let h = e.length - 1; h >= 0; h--) {
      const m = e[h];
      if (a !== m) {
        const p = m.parentNode === t;
        !c && !h ? p ? t.replaceChild(a, m) : t.insertBefore(a, r) : p && m.remove();
      } else c = !0;
    }
  } else t.insertBefore(a, r);
  return [a];
}
function wb(t) {
  const e = Object.keys(t), r = {};
  for (let i = 0; i < e.length; i++) {
    const [a, c] = ra(t[e[i]]);
    Object.defineProperty(r, e[i], {
      get: a,
      set(h) {
        c(() => h);
      }
    });
  }
  return r;
}
function Tb(t) {
  if (t.assignedSlot && t.assignedSlot._$owner) return t.assignedSlot._$owner;
  let e = t.parentNode;
  for (; e && !e._$owner && !(e.assignedSlot && e.assignedSlot._$owner); )
    e = e.parentNode;
  return e && e.assignedSlot ? e.assignedSlot._$owner : t._$owner;
}
function Cb(t) {
  return (e, r) => {
    const { element: i } = r;
    return hb((a) => {
      const c = wb(e);
      i.addPropertyChangedCallback((m, p) => c[m] = p), i.addReleaseCallback(() => {
        i.renderRoot.textContent = "", a();
      });
      const h = t(c, r);
      return et(i.renderRoot, h);
    }, Tb(i));
  };
}
function Sb(t, e, r) {
  return arguments.length === 2 && (r = e, e = {}), cb(t, e)(Cb(r));
}
const Lb = '*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.right-5{right:1.25rem}.top-5{top:1.25rem}.col-span-2{grid-column:span 2 / span 2}.mx-1{margin-left:.25rem;margin-right:.25rem}.mx-auto{margin-left:auto;margin-right:auto}.mb-1{margin-bottom:.25rem}.mb-16{margin-bottom:4rem}.ml-10{margin-left:2.5rem}.mr-1{margin-right:.25rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.block{display:block}.inline{display:inline}.flex{display:flex}.grid{display:grid}.h-10{height:2.5rem}.h-14{height:3.5rem}.h-2{height:.5rem}.h-4{height:1rem}.h-full{height:100%}.w-10{width:2.5rem}.w-14{width:3.5rem}.w-4{width:1rem}.w-full{width:100%}.max-w-\\[calc\\(100vw-96px\\)\\]{max-width:calc(100vw - 96px)}.max-w-screen-sm{max-width:640px}.flex-1{flex:1 1 0%}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.whitespace-pre-wrap{white-space:pre-wrap}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-md{border-radius:.375rem}.rounded-t-md{border-top-left-radius:.375rem;border-top-right-radius:.375rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-slate-300{--tw-border-opacity: 1;border-color:rgb(203 213 225 / var(--tw-border-opacity, 1))}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity, 1))}.bg-gray-900{--tw-bg-opacity: 1;background-color:rgb(17 24 39 / var(--tw-bg-opacity, 1))}.bg-slate-100{--tw-bg-opacity: 1;background-color:rgb(241 245 249 / var(--tw-bg-opacity, 1))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity, 1))}.bg-slate-900{--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity, 1))}.object-cover{-o-object-fit:cover;object-fit:cover}.p-3{padding:.75rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-blue-500{--tw-text-opacity: 1;color:rgb(59 130 246 / var(--tw-text-opacity, 1))}.text-slate-500{--tw-text-opacity: 1;color:rgb(100 116 139 / var(--tw-text-opacity, 1))}.text-slate-600{--tw-text-opacity: 1;color:rgb(71 85 105 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.underline{text-decoration-line:underline}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop\\:bg-gray-800::backdrop{--tw-bg-opacity: 1;background-color:rgb(31 41 55 / var(--tw-bg-opacity, 1))}.backdrop\\:opacity-90::backdrop{opacity:.9}.hover\\:bg-blue-700:hover{--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity, 1))}.hover\\:underline:hover{text-decoration-line:underline}.dark\\:border-slate-800:where(.dark,.dark *){--tw-border-opacity: 1;border-color:rgb(30 41 59 / var(--tw-border-opacity, 1))}.dark\\:bg-slate-800:where(.dark,.dark *){--tw-bg-opacity: 1;background-color:rgb(30 41 59 / var(--tw-bg-opacity, 1))}.dark\\:text-slate-400:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(148 163 184 / var(--tw-text-opacity, 1))}.dark\\:text-white:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}';
var ne = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function kb(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Xf(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(i) {
    var a = Object.getOwnPropertyDescriptor(t, i);
    Object.defineProperty(r, i, a.get ? a : {
      enumerable: !0,
      get: function() {
        return t[i];
      }
    });
  }), r;
}
var Pc = {}, as = {}, Bc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DisallowedDomainError = t.UnsupportedDomainError = t.ReservedHandleError = t.InvalidHandleError = t.isValidTld = t.isValidHandle = t.normalizeAndEnsureValidHandle = t.normalizeHandle = t.ensureValidHandleRegex = t.ensureValidHandle = t.DISALLOWED_TLDS = t.INVALID_HANDLE = void 0, t.INVALID_HANDLE = "handle.invalid", t.DISALLOWED_TLDS = [
    ".local",
    ".arpa",
    ".invalid",
    ".localhost",
    ".internal",
    ".example",
    ".alt",
    // policy could concievably change on ".onion" some day
    ".onion"
    // NOTE: .test is allowed in testing and devopment. In practical terms
    // "should" "never" actually resolve and get registered in production
  ];
  const e = (A) => {
    if (!/^[a-zA-Z0-9.-]*$/.test(A))
      throw new m("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
    if (A.length > 253)
      throw new m("Handle is too long (253 chars max)");
    const B = A.split(".");
    if (B.length < 2)
      throw new m("Handle domain needs at least two parts");
    for (let K = 0; K < B.length; K++) {
      const O = B[K];
      if (O.length < 1)
        throw new m("Handle parts can not be empty");
      if (O.length > 63)
        throw new m("Handle part too long (max 63 chars)");
      if (O.endsWith("-") || O.startsWith("-"))
        throw new m("Handle parts can not start or end with hyphens");
      if (K + 1 === B.length && !/^[a-zA-Z]/.test(O))
        throw new m("Handle final component (TLD) must start with ASCII letter");
    }
  };
  t.ensureValidHandle = e;
  const r = (A) => {
    if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(A))
      throw new m("Handle didn't validate via regex");
    if (A.length > 253)
      throw new m("Handle is too long (253 chars max)");
  };
  t.ensureValidHandleRegex = r;
  const i = (A) => A.toLowerCase();
  t.normalizeHandle = i;
  const a = (A) => {
    const B = (0, t.normalizeHandle)(A);
    return (0, t.ensureValidHandle)(B), B;
  };
  t.normalizeAndEnsureValidHandle = a;
  const c = (A) => {
    try {
      (0, t.ensureValidHandle)(A);
    } catch (B) {
      if (B instanceof m)
        return !1;
      throw B;
    }
    return !0;
  };
  t.isValidHandle = c;
  const h = (A) => !t.DISALLOWED_TLDS.some((B) => A.endsWith(B));
  t.isValidTld = h;
  class m extends Error {
  }
  t.InvalidHandleError = m;
  class p extends Error {
  }
  t.ReservedHandleError = p;
  class y extends Error {
  }
  t.UnsupportedDomainError = y;
  class d extends Error {
  }
  t.DisallowedDomainError = d;
})(Bc);
var Ki = {};
Object.defineProperty(Ki, "__esModule", { value: !0 });
Ki.InvalidDidError = Ki.ensureValidDidRegex = Ki.ensureValidDid = void 0;
const Db = (t) => {
  if (!t.startsWith("did:"))
    throw new Bi('DID requires "did:" prefix');
  if (!/^[a-zA-Z0-9._:%-]*$/.test(t))
    throw new Bi("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
  const { length: e, 1: r } = t.split(":");
  if (e < 3)
    throw new Bi("DID requires prefix, method, and method-specific content");
  if (!/^[a-z]+$/.test(r))
    throw new Bi("DID method must be lower-case letters");
  if (t.endsWith(":") || t.endsWith("%"))
    throw new Bi('DID can not end with ":" or "%"');
  if (t.length > 2 * 1024)
    throw new Bi("DID is too long (2048 chars max)");
};
Ki.ensureValidDid = Db;
const Pb = (t) => {
  if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(t))
    throw new Bi("DID didn't validate via regex");
  if (t.length > 2 * 1024)
    throw new Bi("DID is too long (2048 chars max)");
};
Ki.ensureValidDidRegex = Pb;
class Bi extends Error {
}
Ki.InvalidDidError = Bi;
var Ic = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidNsidError = t.ensureValidNsidRegex = t.ensureValidNsid = t.NSID = void 0;
  class e {
    static parse(h) {
      return new e(h);
    }
    static create(h, m) {
      const p = [...h.split(".").reverse(), m].join(".");
      return new e(p);
    }
    static isValid(h) {
      try {
        return e.parse(h), !0;
      } catch {
        return !1;
      }
    }
    constructor(h) {
      Object.defineProperty(this, "segments", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), (0, t.ensureValidNsid)(h), this.segments = h.split(".");
    }
    get authority() {
      return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
    }
    get name() {
      return this.segments.at(this.segments.length - 1);
    }
    toString() {
      return this.segments.join(".");
    }
  }
  t.NSID = e;
  const r = (c) => {
    const h = c;
    if (!/^[a-zA-Z0-9.-]*$/.test(h))
      throw new a("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
    if (h.length > 317)
      throw new a("NSID is too long (317 chars max)");
    const m = h.split(".");
    if (m.length < 3)
      throw new a("NSID needs at least three parts");
    for (let p = 0; p < m.length; p++) {
      const y = m[p];
      if (y.length < 1)
        throw new a("NSID parts can not be empty");
      if (y.length > 63)
        throw new a("NSID part too long (max 63 chars)");
      if (y.endsWith("-") || y.startsWith("-"))
        throw new a("NSID parts can not start or end with hyphen");
      if (/^[0-9]/.test(y) && p === 0)
        throw new a("NSID first part may not start with a digit");
      if (!/^[a-zA-Z]+$/.test(y) && p + 1 === m.length)
        throw new a("NSID name part must be only letters");
    }
  };
  t.ensureValidNsid = r;
  const i = (c) => {
    if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(c))
      throw new a("NSID didn't validate via regex");
    if (c.length > 317)
      throw new a("NSID is too long (317 chars max)");
  };
  t.ensureValidNsidRegex = i;
  class a extends Error {
  }
  t.InvalidNsidError = a;
})(Ic);
var Hf = {}, Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.ensureValidAtUriRegex = Es.ensureValidAtUri = void 0;
const Zf = Bc, Wf = Ki, Yf = Ic, Bb = (t) => {
  const e = t.split("#");
  if (e.length > 2)
    throw new Error('ATURI can have at most one "#", separating fragment out');
  const r = e[1] || null;
  if (t = e[0], !/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(t))
    throw new Error("Disallowed characters in ATURI (ASCII)");
  const i = t.split("/");
  if (i.length >= 3 && (i[0] !== "at:" || i[1].length !== 0))
    throw new Error('ATURI must start with "at://"');
  if (i.length < 3)
    throw new Error("ATURI requires at least method and authority sections");
  try {
    i[2].startsWith("did:") ? (0, Wf.ensureValidDid)(i[2]) : (0, Zf.ensureValidHandle)(i[2]);
  } catch {
    throw new Error("ATURI authority must be a valid handle or DID");
  }
  if (i.length >= 4) {
    if (i[3].length === 0)
      throw new Error("ATURI can not have a slash after authority without a path segment");
    try {
      (0, Yf.ensureValidNsid)(i[3]);
    } catch {
      throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
    }
  }
  if (i.length >= 5 && i[4].length === 0)
    throw new Error("ATURI can not have a slash after collection, unless record key is provided");
  if (i.length >= 6)
    throw new Error("ATURI path can have at most two parts, and no trailing slash");
  if (e.length >= 2 && r == null)
    throw new Error("ATURI fragment must be non-empty and start with slash");
  if (r != null) {
    if (r.length === 0 || r[0] !== "/")
      throw new Error("ATURI fragment must be non-empty and start with slash");
    if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(r))
      throw new Error("Disallowed characters in ATURI fragment (ASCII)");
  }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
Es.ensureValidAtUri = Bb;
const Ib = (t) => {
  const e = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/, r = t.match(e);
  if (!r || !r.groups)
    throw new Error("ATURI didn't validate via regex");
  const i = r.groups;
  try {
    (0, Zf.ensureValidHandleRegex)(i.authority);
  } catch {
    try {
      (0, Wf.ensureValidDidRegex)(i.authority);
    } catch {
      throw new Error("ATURI authority must be a valid handle or DID");
    }
  }
  if (i.collection)
    try {
      (0, Yf.ensureValidNsidRegex)(i.collection);
    } catch {
      throw new Error("ATURI collection path segment must be a valid NSID");
    }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
Es.ensureValidAtUriRegex = Ib;
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(m, p, y, d) {
    d === void 0 && (d = y);
    var A = Object.getOwnPropertyDescriptor(p, y);
    (!A || ("get" in A ? !p.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
      return p[y];
    } }), Object.defineProperty(m, d, A);
  } : function(m, p, y, d) {
    d === void 0 && (d = y), m[d] = p[y];
  }), r = ne && ne.__exportStar || function(m, p) {
    for (var y in m) y !== "default" && !Object.prototype.hasOwnProperty.call(p, y) && e(p, m, y);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AtUri = t.ATP_URI_REGEX = void 0, r(Es, t), t.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
  /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  const i = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  class a {
    constructor(p, y) {
      Object.defineProperty(this, "hash", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "host", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "pathname", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "searchParams", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      });
      let d;
      if (y) {
        if (d = c(y), !d)
          throw new Error(`Invalid at uri: ${y}`);
        const A = h(p);
        if (!A)
          throw new Error(`Invalid path: ${p}`);
        Object.assign(d, A);
      } else if (d = c(p), !d)
        throw new Error(`Invalid at uri: ${p}`);
      this.hash = d.hash, this.host = d.host, this.pathname = d.pathname, this.searchParams = d.searchParams;
    }
    static make(p, y, d) {
      let A = p;
      return y && (A += "/" + y), d && (A += "/" + d), new a(A);
    }
    get protocol() {
      return "at:";
    }
    get origin() {
      return `at://${this.host}`;
    }
    get hostname() {
      return this.host;
    }
    set hostname(p) {
      this.host = p;
    }
    get search() {
      return this.searchParams.toString();
    }
    set search(p) {
      this.searchParams = new URLSearchParams(p);
    }
    get collection() {
      return this.pathname.split("/").filter(Boolean)[0] || "";
    }
    set collection(p) {
      const y = this.pathname.split("/").filter(Boolean);
      y[0] = p, this.pathname = y.join("/");
    }
    get rkey() {
      return this.pathname.split("/").filter(Boolean)[1] || "";
    }
    set rkey(p) {
      const y = this.pathname.split("/").filter(Boolean);
      y[0] || (y[0] = "undefined"), y[1] = p, this.pathname = y.join("/");
    }
    get href() {
      return this.toString();
    }
    toString() {
      let p = this.pathname || "/";
      p.startsWith("/") || (p = `/${p}`);
      let y = this.searchParams.toString();
      y && !y.startsWith("?") && (y = `?${y}`);
      let d = this.hash;
      return d && !d.startsWith("#") && (d = `#${d}`), `at://${this.host}${p}${y}${d}`;
    }
  }
  t.AtUri = a;
  function c(m) {
    const p = t.ATP_URI_REGEX.exec(m);
    if (p)
      return {
        hash: p[5] || "",
        host: p[2] || "",
        pathname: p[3] || "",
        searchParams: new URLSearchParams(p[4] || "")
      };
  }
  function h(m) {
    const p = i.exec(m);
    if (p)
      return {
        hash: p[3] || "",
        pathname: p[1] || "",
        searchParams: new URLSearchParams(p[2] || "")
      };
  }
})(Hf);
var Jf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidTidError = t.isValidTid = t.ensureValidTid = void 0;
  const e = (a) => {
    if (a.length !== 13)
      throw new i("TID must be 13 characters");
    if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(a))
      throw new i("TID syntax not valid (regex)");
  };
  t.ensureValidTid = e;
  const r = (a) => {
    try {
      (0, t.ensureValidTid)(a);
    } catch (c) {
      if (c instanceof i)
        return !1;
      throw c;
    }
    return !0;
  };
  t.isValidTid = r;
  class i extends Error {
  }
  t.InvalidTidError = i;
})(Jf);
var Qf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidRecordKeyError = t.isValidRecordKey = t.ensureValidRecordKey = void 0;
  const e = (a) => {
    if (a.length > 512 || a.length < 1)
      throw new i("record key must be 1 to 512 characters");
    if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(a))
      throw new i("record key syntax not valid (regex)");
    if (a === "." || a === "..")
      throw new i('record key can not be "." or ".."');
  };
  t.ensureValidRecordKey = e;
  const r = (a) => {
    try {
      (0, t.ensureValidRecordKey)(a);
    } catch (c) {
      if (c instanceof i)
        return !1;
      throw c;
    }
    return !0;
  };
  t.isValidRecordKey = r;
  class i extends Error {
  }
  t.InvalidRecordKeyError = i;
})(Qf);
var ep = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidDatetimeError = t.normalizeDatetimeAlways = t.normalizeDatetime = t.isValidDatetime = t.ensureValidDatetime = void 0;
  const e = (h) => {
    const m = new Date(h);
    if (isNaN(m.getTime()))
      throw new c("datetime did not parse as ISO 8601");
    if (m.toISOString().startsWith("-"))
      throw new c("datetime normalized to a negative time");
    if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(h))
      throw new c("datetime didn't validate via regex");
    if (h.length > 64)
      throw new c("datetime is too long (64 chars max)");
    if (h.endsWith("-00:00"))
      throw new c('datetime can not use "-00:00" for UTC timezone');
    if (h.startsWith("000"))
      throw new c("datetime so close to year zero not allowed");
  };
  t.ensureValidDatetime = e;
  const r = (h) => {
    try {
      (0, t.ensureValidDatetime)(h);
    } catch (m) {
      if (m instanceof c)
        return !1;
      throw m;
    }
    return !0;
  };
  t.isValidDatetime = r;
  const i = (h) => {
    if ((0, t.isValidDatetime)(h)) {
      const y = new Date(h).toISOString();
      if ((0, t.isValidDatetime)(y))
        return y;
    }
    if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(h)) {
      const y = /* @__PURE__ */ new Date(h + "Z");
      if (!isNaN(y.getTime())) {
        const d = y.toISOString();
        if ((0, t.isValidDatetime)(d))
          return d;
      }
    }
    const m = new Date(h);
    if (isNaN(m.getTime()))
      throw new c("datetime did not parse as any timestamp format");
    const p = m.toISOString();
    if ((0, t.isValidDatetime)(p))
      return p;
    throw new c("datetime normalized to invalid timestamp string");
  };
  t.normalizeDatetime = i;
  const a = (h) => {
    try {
      return (0, t.normalizeDatetime)(h);
    } catch (m) {
      if (m instanceof c)
        return (/* @__PURE__ */ new Date(0)).toISOString();
      throw m;
    }
  };
  t.normalizeDatetimeAlways = a;
  class c extends Error {
  }
  t.InvalidDatetimeError = c;
})(ep);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(i, a, c, h) {
    h === void 0 && (h = c);
    var m = Object.getOwnPropertyDescriptor(a, c);
    (!m || ("get" in m ? !a.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(i, h, m);
  } : function(i, a, c, h) {
    h === void 0 && (h = c), i[h] = a[c];
  }), r = ne && ne.__exportStar || function(i, a) {
    for (var c in i) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && e(a, i, c);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Bc, t), r(Ki, t), r(Ic, t), r(Hf, t), r(Jf, t), r(Qf, t), r(ep, t);
})(as);
var _a = {}, Rn = {}, os = {}, _c = {}, ci = {}, ku = {}, wa = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0;
  var e;
  (function(a) {
    a.assertEqual = (p) => p;
    function c(p) {
    }
    a.assertIs = c;
    function h(p) {
      throw new Error();
    }
    a.assertNever = h, a.arrayToEnum = (p) => {
      const y = {};
      for (const d of p)
        y[d] = d;
      return y;
    }, a.getValidEnumValues = (p) => {
      const y = a.objectKeys(p).filter((A) => typeof p[p[A]] != "number"), d = {};
      for (const A of y)
        d[A] = p[A];
      return a.objectValues(d);
    }, a.objectValues = (p) => a.objectKeys(p).map(function(y) {
      return p[y];
    }), a.objectKeys = typeof Object.keys == "function" ? (p) => Object.keys(p) : (p) => {
      const y = [];
      for (const d in p)
        Object.prototype.hasOwnProperty.call(p, d) && y.push(d);
      return y;
    }, a.find = (p, y) => {
      for (const d of p)
        if (y(d))
          return d;
    }, a.isInteger = typeof Number.isInteger == "function" ? (p) => Number.isInteger(p) : (p) => typeof p == "number" && isFinite(p) && Math.floor(p) === p;
    function m(p, y = " | ") {
      return p.map((d) => typeof d == "string" ? `'${d}'` : d).join(y);
    }
    a.joinValues = m, a.jsonStringifyReplacer = (p, y) => typeof y == "bigint" ? y.toString() : y;
  })(e || (t.util = e = {}));
  var r;
  (function(a) {
    a.mergeShapes = (c, h) => ({
      ...c,
      ...h
      // second overwrites first
    });
  })(r || (t.objectUtil = r = {})), t.ZodParsedType = e.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const i = (a) => {
    switch (typeof a) {
      case "undefined":
        return t.ZodParsedType.undefined;
      case "string":
        return t.ZodParsedType.string;
      case "number":
        return isNaN(a) ? t.ZodParsedType.nan : t.ZodParsedType.number;
      case "boolean":
        return t.ZodParsedType.boolean;
      case "function":
        return t.ZodParsedType.function;
      case "bigint":
        return t.ZodParsedType.bigint;
      case "symbol":
        return t.ZodParsedType.symbol;
      case "object":
        return Array.isArray(a) ? t.ZodParsedType.array : a === null ? t.ZodParsedType.null : a.then && typeof a.then == "function" && a.catch && typeof a.catch == "function" ? t.ZodParsedType.promise : typeof Map < "u" && a instanceof Map ? t.ZodParsedType.map : typeof Set < "u" && a instanceof Set ? t.ZodParsedType.set : typeof Date < "u" && a instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;
      default:
        return t.ZodParsedType.unknown;
    }
  };
  t.getParsedType = i;
})(wa);
var di = {};
Object.defineProperty(di, "__esModule", { value: !0 });
di.ZodError = di.quotelessJson = di.ZodIssueCode = void 0;
const tp = wa;
di.ZodIssueCode = tp.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const Ub = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
di.quotelessJson = Ub;
class oa extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (i) => {
      this.issues = [...this.issues, i];
    }, this.addIssues = (i = []) => {
      this.issues = [...this.issues, ...i];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const r = e || function(c) {
      return c.message;
    }, i = { _errors: [] }, a = (c) => {
      for (const h of c.issues)
        if (h.code === "invalid_union")
          h.unionErrors.map(a);
        else if (h.code === "invalid_return_type")
          a(h.returnTypeError);
        else if (h.code === "invalid_arguments")
          a(h.argumentsError);
        else if (h.path.length === 0)
          i._errors.push(r(h));
        else {
          let m = i, p = 0;
          for (; p < h.path.length; ) {
            const y = h.path[p];
            p === h.path.length - 1 ? (m[y] = m[y] || { _errors: [] }, m[y]._errors.push(r(h))) : m[y] = m[y] || { _errors: [] }, m = m[y], p++;
          }
        }
    };
    return a(this), i;
  }
  static assert(e) {
    if (!(e instanceof oa))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, tp.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, i = [];
    for (const a of this.issues)
      a.path.length > 0 ? (r[a.path[0]] = r[a.path[0]] || [], r[a.path[0]].push(e(a))) : i.push(e(a));
    return { formErrors: i, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
di.ZodError = oa;
oa.create = (t) => new oa(t);
Object.defineProperty(ku, "__esModule", { value: !0 });
const Bn = wa, Ht = di, Ob = (t, e) => {
  let r;
  switch (t.code) {
    case Ht.ZodIssueCode.invalid_type:
      t.received === Bn.ZodParsedType.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case Ht.ZodIssueCode.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, Bn.util.jsonStringifyReplacer)}`;
      break;
    case Ht.ZodIssueCode.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Bn.util.joinValues(t.keys, ", ")}`;
      break;
    case Ht.ZodIssueCode.invalid_union:
      r = "Invalid input";
      break;
    case Ht.ZodIssueCode.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Bn.util.joinValues(t.options)}`;
      break;
    case Ht.ZodIssueCode.invalid_enum_value:
      r = `Invalid enum value. Expected ${Bn.util.joinValues(t.options)}, received '${t.received}'`;
      break;
    case Ht.ZodIssueCode.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Ht.ZodIssueCode.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Ht.ZodIssueCode.invalid_date:
      r = "Invalid date";
      break;
    case Ht.ZodIssueCode.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : Bn.util.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case Ht.ZodIssueCode.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case Ht.ZodIssueCode.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case Ht.ZodIssueCode.custom:
      r = "Invalid input";
      break;
    case Ht.ZodIssueCode.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Ht.ZodIssueCode.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Ht.ZodIssueCode.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, Bn.util.assertNever(t);
  }
  return { message: r };
};
ku.default = Ob;
var Kb = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(ci, "__esModule", { value: !0 });
ci.getErrorMap = ci.setErrorMap = ci.defaultErrorMap = void 0;
const rp = Kb(ku);
ci.defaultErrorMap = rp.default;
let ip = rp.default;
function Mb(t) {
  ip = t;
}
ci.setErrorMap = Mb;
function Nb() {
  return ip;
}
ci.getErrorMap = Nb;
var Uc = {};
(function(t) {
  var e = ne && ne.__importDefault || function(K) {
    return K && K.__esModule ? K : { default: K };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;
  const r = ci, i = e(ku), a = (K) => {
    const { data: O, path: z, errorMaps: X, issueData: H } = K, V = [...z, ...H.path || []], G = {
      ...H,
      path: V
    };
    if (H.message !== void 0)
      return {
        ...H,
        path: V,
        message: H.message
      };
    let Z = "";
    const ae = X.filter((se) => !!se).slice().reverse();
    for (const se of ae)
      Z = se(G, { data: O, defaultError: Z }).message;
    return {
      ...H,
      path: V,
      message: Z
    };
  };
  t.makeIssue = a, t.EMPTY_PATH = [];
  function c(K, O) {
    const z = (0, r.getErrorMap)(), X = (0, t.makeIssue)({
      issueData: O,
      data: K.data,
      path: K.path,
      errorMaps: [
        K.common.contextualErrorMap,
        // contextual error map is first priority
        K.schemaErrorMap,
        // then schema-bound map if available
        z,
        // then global override map
        z === i.default ? void 0 : i.default
        // then global default map
      ].filter((H) => !!H)
    });
    K.common.issues.push(X);
  }
  t.addIssueToContext = c;
  class h {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(O, z) {
      const X = [];
      for (const H of z) {
        if (H.status === "aborted")
          return t.INVALID;
        H.status === "dirty" && O.dirty(), X.push(H.value);
      }
      return { status: O.value, value: X };
    }
    static async mergeObjectAsync(O, z) {
      const X = [];
      for (const H of z) {
        const V = await H.key, G = await H.value;
        X.push({
          key: V,
          value: G
        });
      }
      return h.mergeObjectSync(O, X);
    }
    static mergeObjectSync(O, z) {
      const X = {};
      for (const H of z) {
        const { key: V, value: G } = H;
        if (V.status === "aborted" || G.status === "aborted")
          return t.INVALID;
        V.status === "dirty" && O.dirty(), G.status === "dirty" && O.dirty(), V.value !== "__proto__" && (typeof G.value < "u" || H.alwaysSet) && (X[V.value] = G.value);
      }
      return { status: O.value, value: X };
    }
  }
  t.ParseStatus = h, t.INVALID = Object.freeze({
    status: "aborted"
  });
  const m = (K) => ({ status: "dirty", value: K });
  t.DIRTY = m;
  const p = (K) => ({ status: "valid", value: K });
  t.OK = p;
  const y = (K) => K.status === "aborted";
  t.isAborted = y;
  const d = (K) => K.status === "dirty";
  t.isDirty = d;
  const A = (K) => K.status === "valid";
  t.isValid = A;
  const B = (K) => typeof Promise < "u" && K instanceof Promise;
  t.isAsync = B;
})(Uc);
var np = {};
Object.defineProperty(np, "__esModule", { value: !0 });
var j = {}, Du = {};
Object.defineProperty(Du, "__esModule", { value: !0 });
Du.errorUtil = void 0;
var Td;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(Td || (Du.errorUtil = Td = {}));
var fu = ne && ne.__classPrivateFieldGet || function(t, e, r, i) {
  if (r === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? i : r === "a" ? i.call(t) : i ? i.value : e.get(t);
}, sp = ne && ne.__classPrivateFieldSet || function(t, e, r, i, a) {
  if (i === "m") throw new TypeError("Private method is not writable");
  if (i === "a" && !a) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? a.call(t, r) : a ? a.value = r : e.set(t, r), r;
}, ia, na;
Object.defineProperty(j, "__esModule", { value: !0 });
j.boolean = j.bigint = j.array = j.any = j.coerce = j.ZodFirstPartyTypeKind = j.late = j.ZodSchema = j.Schema = j.custom = j.ZodReadonly = j.ZodPipeline = j.ZodBranded = j.BRAND = j.ZodNaN = j.ZodCatch = j.ZodDefault = j.ZodNullable = j.ZodOptional = j.ZodTransformer = j.ZodEffects = j.ZodPromise = j.ZodNativeEnum = j.ZodEnum = j.ZodLiteral = j.ZodLazy = j.ZodFunction = j.ZodSet = j.ZodMap = j.ZodRecord = j.ZodTuple = j.ZodIntersection = j.ZodDiscriminatedUnion = j.ZodUnion = j.ZodObject = j.ZodArray = j.ZodVoid = j.ZodNever = j.ZodUnknown = j.ZodAny = j.ZodNull = j.ZodUndefined = j.ZodSymbol = j.ZodDate = j.ZodBoolean = j.ZodBigInt = j.ZodNumber = j.ZodString = j.datetimeRegex = j.ZodType = void 0;
j.NEVER = j.void = j.unknown = j.union = j.undefined = j.tuple = j.transformer = j.symbol = j.string = j.strictObject = j.set = j.record = j.promise = j.preprocess = j.pipeline = j.ostring = j.optional = j.onumber = j.oboolean = j.object = j.number = j.nullable = j.null = j.never = j.nativeEnum = j.nan = j.map = j.literal = j.lazy = j.intersection = j.instanceof = j.function = j.enum = j.effect = j.discriminatedUnion = j.date = void 0;
const Jl = ci, ve = Du, $ = Uc, ye = wa, fe = di;
class pi {
  constructor(e, r, i, a) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = i, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Cd = (t, e) => {
  if ((0, $.isValid)(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new fe.ZodError(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function Ke(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: i, description: a } = t;
  if (e && (r || i))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: a } : { errorMap: (h, m) => {
    var p, y;
    const { message: d } = t;
    return h.code === "invalid_enum_value" ? { message: d ?? m.defaultError } : typeof m.data > "u" ? { message: (p = d ?? i) !== null && p !== void 0 ? p : m.defaultError } : h.code !== "invalid_type" ? { message: m.defaultError } : { message: (y = d ?? r) !== null && y !== void 0 ? y : m.defaultError };
  }, description: a };
}
class Ve {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return (0, ye.getParsedType)(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: (0, ye.getParsedType)(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new $.ParseStatus(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: (0, ye.getParsedType)(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if ((0, $.isAsync)(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const i = this.safeParse(e, r);
    if (i.success)
      return i.data;
    throw i.error;
  }
  safeParse(e, r) {
    var i;
    const a = {
      common: {
        issues: [],
        async: (i = r?.async) !== null && i !== void 0 ? i : !1,
        contextualErrorMap: r?.errorMap
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: (0, ye.getParsedType)(e)
    }, c = this._parseSync({ data: e, path: a.path, parent: a });
    return Cd(a, c);
  }
  "~validate"(e) {
    var r, i;
    const a = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: (0, ye.getParsedType)(e)
    };
    if (!this["~standard"].async)
      try {
        const c = this._parseSync({ data: e, path: [], parent: a });
        return (0, $.isValid)(c) ? {
          value: c.value
        } : {
          issues: a.common.issues
        };
      } catch (c) {
        !((i = (r = c?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || i === void 0) && i.includes("encountered") && (this["~standard"].async = !0), a.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: a }).then((c) => (0, $.isValid)(c) ? {
      value: c.value
    } : {
      issues: a.common.issues
    });
  }
  async parseAsync(e, r) {
    const i = await this.safeParseAsync(e, r);
    if (i.success)
      return i.data;
    throw i.error;
  }
  async safeParseAsync(e, r) {
    const i = {
      common: {
        issues: [],
        contextualErrorMap: r?.errorMap,
        async: !0
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: (0, ye.getParsedType)(e)
    }, a = this._parse({ data: e, path: i.path, parent: i }), c = await ((0, $.isAsync)(a) ? a : Promise.resolve(a));
    return Cd(i, c);
  }
  refine(e, r) {
    const i = (a) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(a) : r;
    return this._refinement((a, c) => {
      const h = e(a), m = () => c.addIssue({
        code: fe.ZodIssueCode.custom,
        ...i(a)
      });
      return typeof Promise < "u" && h instanceof Promise ? h.then((p) => p ? !0 : (m(), !1)) : h ? !0 : (m(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((i, a) => e(i) ? !0 : (a.addIssue(typeof r == "function" ? r(i, a) : r), !1));
  }
  _refinement(e) {
    return new qr({
      schema: this,
      typeName: ke.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (r) => this["~validate"](r)
    };
  }
  optional() {
    return fi.create(this, this._def);
  }
  nullable() {
    return hn.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Gr.create(this);
  }
  promise() {
    return Rs.create(this, this._def);
  }
  or(e) {
    return da.create([this, e], this._def);
  }
  and(e) {
    return fa.create(this, e, this._def);
  }
  transform(e) {
    return new qr({
      ...Ke(this._def),
      schema: this,
      typeName: ke.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new ba({
      ...Ke(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ke.ZodDefault
    });
  }
  brand() {
    return new Oc({
      typeName: ke.ZodBranded,
      type: this,
      ...Ke(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new ga({
      ...Ke(this._def),
      innerType: this,
      catchValue: r,
      typeName: ke.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Ta.create(this, e);
  }
  readonly() {
    return xa.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
j.ZodType = Ve;
j.Schema = Ve;
j.ZodSchema = Ve;
const Vb = /^c[^\s-]{8,}$/i, jb = /^[0-9a-z]+$/, Fb = /^[0-9A-HJKMNP-TV-Z]{26}$/i, $b = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Gb = /^[a-z0-9_-]{21}$/i, qb = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, zb = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Xb = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Hb = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let uc;
const Zb = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Wb = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Yb = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, Jb = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Qb = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, eg = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, ap = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", tg = new RegExp(`^${ap}$`);
function op(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function rg(t) {
  return new RegExp(`^${op(t)}$`);
}
function lp(t) {
  let e = `${ap}T${op(t)}`;
  const r = [];
  return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, new RegExp(`^${e}$`);
}
j.datetimeRegex = lp;
function ig(t, e) {
  return !!((e === "v4" || !e) && Zb.test(t) || (e === "v6" || !e) && Yb.test(t));
}
function ng(t, e) {
  if (!qb.test(t))
    return !1;
  try {
    const [r] = t.split("."), i = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), a = JSON.parse(atob(i));
    return !(typeof a != "object" || a === null || !a.typ || !a.alg || e && a.alg !== e);
  } catch {
    return !1;
  }
}
function sg(t, e) {
  return !!((e === "v4" || !e) && Wb.test(t) || (e === "v6" || !e) && Jb.test(t));
}
class Mr extends Ve {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== ye.ZodParsedType.string) {
      const c = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(c, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.string,
        received: c.parsedType
      }), $.INVALID;
    }
    const i = new $.ParseStatus();
    let a;
    for (const c of this._def.checks)
      if (c.kind === "min")
        e.data.length < c.value && (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          code: fe.ZodIssueCode.too_small,
          minimum: c.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: c.message
        }), i.dirty());
      else if (c.kind === "max")
        e.data.length > c.value && (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          code: fe.ZodIssueCode.too_big,
          maximum: c.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: c.message
        }), i.dirty());
      else if (c.kind === "length") {
        const h = e.data.length > c.value, m = e.data.length < c.value;
        (h || m) && (a = this._getOrReturnCtx(e, a), h ? (0, $.addIssueToContext)(a, {
          code: fe.ZodIssueCode.too_big,
          maximum: c.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: c.message
        }) : m && (0, $.addIssueToContext)(a, {
          code: fe.ZodIssueCode.too_small,
          minimum: c.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: c.message
        }), i.dirty());
      } else if (c.kind === "email")
        Xb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          validation: "email",
          code: fe.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "emoji")
        uc || (uc = new RegExp(Hb, "u")), uc.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          validation: "emoji",
          code: fe.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "uuid")
        $b.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          validation: "uuid",
          code: fe.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "nanoid")
        Gb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          validation: "nanoid",
          code: fe.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "cuid")
        Vb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          validation: "cuid",
          code: fe.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "cuid2")
        jb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          validation: "cuid2",
          code: fe.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "ulid")
        Fb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
          validation: "ulid",
          code: fe.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "url")
        try {
          new URL(e.data);
        } catch {
          a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
            validation: "url",
            code: fe.ZodIssueCode.invalid_string,
            message: c.message
          }), i.dirty();
        }
      else c.kind === "regex" ? (c.regex.lastIndex = 0, c.regex.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        validation: "regex",
        code: fe.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty())) : c.kind === "trim" ? e.data = e.data.trim() : c.kind === "includes" ? e.data.includes(c.value, c.position) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        code: fe.ZodIssueCode.invalid_string,
        validation: { includes: c.value, position: c.position },
        message: c.message
      }), i.dirty()) : c.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : c.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : c.kind === "startsWith" ? e.data.startsWith(c.value) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        code: fe.ZodIssueCode.invalid_string,
        validation: { startsWith: c.value },
        message: c.message
      }), i.dirty()) : c.kind === "endsWith" ? e.data.endsWith(c.value) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        code: fe.ZodIssueCode.invalid_string,
        validation: { endsWith: c.value },
        message: c.message
      }), i.dirty()) : c.kind === "datetime" ? lp(c).test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        code: fe.ZodIssueCode.invalid_string,
        validation: "datetime",
        message: c.message
      }), i.dirty()) : c.kind === "date" ? tg.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        code: fe.ZodIssueCode.invalid_string,
        validation: "date",
        message: c.message
      }), i.dirty()) : c.kind === "time" ? rg(c).test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        code: fe.ZodIssueCode.invalid_string,
        validation: "time",
        message: c.message
      }), i.dirty()) : c.kind === "duration" ? zb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        validation: "duration",
        code: fe.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "ip" ? ig(e.data, c.version) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        validation: "ip",
        code: fe.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "jwt" ? ng(e.data, c.alg) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        validation: "jwt",
        code: fe.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "cidr" ? sg(e.data, c.version) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        validation: "cidr",
        code: fe.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "base64" ? Qb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        validation: "base64",
        code: fe.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "base64url" ? eg.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        validation: "base64url",
        code: fe.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : ye.util.assertNever(c);
    return { status: i.value, value: e.data };
  }
  _regex(e, r, i) {
    return this.refinement((a) => e.test(a), {
      validation: r,
      code: fe.ZodIssueCode.invalid_string,
      ...ve.errorUtil.errToObj(i)
    });
  }
  _addCheck(e) {
    return new Mr({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...ve.errorUtil.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...ve.errorUtil.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...ve.errorUtil.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...ve.errorUtil.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...ve.errorUtil.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...ve.errorUtil.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...ve.errorUtil.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...ve.errorUtil.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...ve.errorUtil.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...ve.errorUtil.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...ve.errorUtil.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...ve.errorUtil.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...ve.errorUtil.errToObj(e) });
  }
  datetime(e) {
    var r, i;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (r = e?.offset) !== null && r !== void 0 ? r : !1,
      local: (i = e?.local) !== null && i !== void 0 ? i : !1,
      ...ve.errorUtil.errToObj(e?.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      ...ve.errorUtil.errToObj(e?.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...ve.errorUtil.errToObj(e) });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...ve.errorUtil.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r?.position,
      ...ve.errorUtil.errToObj(r?.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...ve.errorUtil.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...ve.errorUtil.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...ve.errorUtil.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...ve.errorUtil.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...ve.errorUtil.errToObj(r)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, ve.errorUtil.errToObj(e));
  }
  trim() {
    return new Mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
j.ZodString = Mr;
Mr.create = (t) => {
  var e;
  return new Mr({
    checks: [],
    typeName: ke.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...Ke(t)
  });
};
function ag(t, e) {
  const r = (t.toString().split(".")[1] || "").length, i = (e.toString().split(".")[1] || "").length, a = r > i ? r : i, c = parseInt(t.toFixed(a).replace(".", "")), h = parseInt(e.toFixed(a).replace(".", ""));
  return c % h / Math.pow(10, a);
}
class dn extends Ve {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== ye.ZodParsedType.number) {
      const c = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(c, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.number,
        received: c.parsedType
      }), $.INVALID;
    }
    let i;
    const a = new $.ParseStatus();
    for (const c of this._def.checks)
      c.kind === "int" ? ye.util.isInteger(e.data) || (i = this._getOrReturnCtx(e, i), (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: c.message
      }), a.dirty()) : c.kind === "min" ? (c.inclusive ? e.data < c.value : e.data <= c.value) && (i = this._getOrReturnCtx(e, i), (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.too_small,
        minimum: c.value,
        type: "number",
        inclusive: c.inclusive,
        exact: !1,
        message: c.message
      }), a.dirty()) : c.kind === "max" ? (c.inclusive ? e.data > c.value : e.data >= c.value) && (i = this._getOrReturnCtx(e, i), (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.too_big,
        maximum: c.value,
        type: "number",
        inclusive: c.inclusive,
        exact: !1,
        message: c.message
      }), a.dirty()) : c.kind === "multipleOf" ? ag(e.data, c.value) !== 0 && (i = this._getOrReturnCtx(e, i), (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.not_multiple_of,
        multipleOf: c.value,
        message: c.message
      }), a.dirty()) : c.kind === "finite" ? Number.isFinite(e.data) || (i = this._getOrReturnCtx(e, i), (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.not_finite,
        message: c.message
      }), a.dirty()) : ye.util.assertNever(c);
    return { status: a.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, ve.errorUtil.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, ve.errorUtil.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, ve.errorUtil.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, ve.errorUtil.toString(r));
  }
  setLimit(e, r, i, a) {
    return new dn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: i,
          message: ve.errorUtil.toString(a)
        }
      ]
    });
  }
  _addCheck(e) {
    return new dn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: ve.errorUtil.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ve.errorUtil.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ve.errorUtil.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ve.errorUtil.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ve.errorUtil.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ve.errorUtil.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: ve.errorUtil.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ve.errorUtil.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ve.errorUtil.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && ye.util.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const i of this._def.checks) {
      if (i.kind === "finite" || i.kind === "int" || i.kind === "multipleOf")
        return !0;
      i.kind === "min" ? (r === null || i.value > r) && (r = i.value) : i.kind === "max" && (e === null || i.value < e) && (e = i.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
j.ZodNumber = dn;
dn.create = (t) => new dn({
  checks: [],
  typeName: ke.ZodNumber,
  coerce: t?.coerce || !1,
  ...Ke(t)
});
class fn extends Ve {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== ye.ZodParsedType.bigint)
      return this._getInvalidInput(e);
    let i;
    const a = new $.ParseStatus();
    for (const c of this._def.checks)
      c.kind === "min" ? (c.inclusive ? e.data < c.value : e.data <= c.value) && (i = this._getOrReturnCtx(e, i), (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.too_small,
        type: "bigint",
        minimum: c.value,
        inclusive: c.inclusive,
        message: c.message
      }), a.dirty()) : c.kind === "max" ? (c.inclusive ? e.data > c.value : e.data >= c.value) && (i = this._getOrReturnCtx(e, i), (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.too_big,
        type: "bigint",
        maximum: c.value,
        inclusive: c.inclusive,
        message: c.message
      }), a.dirty()) : c.kind === "multipleOf" ? e.data % c.value !== BigInt(0) && (i = this._getOrReturnCtx(e, i), (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.not_multiple_of,
        multipleOf: c.value,
        message: c.message
      }), a.dirty()) : ye.util.assertNever(c);
    return { status: a.value, value: e.data };
  }
  _getInvalidInput(e) {
    const r = this._getOrReturnCtx(e);
    return (0, $.addIssueToContext)(r, {
      code: fe.ZodIssueCode.invalid_type,
      expected: ye.ZodParsedType.bigint,
      received: r.parsedType
    }), $.INVALID;
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, ve.errorUtil.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, ve.errorUtil.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, ve.errorUtil.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, ve.errorUtil.toString(r));
  }
  setLimit(e, r, i, a) {
    return new fn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: i,
          message: ve.errorUtil.toString(a)
        }
      ]
    });
  }
  _addCheck(e) {
    return new fn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ve.errorUtil.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ve.errorUtil.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ve.errorUtil.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ve.errorUtil.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ve.errorUtil.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
j.ZodBigInt = fn;
fn.create = (t) => {
  var e;
  return new fn({
    checks: [],
    typeName: ke.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...Ke(t)
  });
};
class la extends Ve {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== ye.ZodParsedType.boolean) {
      const i = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.boolean,
        received: i.parsedType
      }), $.INVALID;
    }
    return (0, $.OK)(e.data);
  }
}
j.ZodBoolean = la;
la.create = (t) => new la({
  typeName: ke.ZodBoolean,
  coerce: t?.coerce || !1,
  ...Ke(t)
});
class Kn extends Ve {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== ye.ZodParsedType.date) {
      const c = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(c, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.date,
        received: c.parsedType
      }), $.INVALID;
    }
    if (isNaN(e.data.getTime())) {
      const c = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(c, {
        code: fe.ZodIssueCode.invalid_date
      }), $.INVALID;
    }
    const i = new $.ParseStatus();
    let a;
    for (const c of this._def.checks)
      c.kind === "min" ? e.data.getTime() < c.value && (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        code: fe.ZodIssueCode.too_small,
        message: c.message,
        inclusive: !0,
        exact: !1,
        minimum: c.value,
        type: "date"
      }), i.dirty()) : c.kind === "max" ? e.data.getTime() > c.value && (a = this._getOrReturnCtx(e, a), (0, $.addIssueToContext)(a, {
        code: fe.ZodIssueCode.too_big,
        message: c.message,
        inclusive: !0,
        exact: !1,
        maximum: c.value,
        type: "date"
      }), i.dirty()) : ye.util.assertNever(c);
    return {
      status: i.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Kn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: ve.errorUtil.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: ve.errorUtil.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
j.ZodDate = Kn;
Kn.create = (t) => new Kn({
  checks: [],
  coerce: t?.coerce || !1,
  typeName: ke.ZodDate,
  ...Ke(t)
});
class pu extends Ve {
  _parse(e) {
    if (this._getType(e) !== ye.ZodParsedType.symbol) {
      const i = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.symbol,
        received: i.parsedType
      }), $.INVALID;
    }
    return (0, $.OK)(e.data);
  }
}
j.ZodSymbol = pu;
pu.create = (t) => new pu({
  typeName: ke.ZodSymbol,
  ...Ke(t)
});
class ua extends Ve {
  _parse(e) {
    if (this._getType(e) !== ye.ZodParsedType.undefined) {
      const i = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.undefined,
        received: i.parsedType
      }), $.INVALID;
    }
    return (0, $.OK)(e.data);
  }
}
j.ZodUndefined = ua;
ua.create = (t) => new ua({
  typeName: ke.ZodUndefined,
  ...Ke(t)
});
class ca extends Ve {
  _parse(e) {
    if (this._getType(e) !== ye.ZodParsedType.null) {
      const i = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.null,
        received: i.parsedType
      }), $.INVALID;
    }
    return (0, $.OK)(e.data);
  }
}
j.ZodNull = ca;
ca.create = (t) => new ca({
  typeName: ke.ZodNull,
  ...Ke(t)
});
class vs extends Ve {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return (0, $.OK)(e.data);
  }
}
j.ZodAny = vs;
vs.create = (t) => new vs({
  typeName: ke.ZodAny,
  ...Ke(t)
});
class On extends Ve {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return (0, $.OK)(e.data);
  }
}
j.ZodUnknown = On;
On.create = (t) => new On({
  typeName: ke.ZodUnknown,
  ...Ke(t)
});
class en extends Ve {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return (0, $.addIssueToContext)(r, {
      code: fe.ZodIssueCode.invalid_type,
      expected: ye.ZodParsedType.never,
      received: r.parsedType
    }), $.INVALID;
  }
}
j.ZodNever = en;
en.create = (t) => new en({
  typeName: ke.ZodNever,
  ...Ke(t)
});
class hu extends Ve {
  _parse(e) {
    if (this._getType(e) !== ye.ZodParsedType.undefined) {
      const i = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.void,
        received: i.parsedType
      }), $.INVALID;
    }
    return (0, $.OK)(e.data);
  }
}
j.ZodVoid = hu;
hu.create = (t) => new hu({
  typeName: ke.ZodVoid,
  ...Ke(t)
});
class Gr extends Ve {
  _parse(e) {
    const { ctx: r, status: i } = this._processInputParams(e), a = this._def;
    if (r.parsedType !== ye.ZodParsedType.array)
      return (0, $.addIssueToContext)(r, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.array,
        received: r.parsedType
      }), $.INVALID;
    if (a.exactLength !== null) {
      const h = r.data.length > a.exactLength.value, m = r.data.length < a.exactLength.value;
      (h || m) && ((0, $.addIssueToContext)(r, {
        code: h ? fe.ZodIssueCode.too_big : fe.ZodIssueCode.too_small,
        minimum: m ? a.exactLength.value : void 0,
        maximum: h ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), i.dirty());
    }
    if (a.minLength !== null && r.data.length < a.minLength.value && ((0, $.addIssueToContext)(r, {
      code: fe.ZodIssueCode.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), i.dirty()), a.maxLength !== null && r.data.length > a.maxLength.value && ((0, $.addIssueToContext)(r, {
      code: fe.ZodIssueCode.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), i.dirty()), r.common.async)
      return Promise.all([...r.data].map((h, m) => a.type._parseAsync(new pi(r, h, r.path, m)))).then((h) => $.ParseStatus.mergeArray(i, h));
    const c = [...r.data].map((h, m) => a.type._parseSync(new pi(r, h, r.path, m)));
    return $.ParseStatus.mergeArray(i, c);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new Gr({
      ...this._def,
      minLength: { value: e, message: ve.errorUtil.toString(r) }
    });
  }
  max(e, r) {
    return new Gr({
      ...this._def,
      maxLength: { value: e, message: ve.errorUtil.toString(r) }
    });
  }
  length(e, r) {
    return new Gr({
      ...this._def,
      exactLength: { value: e, message: ve.errorUtil.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
j.ZodArray = Gr;
Gr.create = (t, e) => new Gr({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ke.ZodArray,
  ...Ke(e)
});
function ys(t) {
  if (t instanceof ft) {
    const e = {};
    for (const r in t.shape) {
      const i = t.shape[r];
      e[r] = fi.create(ys(i));
    }
    return new ft({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof Gr ? new Gr({
    ...t._def,
    type: ys(t.element)
  }) : t instanceof fi ? fi.create(ys(t.unwrap())) : t instanceof hn ? hn.create(ys(t.unwrap())) : t instanceof hi ? hi.create(t.items.map((e) => ys(e))) : t;
}
class ft extends Ve {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = ye.util.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== ye.ZodParsedType.object) {
      const y = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(y, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.object,
        received: y.parsedType
      }), $.INVALID;
    }
    const { status: i, ctx: a } = this._processInputParams(e), { shape: c, keys: h } = this._getCached(), m = [];
    if (!(this._def.catchall instanceof en && this._def.unknownKeys === "strip"))
      for (const y in a.data)
        h.includes(y) || m.push(y);
    const p = [];
    for (const y of h) {
      const d = c[y], A = a.data[y];
      p.push({
        key: { status: "valid", value: y },
        value: d._parse(new pi(a, A, a.path, y)),
        alwaysSet: y in a.data
      });
    }
    if (this._def.catchall instanceof en) {
      const y = this._def.unknownKeys;
      if (y === "passthrough")
        for (const d of m)
          p.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: a.data[d] }
          });
      else if (y === "strict")
        m.length > 0 && ((0, $.addIssueToContext)(a, {
          code: fe.ZodIssueCode.unrecognized_keys,
          keys: m
        }), i.dirty());
      else if (y !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const y = this._def.catchall;
      for (const d of m) {
        const A = a.data[d];
        p.push({
          key: { status: "valid", value: d },
          value: y._parse(
            new pi(a, A, a.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(async () => {
      const y = [];
      for (const d of p) {
        const A = await d.key, B = await d.value;
        y.push({
          key: A,
          value: B,
          alwaysSet: d.alwaysSet
        });
      }
      return y;
    }).then((y) => $.ParseStatus.mergeObjectSync(i, y)) : $.ParseStatus.mergeObjectSync(i, p);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return ve.errorUtil.errToObj, new ft({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, i) => {
          var a, c, h, m;
          const p = (h = (c = (a = this._def).errorMap) === null || c === void 0 ? void 0 : c.call(a, r, i).message) !== null && h !== void 0 ? h : i.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (m = ve.errorUtil.errToObj(e).message) !== null && m !== void 0 ? m : p
          } : {
            message: p
          };
        }
      } : {}
    });
  }
  strip() {
    return new ft({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ft({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new ft({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new ft({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: ke.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new ft({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return ye.util.objectKeys(e).forEach((i) => {
      e[i] && this.shape[i] && (r[i] = this.shape[i]);
    }), new ft({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return ye.util.objectKeys(this.shape).forEach((i) => {
      e[i] || (r[i] = this.shape[i]);
    }), new ft({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ys(this);
  }
  partial(e) {
    const r = {};
    return ye.util.objectKeys(this.shape).forEach((i) => {
      const a = this.shape[i];
      e && !e[i] ? r[i] = a : r[i] = a.optional();
    }), new ft({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return ye.util.objectKeys(this.shape).forEach((i) => {
      if (e && !e[i])
        r[i] = this.shape[i];
      else {
        let c = this.shape[i];
        for (; c instanceof fi; )
          c = c._def.innerType;
        r[i] = c;
      }
    }), new ft({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return up(ye.util.objectKeys(this.shape));
  }
}
j.ZodObject = ft;
ft.create = (t, e) => new ft({
  shape: () => t,
  unknownKeys: "strip",
  catchall: en.create(),
  typeName: ke.ZodObject,
  ...Ke(e)
});
ft.strictCreate = (t, e) => new ft({
  shape: () => t,
  unknownKeys: "strict",
  catchall: en.create(),
  typeName: ke.ZodObject,
  ...Ke(e)
});
ft.lazycreate = (t, e) => new ft({
  shape: t,
  unknownKeys: "strip",
  catchall: en.create(),
  typeName: ke.ZodObject,
  ...Ke(e)
});
class da extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), i = this._def.options;
    function a(c) {
      for (const m of c)
        if (m.result.status === "valid")
          return m.result;
      for (const m of c)
        if (m.result.status === "dirty")
          return r.common.issues.push(...m.ctx.common.issues), m.result;
      const h = c.map((m) => new fe.ZodError(m.ctx.common.issues));
      return (0, $.addIssueToContext)(r, {
        code: fe.ZodIssueCode.invalid_union,
        unionErrors: h
      }), $.INVALID;
    }
    if (r.common.async)
      return Promise.all(i.map(async (c) => {
        const h = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await c._parseAsync({
            data: r.data,
            path: r.path,
            parent: h
          }),
          ctx: h
        };
      })).then(a);
    {
      let c;
      const h = [];
      for (const p of i) {
        const y = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, d = p._parseSync({
          data: r.data,
          path: r.path,
          parent: y
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !c && (c = { result: d, ctx: y }), y.common.issues.length && h.push(y.common.issues);
      }
      if (c)
        return r.common.issues.push(...c.ctx.common.issues), c.result;
      const m = h.map((p) => new fe.ZodError(p));
      return (0, $.addIssueToContext)(r, {
        code: fe.ZodIssueCode.invalid_union,
        unionErrors: m
      }), $.INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
j.ZodUnion = da;
da.create = (t, e) => new da({
  options: t,
  typeName: ke.ZodUnion,
  ...Ke(e)
});
const ki = (t) => t instanceof ha ? ki(t.schema) : t instanceof qr ? ki(t.innerType()) : t instanceof ma ? [t.value] : t instanceof pn ? t.options : t instanceof ya ? ye.util.objectValues(t.enum) : t instanceof ba ? ki(t._def.innerType) : t instanceof ua ? [void 0] : t instanceof ca ? [null] : t instanceof fi ? [void 0, ...ki(t.unwrap())] : t instanceof hn ? [null, ...ki(t.unwrap())] : t instanceof Oc || t instanceof xa ? ki(t.unwrap()) : t instanceof ga ? ki(t._def.innerType) : [];
class Pu extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== ye.ZodParsedType.object)
      return (0, $.addIssueToContext)(r, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.object,
        received: r.parsedType
      }), $.INVALID;
    const i = this.discriminator, a = r.data[i], c = this.optionsMap.get(a);
    return c ? r.common.async ? c._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : c._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : ((0, $.addIssueToContext)(r, {
      code: fe.ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [i]
    }), $.INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, i) {
    const a = /* @__PURE__ */ new Map();
    for (const c of r) {
      const h = ki(c.shape[e]);
      if (!h.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const m of h) {
        if (a.has(m))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(m)}`);
        a.set(m, c);
      }
    }
    return new Pu({
      typeName: ke.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: a,
      ...Ke(i)
    });
  }
}
j.ZodDiscriminatedUnion = Pu;
function wc(t, e) {
  const r = (0, ye.getParsedType)(t), i = (0, ye.getParsedType)(e);
  if (t === e)
    return { valid: !0, data: t };
  if (r === ye.ZodParsedType.object && i === ye.ZodParsedType.object) {
    const a = ye.util.objectKeys(e), c = ye.util.objectKeys(t).filter((m) => a.indexOf(m) !== -1), h = { ...t, ...e };
    for (const m of c) {
      const p = wc(t[m], e[m]);
      if (!p.valid)
        return { valid: !1 };
      h[m] = p.data;
    }
    return { valid: !0, data: h };
  } else if (r === ye.ZodParsedType.array && i === ye.ZodParsedType.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const a = [];
    for (let c = 0; c < t.length; c++) {
      const h = t[c], m = e[c], p = wc(h, m);
      if (!p.valid)
        return { valid: !1 };
      a.push(p.data);
    }
    return { valid: !0, data: a };
  } else return r === ye.ZodParsedType.date && i === ye.ZodParsedType.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class fa extends Ve {
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e), a = (c, h) => {
      if ((0, $.isAborted)(c) || (0, $.isAborted)(h))
        return $.INVALID;
      const m = wc(c.value, h.value);
      return m.valid ? (((0, $.isDirty)(c) || (0, $.isDirty)(h)) && r.dirty(), { status: r.value, value: m.data }) : ((0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_intersection_types
      }), $.INVALID);
    };
    return i.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: i.data,
        path: i.path,
        parent: i
      }),
      this._def.right._parseAsync({
        data: i.data,
        path: i.path,
        parent: i
      })
    ]).then(([c, h]) => a(c, h)) : a(this._def.left._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }), this._def.right._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }));
  }
}
j.ZodIntersection = fa;
fa.create = (t, e, r) => new fa({
  left: t,
  right: e,
  typeName: ke.ZodIntersection,
  ...Ke(r)
});
class hi extends Ve {
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== ye.ZodParsedType.array)
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.array,
        received: i.parsedType
      }), $.INVALID;
    if (i.data.length < this._def.items.length)
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), $.INVALID;
    !this._def.rest && i.data.length > this._def.items.length && ((0, $.addIssueToContext)(i, {
      code: fe.ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const c = [...i.data].map((h, m) => {
      const p = this._def.items[m] || this._def.rest;
      return p ? p._parse(new pi(i, h, i.path, m)) : null;
    }).filter((h) => !!h);
    return i.common.async ? Promise.all(c).then((h) => $.ParseStatus.mergeArray(r, h)) : $.ParseStatus.mergeArray(r, c);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new hi({
      ...this._def,
      rest: e
    });
  }
}
j.ZodTuple = hi;
hi.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new hi({
    items: t,
    typeName: ke.ZodTuple,
    rest: null,
    ...Ke(e)
  });
};
class pa extends Ve {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== ye.ZodParsedType.object)
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.object,
        received: i.parsedType
      }), $.INVALID;
    const a = [], c = this._def.keyType, h = this._def.valueType;
    for (const m in i.data)
      a.push({
        key: c._parse(new pi(i, m, i.path, m)),
        value: h._parse(new pi(i, i.data[m], i.path, m)),
        alwaysSet: m in i.data
      });
    return i.common.async ? $.ParseStatus.mergeObjectAsync(r, a) : $.ParseStatus.mergeObjectSync(r, a);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, i) {
    return r instanceof Ve ? new pa({
      keyType: e,
      valueType: r,
      typeName: ke.ZodRecord,
      ...Ke(i)
    }) : new pa({
      keyType: Mr.create(),
      valueType: e,
      typeName: ke.ZodRecord,
      ...Ke(r)
    });
  }
}
j.ZodRecord = pa;
class mu extends Ve {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== ye.ZodParsedType.map)
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.map,
        received: i.parsedType
      }), $.INVALID;
    const a = this._def.keyType, c = this._def.valueType, h = [...i.data.entries()].map(([m, p], y) => ({
      key: a._parse(new pi(i, m, i.path, [y, "key"])),
      value: c._parse(new pi(i, p, i.path, [y, "value"]))
    }));
    if (i.common.async) {
      const m = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const p of h) {
          const y = await p.key, d = await p.value;
          if (y.status === "aborted" || d.status === "aborted")
            return $.INVALID;
          (y.status === "dirty" || d.status === "dirty") && r.dirty(), m.set(y.value, d.value);
        }
        return { status: r.value, value: m };
      });
    } else {
      const m = /* @__PURE__ */ new Map();
      for (const p of h) {
        const y = p.key, d = p.value;
        if (y.status === "aborted" || d.status === "aborted")
          return $.INVALID;
        (y.status === "dirty" || d.status === "dirty") && r.dirty(), m.set(y.value, d.value);
      }
      return { status: r.value, value: m };
    }
  }
}
j.ZodMap = mu;
mu.create = (t, e, r) => new mu({
  valueType: e,
  keyType: t,
  typeName: ke.ZodMap,
  ...Ke(r)
});
class Mn extends Ve {
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== ye.ZodParsedType.set)
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.set,
        received: i.parsedType
      }), $.INVALID;
    const a = this._def;
    a.minSize !== null && i.data.size < a.minSize.value && ((0, $.addIssueToContext)(i, {
      code: fe.ZodIssueCode.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), r.dirty()), a.maxSize !== null && i.data.size > a.maxSize.value && ((0, $.addIssueToContext)(i, {
      code: fe.ZodIssueCode.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), r.dirty());
    const c = this._def.valueType;
    function h(p) {
      const y = /* @__PURE__ */ new Set();
      for (const d of p) {
        if (d.status === "aborted")
          return $.INVALID;
        d.status === "dirty" && r.dirty(), y.add(d.value);
      }
      return { status: r.value, value: y };
    }
    const m = [...i.data.values()].map((p, y) => c._parse(new pi(i, p, i.path, y)));
    return i.common.async ? Promise.all(m).then((p) => h(p)) : h(m);
  }
  min(e, r) {
    return new Mn({
      ...this._def,
      minSize: { value: e, message: ve.errorUtil.toString(r) }
    });
  }
  max(e, r) {
    return new Mn({
      ...this._def,
      maxSize: { value: e, message: ve.errorUtil.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
j.ZodSet = Mn;
Mn.create = (t, e) => new Mn({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: ke.ZodSet,
  ...Ke(e)
});
class xs extends Ve {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== ye.ZodParsedType.function)
      return (0, $.addIssueToContext)(r, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.function,
        received: r.parsedType
      }), $.INVALID;
    function i(m, p) {
      return (0, $.makeIssue)({
        data: m,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          (0, Jl.getErrorMap)(),
          Jl.defaultErrorMap
        ].filter((y) => !!y),
        issueData: {
          code: fe.ZodIssueCode.invalid_arguments,
          argumentsError: p
        }
      });
    }
    function a(m, p) {
      return (0, $.makeIssue)({
        data: m,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          (0, Jl.getErrorMap)(),
          Jl.defaultErrorMap
        ].filter((y) => !!y),
        issueData: {
          code: fe.ZodIssueCode.invalid_return_type,
          returnTypeError: p
        }
      });
    }
    const c = { errorMap: r.common.contextualErrorMap }, h = r.data;
    if (this._def.returns instanceof Rs) {
      const m = this;
      return (0, $.OK)(async function(...p) {
        const y = new fe.ZodError([]), d = await m._def.args.parseAsync(p, c).catch((K) => {
          throw y.addIssue(i(p, K)), y;
        }), A = await Reflect.apply(h, this, d);
        return await m._def.returns._def.type.parseAsync(A, c).catch((K) => {
          throw y.addIssue(a(A, K)), y;
        });
      });
    } else {
      const m = this;
      return (0, $.OK)(function(...p) {
        const y = m._def.args.safeParse(p, c);
        if (!y.success)
          throw new fe.ZodError([i(p, y.error)]);
        const d = Reflect.apply(h, this, y.data), A = m._def.returns.safeParse(d, c);
        if (!A.success)
          throw new fe.ZodError([a(d, A.error)]);
        return A.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new xs({
      ...this._def,
      args: hi.create(e).rest(On.create())
    });
  }
  returns(e) {
    return new xs({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, i) {
    return new xs({
      args: e || hi.create([]).rest(On.create()),
      returns: r || On.create(),
      typeName: ke.ZodFunction,
      ...Ke(i)
    });
  }
}
j.ZodFunction = xs;
class ha extends Ve {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
j.ZodLazy = ha;
ha.create = (t, e) => new ha({
  getter: t,
  typeName: ke.ZodLazy,
  ...Ke(e)
});
class ma extends Ve {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(r, {
        received: r.data,
        code: fe.ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), $.INVALID;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
j.ZodLiteral = ma;
ma.create = (t, e) => new ma({
  value: t,
  typeName: ke.ZodLiteral,
  ...Ke(e)
});
function up(t, e) {
  return new pn({
    values: t,
    typeName: ke.ZodEnum,
    ...Ke(e)
  });
}
class pn extends Ve {
  constructor() {
    super(...arguments), ia.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), i = this._def.values;
      return (0, $.addIssueToContext)(r, {
        expected: ye.util.joinValues(i),
        received: r.parsedType,
        code: fe.ZodIssueCode.invalid_type
      }), $.INVALID;
    }
    if (fu(this, ia, "f") || sp(this, ia, new Set(this._def.values), "f"), !fu(this, ia, "f").has(e.data)) {
      const r = this._getOrReturnCtx(e), i = this._def.values;
      return (0, $.addIssueToContext)(r, {
        received: r.data,
        code: fe.ZodIssueCode.invalid_enum_value,
        options: i
      }), $.INVALID;
    }
    return (0, $.OK)(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return pn.create(e, {
      ...this._def,
      ...r
    });
  }
  exclude(e, r = this._def) {
    return pn.create(this.options.filter((i) => !e.includes(i)), {
      ...this._def,
      ...r
    });
  }
}
j.ZodEnum = pn;
ia = /* @__PURE__ */ new WeakMap();
pn.create = up;
class ya extends Ve {
  constructor() {
    super(...arguments), na.set(this, void 0);
  }
  _parse(e) {
    const r = ye.util.getValidEnumValues(this._def.values), i = this._getOrReturnCtx(e);
    if (i.parsedType !== ye.ZodParsedType.string && i.parsedType !== ye.ZodParsedType.number) {
      const a = ye.util.objectValues(r);
      return (0, $.addIssueToContext)(i, {
        expected: ye.util.joinValues(a),
        received: i.parsedType,
        code: fe.ZodIssueCode.invalid_type
      }), $.INVALID;
    }
    if (fu(this, na, "f") || sp(this, na, new Set(ye.util.getValidEnumValues(this._def.values)), "f"), !fu(this, na, "f").has(e.data)) {
      const a = ye.util.objectValues(r);
      return (0, $.addIssueToContext)(i, {
        received: i.data,
        code: fe.ZodIssueCode.invalid_enum_value,
        options: a
      }), $.INVALID;
    }
    return (0, $.OK)(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
j.ZodNativeEnum = ya;
na = /* @__PURE__ */ new WeakMap();
ya.create = (t, e) => new ya({
  values: t,
  typeName: ke.ZodNativeEnum,
  ...Ke(e)
});
class Rs extends Ve {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== ye.ZodParsedType.promise && r.common.async === !1)
      return (0, $.addIssueToContext)(r, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.promise,
        received: r.parsedType
      }), $.INVALID;
    const i = r.parsedType === ye.ZodParsedType.promise ? r.data : Promise.resolve(r.data);
    return (0, $.OK)(i.then((a) => this._def.type.parseAsync(a, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
j.ZodPromise = Rs;
Rs.create = (t, e) => new Rs({
  type: t,
  typeName: ke.ZodPromise,
  ...Ke(e)
});
class qr extends Ve {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ke.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e), a = this._def.effect || null, c = {
      addIssue: (h) => {
        (0, $.addIssueToContext)(i, h), h.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return i.path;
      }
    };
    if (c.addIssue = c.addIssue.bind(c), a.type === "preprocess") {
      const h = a.transform(i.data, c);
      if (i.common.async)
        return Promise.resolve(h).then(async (m) => {
          if (r.value === "aborted")
            return $.INVALID;
          const p = await this._def.schema._parseAsync({
            data: m,
            path: i.path,
            parent: i
          });
          return p.status === "aborted" ? $.INVALID : p.status === "dirty" || r.value === "dirty" ? (0, $.DIRTY)(p.value) : p;
        });
      {
        if (r.value === "aborted")
          return $.INVALID;
        const m = this._def.schema._parseSync({
          data: h,
          path: i.path,
          parent: i
        });
        return m.status === "aborted" ? $.INVALID : m.status === "dirty" || r.value === "dirty" ? (0, $.DIRTY)(m.value) : m;
      }
    }
    if (a.type === "refinement") {
      const h = (m) => {
        const p = a.refinement(m, c);
        if (i.common.async)
          return Promise.resolve(p);
        if (p instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return m;
      };
      if (i.common.async === !1) {
        const m = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return m.status === "aborted" ? $.INVALID : (m.status === "dirty" && r.dirty(), h(m.value), { status: r.value, value: m.value });
      } else
        return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((m) => m.status === "aborted" ? $.INVALID : (m.status === "dirty" && r.dirty(), h(m.value).then(() => ({ status: r.value, value: m.value }))));
    }
    if (a.type === "transform")
      if (i.common.async === !1) {
        const h = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        if (!(0, $.isValid)(h))
          return h;
        const m = a.transform(h.value, c);
        if (m instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: m };
      } else
        return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((h) => (0, $.isValid)(h) ? Promise.resolve(a.transform(h.value, c)).then((m) => ({ status: r.value, value: m })) : h);
    ye.util.assertNever(a);
  }
}
j.ZodEffects = qr;
j.ZodTransformer = qr;
qr.create = (t, e, r) => new qr({
  schema: t,
  typeName: ke.ZodEffects,
  effect: e,
  ...Ke(r)
});
qr.createWithPreprocess = (t, e, r) => new qr({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: ke.ZodEffects,
  ...Ke(r)
});
class fi extends Ve {
  _parse(e) {
    return this._getType(e) === ye.ZodParsedType.undefined ? (0, $.OK)(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
j.ZodOptional = fi;
fi.create = (t, e) => new fi({
  innerType: t,
  typeName: ke.ZodOptional,
  ...Ke(e)
});
class hn extends Ve {
  _parse(e) {
    return this._getType(e) === ye.ZodParsedType.null ? (0, $.OK)(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
j.ZodNullable = hn;
hn.create = (t, e) => new hn({
  innerType: t,
  typeName: ke.ZodNullable,
  ...Ke(e)
});
class ba extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let i = r.data;
    return r.parsedType === ye.ZodParsedType.undefined && (i = this._def.defaultValue()), this._def.innerType._parse({
      data: i,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
j.ZodDefault = ba;
ba.create = (t, e) => new ba({
  innerType: t,
  typeName: ke.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...Ke(e)
});
class ga extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), i = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: i.data,
      path: i.path,
      parent: {
        ...i
      }
    });
    return (0, $.isAsync)(a) ? a.then((c) => ({
      status: "valid",
      value: c.status === "valid" ? c.value : this._def.catchValue({
        get error() {
          return new fe.ZodError(i.common.issues);
        },
        input: i.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new fe.ZodError(i.common.issues);
        },
        input: i.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
j.ZodCatch = ga;
ga.create = (t, e) => new ga({
  innerType: t,
  typeName: ke.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...Ke(e)
});
class yu extends Ve {
  _parse(e) {
    if (this._getType(e) !== ye.ZodParsedType.nan) {
      const i = this._getOrReturnCtx(e);
      return (0, $.addIssueToContext)(i, {
        code: fe.ZodIssueCode.invalid_type,
        expected: ye.ZodParsedType.nan,
        received: i.parsedType
      }), $.INVALID;
    }
    return { status: "valid", value: e.data };
  }
}
j.ZodNaN = yu;
yu.create = (t) => new yu({
  typeName: ke.ZodNaN,
  ...Ke(t)
});
j.BRAND = Symbol("zod_brand");
class Oc extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), i = r.data;
    return this._def.type._parse({
      data: i,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
j.ZodBranded = Oc;
class Ta extends Ve {
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.common.async)
      return (async () => {
        const c = await this._def.in._parseAsync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return c.status === "aborted" ? $.INVALID : c.status === "dirty" ? (r.dirty(), (0, $.DIRTY)(c.value)) : this._def.out._parseAsync({
          data: c.value,
          path: i.path,
          parent: i
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: i.data,
        path: i.path,
        parent: i
      });
      return a.status === "aborted" ? $.INVALID : a.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: i.path,
        parent: i
      });
    }
  }
  static create(e, r) {
    return new Ta({
      in: e,
      out: r,
      typeName: ke.ZodPipeline
    });
  }
}
j.ZodPipeline = Ta;
class xa extends Ve {
  _parse(e) {
    const r = this._def.innerType._parse(e), i = (a) => ((0, $.isValid)(a) && (a.value = Object.freeze(a.value)), a);
    return (0, $.isAsync)(r) ? r.then((a) => i(a)) : i(r);
  }
  unwrap() {
    return this._def.innerType;
  }
}
j.ZodReadonly = xa;
xa.create = (t, e) => new xa({
  innerType: t,
  typeName: ke.ZodReadonly,
  ...Ke(e)
});
function cp(t, e = {}, r) {
  return t ? vs.create().superRefine((i, a) => {
    var c, h;
    if (!t(i)) {
      const m = typeof e == "function" ? e(i) : typeof e == "string" ? { message: e } : e, p = (h = (c = m.fatal) !== null && c !== void 0 ? c : r) !== null && h !== void 0 ? h : !0, y = typeof m == "string" ? { message: m } : m;
      a.addIssue({ code: "custom", ...y, fatal: p });
    }
  }) : vs.create();
}
j.custom = cp;
j.late = {
  object: ft.lazycreate
};
var ke;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(ke || (j.ZodFirstPartyTypeKind = ke = {}));
const og = (t, e = {
  message: `Input not instance of ${t.name}`
}) => cp((r) => r instanceof t, e);
j.instanceof = og;
const dp = Mr.create;
j.string = dp;
const fp = dn.create;
j.number = fp;
const lg = yu.create;
j.nan = lg;
const ug = fn.create;
j.bigint = ug;
const pp = la.create;
j.boolean = pp;
const cg = Kn.create;
j.date = cg;
const dg = pu.create;
j.symbol = dg;
const fg = ua.create;
j.undefined = fg;
const pg = ca.create;
j.null = pg;
const hg = vs.create;
j.any = hg;
const mg = On.create;
j.unknown = mg;
const yg = en.create;
j.never = yg;
const bg = hu.create;
j.void = bg;
const gg = Gr.create;
j.array = gg;
const xg = ft.create;
j.object = xg;
const Eg = ft.strictCreate;
j.strictObject = Eg;
const vg = da.create;
j.union = vg;
const Rg = Pu.create;
j.discriminatedUnion = Rg;
const Ag = fa.create;
j.intersection = Ag;
const _g = hi.create;
j.tuple = _g;
const wg = pa.create;
j.record = wg;
const Tg = mu.create;
j.map = Tg;
const Cg = Mn.create;
j.set = Cg;
const Sg = xs.create;
j.function = Sg;
const Lg = ha.create;
j.lazy = Lg;
const kg = ma.create;
j.literal = kg;
const Dg = pn.create;
j.enum = Dg;
const Pg = ya.create;
j.nativeEnum = Pg;
const Bg = Rs.create;
j.promise = Bg;
const hp = qr.create;
j.effect = hp;
j.transformer = hp;
const Ig = fi.create;
j.optional = Ig;
const Ug = hn.create;
j.nullable = Ug;
const Og = qr.createWithPreprocess;
j.preprocess = Og;
const Kg = Ta.create;
j.pipeline = Kg;
const Mg = () => dp().optional();
j.ostring = Mg;
const Ng = () => fp().optional();
j.onumber = Ng;
const Vg = () => pp().optional();
j.oboolean = Vg;
j.coerce = {
  string: (t) => Mr.create({ ...t, coerce: !0 }),
  number: (t) => dn.create({ ...t, coerce: !0 }),
  boolean: (t) => la.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => fn.create({ ...t, coerce: !0 }),
  date: (t) => Kn.create({ ...t, coerce: !0 })
};
j.NEVER = $.INVALID;
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(i, a, c, h) {
    h === void 0 && (h = c);
    var m = Object.getOwnPropertyDescriptor(a, c);
    (!m || ("get" in m ? !a.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(i, h, m);
  } : function(i, a, c, h) {
    h === void 0 && (h = c), i[h] = a[c];
  }), r = ne && ne.__exportStar || function(i, a) {
    for (var c in i) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && e(a, i, c);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(ci, t), r(Uc, t), r(np, t), r(wa, t), r(j, t), r(di, t);
})(_c);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(h, m, p, y) {
    y === void 0 && (y = p);
    var d = Object.getOwnPropertyDescriptor(m, p);
    (!d || ("get" in d ? !m.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return m[p];
    } }), Object.defineProperty(h, y, d);
  } : function(h, m, p, y) {
    y === void 0 && (y = p), h[y] = m[p];
  }), r = ne && ne.__setModuleDefault || (Object.create ? function(h, m) {
    Object.defineProperty(h, "default", { enumerable: !0, value: m });
  } : function(h, m) {
    h.default = m;
  }), i = ne && ne.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var m = {};
    if (h != null) for (var p in h) p !== "default" && Object.prototype.hasOwnProperty.call(h, p) && e(m, h, p);
    return r(m, h), m;
  }, a = ne && ne.__exportStar || function(h, m) {
    for (var p in h) p !== "default" && !Object.prototype.hasOwnProperty.call(m, p) && e(m, h, p);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.z = void 0;
  const c = i(_c);
  t.z = c, a(_c, t), t.default = c;
})(os);
var ls = {};
Object.defineProperty(ls, "__esModule", { value: !0 });
ls.toLexUri = jg;
ls.toConcreteTypes = Fg;
ls.requiredPropertiesRefinement = $g;
const cc = os;
function jg(t, e) {
  if (t.split("#").length > 2)
    throw new Error("Uri can only have one hash segment");
  if (t.startsWith("lex:"))
    return t;
  if (t.startsWith("#")) {
    if (!e)
      throw new Error(`Unable to resolve uri without anchor: ${t}`);
    return `${e}${t}`;
  }
  return `lex:${t}`;
}
function Fg(t, e) {
  return e.type === "ref" ? [t.getDefOrThrow(e.ref)] : e.type === "union" ? e.refs.map((r) => t.getDefOrThrow(r)).flat() : [e];
}
function $g(t, e) {
  if (t.required !== void 0) {
    if (!Array.isArray(t.required)) {
      e.addIssue({
        code: cc.z.ZodIssueCode.invalid_type,
        received: typeof t.required,
        expected: "array"
      });
      return;
    }
    if (t.properties === void 0) {
      t.required.length > 0 && e.addIssue({
        code: cc.z.ZodIssueCode.custom,
        message: "Required fields defined but no properties defined"
      });
      return;
    }
    for (const r of t.required)
      t.properties[r] === void 0 && e.addIssue({
        code: cc.z.ZodIssueCode.custom,
        message: `Required field "${r}" not defined`
      });
  }
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.LexiconDefNotFoundError = t.InvalidLexiconError = t.ValidationError = t.discriminatedObject = t.lexiconDoc = t.lexUserType = t.lexRecord = t.lexXrpcSubscription = t.lexXrpcProcedure = t.lexXrpcQuery = t.lexXrpcError = t.lexXrpcSubscriptionMessage = t.lexXrpcBody = t.lexXrpcParameters = t.lexObject = t.lexToken = t.lexPrimitiveArray = t.lexArray = t.lexBlob = t.lexRefVariant = t.lexRefUnion = t.lexRef = t.lexIpldType = t.lexCidLink = t.lexBytes = t.lexPrimitive = t.lexUnknown = t.lexString = t.lexStringFormat = t.lexInteger = t.lexBoolean = void 0, t.isValidLexiconDoc = a, t.isObj = c, t.hasProp = h, t.isDiscriminatedObject = m, t.parseLexiconDoc = p;
  const e = os, r = as, i = ls;
  t.lexBoolean = e.z.object({
    type: e.z.literal("boolean"),
    description: e.z.string().optional(),
    default: e.z.boolean().optional(),
    const: e.z.boolean().optional()
  }).strict(), t.lexInteger = e.z.object({
    type: e.z.literal("integer"),
    description: e.z.string().optional(),
    default: e.z.number().int().optional(),
    minimum: e.z.number().int().optional(),
    maximum: e.z.number().int().optional(),
    enum: e.z.number().int().array().optional(),
    const: e.z.number().int().optional()
  }).strict(), t.lexStringFormat = e.z.enum([
    "datetime",
    "uri",
    "at-uri",
    "did",
    "handle",
    "at-identifier",
    "nsid",
    "cid",
    "language",
    "tid",
    "record-key"
  ]), t.lexString = e.z.object({
    type: e.z.literal("string"),
    format: t.lexStringFormat.optional(),
    description: e.z.string().optional(),
    default: e.z.string().optional(),
    minLength: e.z.number().int().optional(),
    maxLength: e.z.number().int().optional(),
    minGraphemes: e.z.number().int().optional(),
    maxGraphemes: e.z.number().int().optional(),
    enum: e.z.string().array().optional(),
    const: e.z.string().optional(),
    knownValues: e.z.string().array().optional()
  }).strict(), t.lexUnknown = e.z.object({
    type: e.z.literal("unknown"),
    description: e.z.string().optional()
  }).strict(), t.lexPrimitive = e.z.discriminatedUnion("type", [
    t.lexBoolean,
    t.lexInteger,
    t.lexString,
    t.lexUnknown
  ]), t.lexBytes = e.z.object({
    type: e.z.literal("bytes"),
    description: e.z.string().optional(),
    maxLength: e.z.number().optional(),
    minLength: e.z.number().optional()
  }).strict(), t.lexCidLink = e.z.object({
    type: e.z.literal("cid-link"),
    description: e.z.string().optional()
  }).strict(), t.lexIpldType = e.z.discriminatedUnion("type", [t.lexBytes, t.lexCidLink]), t.lexRef = e.z.object({
    type: e.z.literal("ref"),
    description: e.z.string().optional(),
    ref: e.z.string()
  }).strict(), t.lexRefUnion = e.z.object({
    type: e.z.literal("union"),
    description: e.z.string().optional(),
    refs: e.z.string().array(),
    closed: e.z.boolean().optional()
  }).strict(), t.lexRefVariant = e.z.discriminatedUnion("type", [t.lexRef, t.lexRefUnion]), t.lexBlob = e.z.object({
    type: e.z.literal("blob"),
    description: e.z.string().optional(),
    accept: e.z.string().array().optional(),
    maxSize: e.z.number().optional()
  }).strict(), t.lexArray = e.z.object({
    type: e.z.literal("array"),
    description: e.z.string().optional(),
    items: e.z.discriminatedUnion("type", [
      // lexPrimitive
      t.lexBoolean,
      t.lexInteger,
      t.lexString,
      t.lexUnknown,
      // lexIpldType
      t.lexBytes,
      t.lexCidLink,
      // lexRefVariant
      t.lexRef,
      t.lexRefUnion,
      // other
      t.lexBlob
    ]),
    minLength: e.z.number().int().optional(),
    maxLength: e.z.number().int().optional()
  }).strict(), t.lexPrimitiveArray = t.lexArray.merge(e.z.object({
    items: t.lexPrimitive
  }).strict()), t.lexToken = e.z.object({
    type: e.z.literal("token"),
    description: e.z.string().optional()
  }).strict(), t.lexObject = e.z.object({
    type: e.z.literal("object"),
    description: e.z.string().optional(),
    required: e.z.string().array().optional(),
    nullable: e.z.string().array().optional(),
    properties: e.z.record(e.z.discriminatedUnion("type", [
      t.lexArray,
      // lexPrimitive
      t.lexBoolean,
      t.lexInteger,
      t.lexString,
      t.lexUnknown,
      // lexIpldType
      t.lexBytes,
      t.lexCidLink,
      // lexRefVariant
      t.lexRef,
      t.lexRefUnion,
      // other
      t.lexBlob
    ]))
  }).strict().superRefine(i.requiredPropertiesRefinement), t.lexXrpcParameters = e.z.object({
    type: e.z.literal("params"),
    description: e.z.string().optional(),
    required: e.z.string().array().optional(),
    properties: e.z.record(e.z.discriminatedUnion("type", [
      t.lexPrimitiveArray,
      // lexPrimitive
      t.lexBoolean,
      t.lexInteger,
      t.lexString,
      t.lexUnknown
    ]))
  }).strict().superRefine(i.requiredPropertiesRefinement), t.lexXrpcBody = e.z.object({
    description: e.z.string().optional(),
    encoding: e.z.string(),
    // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
    schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
  }).strict(), t.lexXrpcSubscriptionMessage = e.z.object({
    description: e.z.string().optional(),
    // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
    schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
  }).strict(), t.lexXrpcError = e.z.object({
    name: e.z.string(),
    description: e.z.string().optional()
  }).strict(), t.lexXrpcQuery = e.z.object({
    type: e.z.literal("query"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    output: t.lexXrpcBody.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexXrpcProcedure = e.z.object({
    type: e.z.literal("procedure"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    input: t.lexXrpcBody.optional(),
    output: t.lexXrpcBody.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexXrpcSubscription = e.z.object({
    type: e.z.literal("subscription"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    message: t.lexXrpcSubscriptionMessage.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexRecord = e.z.object({
    type: e.z.literal("record"),
    description: e.z.string().optional(),
    key: e.z.string().optional(),
    record: t.lexObject
  }).strict(), t.lexUserType = e.z.custom((B) => {
    if (!(!B || typeof B != "object") && B.type !== void 0)
      switch (B.type) {
        case "record":
          return t.lexRecord.parse(B);
        case "query":
          return t.lexXrpcQuery.parse(B);
        case "procedure":
          return t.lexXrpcProcedure.parse(B);
        case "subscription":
          return t.lexXrpcSubscription.parse(B);
        case "blob":
          return t.lexBlob.parse(B);
        case "array":
          return t.lexArray.parse(B);
        case "token":
          return t.lexToken.parse(B);
        case "object":
          return t.lexObject.parse(B);
        case "boolean":
          return t.lexBoolean.parse(B);
        case "integer":
          return t.lexInteger.parse(B);
        case "string":
          return t.lexString.parse(B);
        case "bytes":
          return t.lexBytes.parse(B);
        case "cid-link":
          return t.lexCidLink.parse(B);
        case "unknown":
          return t.lexUnknown.parse(B);
      }
  }, (B) => !B || typeof B != "object" ? {
    message: "Must be an object",
    fatal: !0
  } : B.type === void 0 ? {
    message: "Must have a type",
    fatal: !0
  } : typeof B.type != "string" ? {
    message: "Type property must be a string",
    fatal: !0
  } : {
    message: `Invalid type: ${B.type} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
    fatal: !0
  }), t.lexiconDoc = e.z.object({
    lexicon: e.z.literal(1),
    id: e.z.string().refine((B) => r.NSID.isValid(B), {
      message: "Must be a valid NSID"
    }),
    revision: e.z.number().optional(),
    description: e.z.string().optional(),
    defs: e.z.record(t.lexUserType)
  }).strict().superRefine((B, K) => {
    for (const O in B.defs) {
      const z = B.defs[O];
      O !== "main" && (z.type === "record" || z.type === "procedure" || z.type === "query" || z.type === "subscription") && K.addIssue({
        code: e.z.ZodIssueCode.custom,
        message: "Records, procedures, queries, and subscriptions must be the main definition."
      });
    }
  });
  function a(B) {
    return t.lexiconDoc.safeParse(B).success;
  }
  function c(B) {
    return B !== null && typeof B == "object";
  }
  function h(B, K) {
    return K in B;
  }
  t.discriminatedObject = e.z.object({ $type: e.z.string() });
  function m(B) {
    return t.discriminatedObject.safeParse(B).success;
  }
  function p(B) {
    return t.lexiconDoc.parse(B), B;
  }
  class y extends Error {
  }
  t.ValidationError = y;
  class d extends Error {
  }
  t.InvalidLexiconError = d;
  class A extends Error {
  }
  t.LexiconDefNotFoundError = A;
})(Rn);
var Bu = {}, us = {}, An = {}, Kc = {}, Iu = {}, vi = {}, ri = {};
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.isObject = ri.assure = ri.create = ri.is = void 0;
const Gg = (t, e) => e.safeParse(t).success;
ri.is = Gg;
const qg = (t) => (e) => t.safeParse(e).success;
ri.create = qg;
const zg = (t, e) => t.parse(e);
ri.assure = zg;
const Xg = (t) => typeof t == "object" && t !== null;
ri.isObject = Xg;
var As = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseIntWithFallback = t.dedupeStrs = t.range = t.chunkArray = t.errHasMsg = t.isErrnoException = t.asyncFilter = t.s32decode = t.s32encode = t.streamToBuffer = t.flattenUint8Arrays = t.bailableWait = t.wait = t.jitter = t.noUndefinedVals = void 0, t.omit = r;
  const e = (V) => (Object.keys(V).forEach((G) => {
    V[G] === void 0 && delete V[G];
  }), V);
  t.noUndefinedVals = e;
  function r(V, G) {
    if (!V)
      return V;
    const Z = {}, ae = Object.keys(V);
    for (let se = 0; se < ae.length; se++) {
      const be = ae[se];
      G.includes(be) || (Z[be] = V[be]);
    }
    return Z;
  }
  const i = (V) => Math.round((Math.random() - 0.5) * V * 2);
  t.jitter = i;
  const a = (V) => new Promise((G) => setTimeout(G, V));
  t.wait = a;
  const c = (V) => {
    let G;
    const Z = new Promise((ae) => {
      const se = setTimeout(ae, V);
      G = () => {
        clearTimeout(se), ae();
      };
    });
    return { bail: G, wait: () => Z };
  };
  t.bailableWait = c;
  const h = (V) => {
    const G = V.reduce((se, be) => se + be.length, 0), Z = new Uint8Array(G);
    let ae = 0;
    return V.forEach((se) => {
      Z.set(se, ae), ae += se.length;
    }), Z;
  };
  t.flattenUint8Arrays = h;
  const m = async (V) => {
    const G = [];
    for await (const Z of V)
      G.push(Z);
    return (0, t.flattenUint8Arrays)(G);
  };
  t.streamToBuffer = m;
  const p = "234567abcdefghijklmnopqrstuvwxyz", y = (V) => {
    let G = "";
    for (; V; ) {
      const Z = V % 32;
      V = Math.floor(V / 32), G = p.charAt(Z) + G;
    }
    return G;
  };
  t.s32encode = y;
  const d = (V) => {
    let G = 0;
    for (const Z of V)
      G = G * 32 + p.indexOf(Z);
    return G;
  };
  t.s32decode = d;
  const A = async (V, G) => {
    const Z = await Promise.all(V.map((ae) => G(ae)));
    return V.filter((ae, se) => Z[se]);
  };
  t.asyncFilter = A;
  const B = (V) => !!V && V.code;
  t.isErrnoException = B;
  const K = (V, G) => !!V && typeof V == "object" && V.message === G;
  t.errHasMsg = K;
  const O = (V, G) => V.reduce((Z, ae, se) => {
    const be = Math.floor(se / G);
    return Z[be] || (Z[be] = []), Z[be].push(ae), Z;
  }, []);
  t.chunkArray = O;
  const z = (V) => {
    const G = [];
    for (let Z = 0; Z < V; Z++)
      G.push(Z);
    return G;
  };
  t.range = z;
  const X = (V) => [...new Set(V)];
  t.dedupeStrs = X;
  const H = (V, G) => {
    const Z = parseInt(V || "", 10);
    return isNaN(Z) ? G : Z;
  };
  t.parseIntWithFallback = H;
})(As);
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.mapDefined = _s.keyBy = void 0;
const Hg = (t, e) => t.reduce((r, i) => (r[i[e]] = i, r), {});
_s.keyBy = Hg;
const Zg = (t, e) => {
  const r = [];
  for (const i of t) {
    const a = e(i);
    a !== void 0 && r.push(a);
  }
  return r;
};
_s.mapDefined = Zg;
var mp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AsyncBufferFullError = t.AsyncBuffer = t.allComplete = t.createDeferrables = t.createDeferrable = t.readFromGenerator = void 0, t.allFulfilled = p, t.handleAllSettledErrors = y, t.isRejectedResult = d, t.isFulfilledResult = B;
  const e = As, r = async (z, X, H = Promise.resolve(), V = Number.MAX_SAFE_INTEGER) => {
    const G = [];
    let Z, ae = !1;
    const se = async () => {
      if (await X(G.at(-1)))
        return !0;
      const me = (0, e.bailableWait)(20);
      return await me.wait(), Z = me.bail, ae ? !1 : await se();
    }, be = new Promise((me) => {
      H.then(() => {
        se().then(() => me());
      });
    });
    try {
      for (; G.length < V; ) {
        const me = await Promise.race([z.next(), be]);
        if (!me)
          break;
        const Ae = me;
        if (Ae.done)
          break;
        G.push(Ae.value);
      }
    } finally {
      ae = !0, Z && Z();
    }
    return G;
  };
  t.readFromGenerator = r;
  const i = () => {
    let z;
    const X = new Promise((H) => {
      z = () => H();
    });
    return { resolve: z, complete: X };
  };
  t.createDeferrable = i;
  const a = (z) => {
    const X = [];
    for (let H = 0; H < z; H++)
      X.push((0, t.createDeferrable)());
    return X;
  };
  t.createDeferrables = a;
  const c = async (z) => {
    await Promise.all(z.map((X) => X.complete));
  };
  t.allComplete = c;
  class h {
    constructor(X) {
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: X
      }), Object.defineProperty(this, "buffer", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), Object.defineProperty(this, "promise", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "resolve", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "closed", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "toThrow", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.promise = Promise.resolve(), this.resolve = () => null, this.resetPromise();
    }
    get curr() {
      return this.buffer;
    }
    get size() {
      return this.buffer.length;
    }
    get isClosed() {
      return this.closed;
    }
    resetPromise() {
      this.promise = new Promise((X) => this.resolve = X);
    }
    push(X) {
      this.buffer.push(X), this.resolve();
    }
    pushMany(X) {
      X.forEach((H) => this.buffer.push(H)), this.resolve();
    }
    async *events() {
      for (; ; ) {
        if (this.closed && this.buffer.length === 0) {
          if (this.toThrow)
            throw this.toThrow;
          return;
        }
        if (await this.promise, this.toThrow)
          throw this.toThrow;
        if (this.maxSize && this.size > this.maxSize)
          throw new m(this.maxSize);
        const [X, ...H] = this.buffer;
        X ? (this.buffer = H, yield X) : this.resetPromise();
      }
    }
    throw(X) {
      this.toThrow = X, this.closed = !0, this.resolve();
    }
    close() {
      this.closed = !0, this.resolve();
    }
  }
  t.AsyncBuffer = h;
  class m extends Error {
    constructor(X) {
      super(`ReachedMaxBufferSize: ${X}`);
    }
  }
  t.AsyncBufferFullError = m;
  function p(z) {
    return Promise.allSettled(z).then(y);
  }
  function y(z) {
    const X = z.filter(d).map(A);
    if (X.length === 0)
      return z.map(K);
    throw X.length === 1 ? X[0] : new AggregateError(X, `Multiple errors: ${X.map(O).join(`
`)}`);
  }
  function d(z) {
    return z.status === "rejected";
  }
  function A(z) {
    return z.reason;
  }
  function B(z) {
    return z.status === "fulfilled";
  }
  function K(z) {
    return z.value;
  }
  function O(z) {
    return z instanceof Error ? z.message : String(z);
  }
})(mp);
var Ca = {};
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.TID = void 0;
const Ql = As, Sd = 13;
let dc = 0, Ld = 0, eu = null;
function kd(t) {
  return t.replaceAll("-", "");
}
class Ii {
  constructor(e) {
    Object.defineProperty(this, "str", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const r = kd(e);
    if (r.length !== Sd)
      throw new Error(`Poorly formatted TID: ${r.length} length`);
    this.str = r;
  }
  static next(e) {
    const r = Math.max(Date.now(), dc);
    r === dc && Ld++, dc = r;
    const i = r * 1e3 + Ld;
    eu === null && (eu = Math.floor(Math.random() * 32));
    const a = Ii.fromTime(i, eu);
    return !e || a.newerThan(e) ? a : Ii.fromTime(e.timestamp() + 1, eu);
  }
  static nextStr(e) {
    return Ii.next(e ? new Ii(e) : void 0).toString();
  }
  static fromTime(e, r) {
    const i = `${(0, Ql.s32encode)(e)}${(0, Ql.s32encode)(r).padStart(2, "2")}`;
    return new Ii(i);
  }
  static fromStr(e) {
    return new Ii(e);
  }
  static oldestFirst(e, r) {
    return e.compareTo(r);
  }
  static newestFirst(e, r) {
    return r.compareTo(e);
  }
  static is(e) {
    return kd(e).length === Sd;
  }
  timestamp() {
    return (0, Ql.s32decode)(this.str.slice(0, 11));
  }
  clockid() {
    return (0, Ql.s32decode)(this.str.slice(11, 13));
  }
  formatted() {
    const e = this.toString();
    return `${e.slice(0, 4)}-${e.slice(4, 7)}-${e.slice(7, 11)}-${e.slice(11, 13)}`;
  }
  toString() {
    return this.str;
  }
  // newer > older
  compareTo(e) {
    return this.str > e.str ? 1 : this.str < e.str ? -1 : 0;
  }
  equals(e) {
    return this.str === e.str;
  }
  newerThan(e) {
    return this.compareTo(e) > 0;
  }
  olderThan(e) {
    return this.compareTo(e) < 0;
  }
}
Ca.TID = Ii;
Ca.default = Ii;
var yp = {}, Wg = bp, Dd = 128, Yg = -128, Jg = Math.pow(2, 31);
function bp(t, e, r) {
  e = e || [], r = r || 0;
  for (var i = r; t >= Jg; )
    e[r++] = t & 255 | Dd, t /= 128;
  for (; t & Yg; )
    e[r++] = t & 255 | Dd, t >>>= 7;
  return e[r] = t | 0, bp.bytes = r - i + 1, e;
}
var Qg = Tc, ex = 128, Pd = 127;
function Tc(t, i) {
  var r = 0, i = i || 0, a = 0, c = i, h, m = t.length;
  do {
    if (c >= m)
      throw Tc.bytes = 0, new RangeError("Could not decode varint");
    h = t[c++], r += a < 28 ? (h & Pd) << a : (h & Pd) * Math.pow(2, a), a += 7;
  } while (h >= ex);
  return Tc.bytes = c - i, r;
}
var tx = Math.pow(2, 7), rx = Math.pow(2, 14), ix = Math.pow(2, 21), nx = Math.pow(2, 28), sx = Math.pow(2, 35), ax = Math.pow(2, 42), ox = Math.pow(2, 49), lx = Math.pow(2, 56), ux = Math.pow(2, 63), cx = function(t) {
  return t < tx ? 1 : t < rx ? 2 : t < ix ? 3 : t < nx ? 4 : t < sx ? 5 : t < ax ? 6 : t < ox ? 7 : t < lx ? 8 : t < ux ? 9 : 10;
}, dx = {
  encode: Wg,
  decode: Qg,
  encodingLength: cx
}, bu = dx;
const Cc = (t, e = 0) => [
  bu.decode(t, e),
  bu.decode.bytes
], gu = (t, e, r = 0) => (bu.encode(t, e, r), e), xu = (t) => bu.encodingLength(t), fx = (t, e) => {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}, Mc = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, px = (t) => new TextEncoder().encode(t), hx = (t) => new TextDecoder().decode(t), mx = (t, e) => {
  const r = e.byteLength, i = xu(t), a = i + xu(r), c = new Uint8Array(a + r);
  return gu(t, c, 0), gu(r, c, i), c.set(e, a), new Nc(t, r, e, c);
}, yx = (t) => {
  const e = Mc(t), [r, i] = Cc(e), [a, c] = Cc(e.subarray(i)), h = e.subarray(i + c);
  if (h.byteLength !== a)
    throw new Error("Incorrect length");
  return new Nc(r, a, h, e);
}, bx = (t, e) => t === e ? !0 : t.code === e.code && t.size === e.size && fx(t.bytes, e.bytes);
class Nc {
  constructor(e, r, i, a) {
    this.code = e, this.size = r, this.digest = i, this.bytes = a;
  }
}
function gx(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), i = 0; i < r.length; i++)
    r[i] = 255;
  for (var a = 0; a < t.length; a++) {
    var c = t.charAt(a), h = c.charCodeAt(0);
    if (r[h] !== 255)
      throw new TypeError(c + " is ambiguous");
    r[h] = a;
  }
  var m = t.length, p = t.charAt(0), y = Math.log(m) / Math.log(256), d = Math.log(256) / Math.log(m);
  function A(O) {
    if (O instanceof Uint8Array || (ArrayBuffer.isView(O) ? O = new Uint8Array(O.buffer, O.byteOffset, O.byteLength) : Array.isArray(O) && (O = Uint8Array.from(O))), !(O instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (O.length === 0)
      return "";
    for (var z = 0, X = 0, H = 0, V = O.length; H !== V && O[H] === 0; )
      H++, z++;
    for (var G = (V - H) * d + 1 >>> 0, Z = new Uint8Array(G); H !== V; ) {
      for (var ae = O[H], se = 0, be = G - 1; (ae !== 0 || se < X) && be !== -1; be--, se++)
        ae += 256 * Z[be] >>> 0, Z[be] = ae % m >>> 0, ae = ae / m >>> 0;
      if (ae !== 0)
        throw new Error("Non-zero carry");
      X = se, H++;
    }
    for (var me = G - X; me !== G && Z[me] === 0; )
      me++;
    for (var Ae = p.repeat(z); me < G; ++me)
      Ae += t.charAt(Z[me]);
    return Ae;
  }
  function B(O) {
    if (typeof O != "string")
      throw new TypeError("Expected String");
    if (O.length === 0)
      return new Uint8Array();
    var z = 0;
    if (O[z] !== " ") {
      for (var X = 0, H = 0; O[z] === p; )
        X++, z++;
      for (var V = (O.length - z) * y + 1 >>> 0, G = new Uint8Array(V); O[z]; ) {
        var Z = r[O.charCodeAt(z)];
        if (Z === 255)
          return;
        for (var ae = 0, se = V - 1; (Z !== 0 || ae < H) && se !== -1; se--, ae++)
          Z += m * G[se] >>> 0, G[se] = Z % 256 >>> 0, Z = Z / 256 >>> 0;
        if (Z !== 0)
          throw new Error("Non-zero carry");
        H = ae, z++;
      }
      if (O[z] !== " ") {
        for (var be = V - H; be !== V && G[be] === 0; )
          be++;
        for (var me = new Uint8Array(X + (V - be)), Ae = X; be !== V; )
          me[Ae++] = G[be++];
        return me;
      }
    }
  }
  function K(O) {
    var z = B(O);
    if (z)
      return z;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: A,
    decodeUnsafe: B,
    decode: K
  };
}
var xx = gx, Ex = xx;
class vx {
  constructor(e, r, i) {
    this.name = e, this.prefix = r, this.baseEncode = i;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Rx {
  constructor(e, r, i) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = i;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return gp(this, e);
  }
}
class Ax {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return gp(this, e);
  }
  decode(e) {
    const r = e[0], i = this.decoders[r];
    if (i)
      return i.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const gp = (t, e) => new Ax({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class _x {
  constructor(e, r, i, a) {
    this.name = e, this.prefix = r, this.baseEncode = i, this.baseDecode = a, this.encoder = new vx(e, r, i), this.decoder = new Rx(e, r, a);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Uu = ({ name: t, prefix: e, encode: r, decode: i }) => new _x(t, e, r, i), Sa = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: i, decode: a } = Ex(r, e);
  return Uu({
    prefix: t,
    name: e,
    encode: i,
    decode: (c) => Mc(a(c))
  });
}, wx = (t, e, r, i) => {
  const a = {};
  for (let d = 0; d < e.length; ++d)
    a[e[d]] = d;
  let c = t.length;
  for (; t[c - 1] === "="; )
    --c;
  const h = new Uint8Array(c * r / 8 | 0);
  let m = 0, p = 0, y = 0;
  for (let d = 0; d < c; ++d) {
    const A = a[t[d]];
    if (A === void 0)
      throw new SyntaxError(`Non-${i} character`);
    p = p << r | A, m += r, m >= 8 && (m -= 8, h[y++] = 255 & p >> m);
  }
  if (m >= r || 255 & p << 8 - m)
    throw new SyntaxError("Unexpected end of data");
  return h;
}, Tx = (t, e, r) => {
  const i = e[e.length - 1] === "=", a = (1 << r) - 1;
  let c = "", h = 0, m = 0;
  for (let p = 0; p < t.length; ++p)
    for (m = m << 8 | t[p], h += 8; h > r; )
      h -= r, c += e[a & m >> h];
  if (h && (c += e[a & m << r - h]), i)
    for (; c.length * r & 7; )
      c += "=";
  return c;
}, Gt = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) => Uu({
  prefix: e,
  name: t,
  encode(a) {
    return Tx(a, i, r);
  },
  decode(a) {
    return wx(a, i, r, t);
  }
}), Ui = Sa({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), Cx = Sa({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), Sx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: Ui,
  base58flickr: Cx
}, Symbol.toStringTag, { value: "Module" })), sa = Gt({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), Lx = Gt({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), kx = Gt({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), Dx = Gt({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), Px = Gt({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), Bx = Gt({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), Ix = Gt({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), Ux = Gt({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), Ox = Gt({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), Kx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: sa,
  base32hex: Px,
  base32hexpad: Ix,
  base32hexpadupper: Ux,
  base32hexupper: Bx,
  base32pad: kx,
  base32padupper: Dx,
  base32upper: Lx,
  base32z: Ox
}, Symbol.toStringTag, { value: "Module" }));
class Zt {
  constructor(e, r, i, a) {
    this.code = r, this.version = e, this.multihash = i, this.bytes = a, this.byteOffset = a.byteOffset, this.byteLength = a.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, {
      byteOffset: ru,
      byteLength: ru,
      code: tu,
      version: tu,
      multihash: tu,
      bytes: tu,
      _baseCache: ru,
      asCID: ru
    });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: e, multihash: r } = this;
        if (e !== Js)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (r.code !== jx)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return Zt.createV0(r);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: r } = this.multihash, i = mx(e, r);
        return Zt.createV1(this.code, i);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  equals(e) {
    return e && this.code === e.code && this.version === e.version && bx(this.multihash, e.multihash);
  }
  toString(e) {
    const { bytes: r, version: i, _baseCache: a } = this;
    switch (i) {
      case 0:
        return Nx(r, a, e || Ui.encoder);
      default:
        return Vx(r, a, e || sa.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(e) {
    return $x(/^0\.0/, Gx), !!(e && (e[Id] || e.asCID === e));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(e) {
    if (e instanceof Zt)
      return e;
    if (e != null && e.asCID === e) {
      const { version: r, code: i, multihash: a, bytes: c } = e;
      return new Zt(r, i, a, c || Bd(r, i, a.bytes));
    } else if (e != null && e[Id] === !0) {
      const { version: r, multihash: i, code: a } = e, c = yx(i);
      return Zt.create(r, a, c);
    } else
      return null;
  }
  static create(e, r, i) {
    if (typeof r != "number")
      throw new Error("String codecs are no longer supported");
    switch (e) {
      case 0: {
        if (r !== Js)
          throw new Error(`Version 0 CID must use dag-pb (code: ${Js}) block encoding`);
        return new Zt(e, r, i, i.bytes);
      }
      case 1: {
        const a = Bd(e, r, i.bytes);
        return new Zt(e, r, i, a);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(e) {
    return Zt.create(0, Js, e);
  }
  static createV1(e, r) {
    return Zt.create(1, e, r);
  }
  static decode(e) {
    const [r, i] = Zt.decodeFirst(e);
    if (i.length)
      throw new Error("Incorrect length");
    return r;
  }
  static decodeFirst(e) {
    const r = Zt.inspectBytes(e), i = r.size - r.multihashSize, a = Mc(e.subarray(i, i + r.multihashSize));
    if (a.byteLength !== r.multihashSize)
      throw new Error("Incorrect length");
    const c = a.subarray(r.multihashSize - r.digestSize), h = new Nc(r.multihashCode, r.digestSize, c, a);
    return [
      r.version === 0 ? Zt.createV0(h) : Zt.createV1(r.codec, h),
      e.subarray(r.size)
    ];
  }
  static inspectBytes(e) {
    let r = 0;
    const i = () => {
      const [A, B] = Cc(e.subarray(r));
      return r += B, A;
    };
    let a = i(), c = Js;
    if (a === 18 ? (a = 0, r = 0) : a === 1 && (c = i()), a !== 0 && a !== 1)
      throw new RangeError(`Invalid CID version ${a}`);
    const h = r, m = i(), p = i(), y = r + p, d = y - h;
    return {
      version: a,
      codec: c,
      multihashCode: m,
      digestSize: p,
      multihashSize: d,
      size: y
    };
  }
  static parse(e, r) {
    const [i, a] = Mx(e, r), c = Zt.decode(a);
    return c._baseCache.set(i, e), c;
  }
}
const Mx = (t, e) => {
  switch (t[0]) {
    case "Q": {
      const r = e || Ui;
      return [
        Ui.prefix,
        r.decode(`${Ui.prefix}${t}`)
      ];
    }
    case Ui.prefix: {
      const r = e || Ui;
      return [
        Ui.prefix,
        r.decode(t)
      ];
    }
    case sa.prefix: {
      const r = e || sa;
      return [
        sa.prefix,
        r.decode(t)
      ];
    }
    default: {
      if (e == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [
        t[0],
        e.decode(t)
      ];
    }
  }
}, Nx = (t, e, r) => {
  const { prefix: i } = r;
  if (i !== Ui.prefix)
    throw Error(`Cannot string encode V0 in ${r.name} encoding`);
  const a = e.get(i);
  if (a == null) {
    const c = r.encode(t).slice(1);
    return e.set(i, c), c;
  } else
    return a;
}, Vx = (t, e, r) => {
  const { prefix: i } = r, a = e.get(i);
  if (a == null) {
    const c = r.encode(t);
    return e.set(i, c), c;
  } else
    return a;
}, Js = 112, jx = 18, Bd = (t, e, r) => {
  const i = xu(t), a = i + xu(e), c = new Uint8Array(a + r.byteLength);
  return gu(t, c, 0), gu(e, c, i), c.set(r, a), c;
}, Id = Symbol.for("@ipld/js-cid/CID"), tu = {
  writable: !1,
  configurable: !1,
  enumerable: !0
}, ru = {
  writable: !1,
  enumerable: !1,
  configurable: !1
}, Fx = "0.0.0-dev", $x = (t, e) => {
  if (t.test(Fx))
    console.warn(e);
  else
    throw new Error(e);
}, Gx = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`, qx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: Zt
}, Symbol.toStringTag, { value: "Module" })), Fs = /* @__PURE__ */ Xf(qx);
function zx(t, e) {
  for (let r = 0; r < t.byteLength; r++) {
    if (t[r] < e[r])
      return -1;
    if (t[r] > e[r])
      return 1;
  }
  return t.byteLength > e.byteLength ? 1 : t.byteLength < e.byteLength ? -1 : 0;
}
function Xx(t, e) {
  e || (e = t.reduce((a, c) => a + c.length, 0));
  const r = new Uint8Array(e);
  let i = 0;
  for (const a of t)
    r.set(a, i), i += a.length;
  return r;
}
function Hx(t, e) {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const Zx = Uu({
  prefix: "\0",
  name: "identity",
  encode: (t) => hx(t),
  decode: (t) => px(t)
}), Wx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: Zx
}, Symbol.toStringTag, { value: "Module" })), Yx = Gt({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), Jx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: Yx
}, Symbol.toStringTag, { value: "Module" })), Qx = Gt({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), eE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: Qx
}, Symbol.toStringTag, { value: "Module" })), tE = Sa({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), rE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: tE
}, Symbol.toStringTag, { value: "Module" })), iE = Gt({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), nE = Gt({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), sE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: iE,
  base16upper: nE
}, Symbol.toStringTag, { value: "Module" })), aE = Sa({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), oE = Sa({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), lE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: aE,
  base36upper: oE
}, Symbol.toStringTag, { value: "Module" })), uE = Gt({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), cE = Gt({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), dE = Gt({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), fE = Gt({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), pE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: uE,
  base64pad: cE,
  base64url: dE,
  base64urlpad: fE
}, Symbol.toStringTag, { value: "Module" })), xp = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), hE = xp.reduce((t, e, r) => (t[r] = e, t), []), mE = xp.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function yE(t) {
  return t.reduce((e, r) => (e += hE[r], e), "");
}
function bE(t) {
  const e = [];
  for (const r of t) {
    const i = mE[r.codePointAt(0)];
    if (i === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(i);
  }
  return new Uint8Array(e);
}
const gE = Uu({
  prefix: "🚀",
  name: "base256emoji",
  encode: yE,
  decode: bE
}), xE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: gE
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Ud = {
  ...Wx,
  ...Jx,
  ...eE,
  ...rE,
  ...sE,
  ...Kx,
  ...lE,
  ...Sx,
  ...pE,
  ...xE
};
function Ep(t, e, r, i) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: i }
  };
}
const Od = Ep("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), fc = Ep("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), vp = {
  utf8: Od,
  "utf-8": Od,
  hex: Ud.base16,
  latin1: fc,
  ascii: fc,
  binary: fc,
  ...Ud
};
function EE(t, e = "utf8") {
  const r = vp[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.decoder.decode(`${r.prefix}${t}`);
}
function vE(t, e = "utf8") {
  const r = vp[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.encoder.encode(t).substring(1);
}
function RE(t, e) {
  if (t.length !== e.length)
    throw new Error("Inputs should have the same length");
  const r = new Uint8Array(t.length);
  for (let i = 0; i < t.length; i++)
    r[i] = t[i] ^ e[i];
  return r;
}
const AE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: zx,
  concat: Xx,
  equals: Hx,
  fromString: EE,
  toString: vE,
  xor: RE
}, Symbol.toStringTag, { value: "Module" })), Rp = /* @__PURE__ */ Xf(AE);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(y, d, A, B) {
    B === void 0 && (B = A);
    var K = Object.getOwnPropertyDescriptor(d, A);
    (!K || ("get" in K ? !d.__esModule : K.writable || K.configurable)) && (K = { enumerable: !0, get: function() {
      return d[A];
    } }), Object.defineProperty(y, B, K);
  } : function(y, d, A, B) {
    B === void 0 && (B = A), y[B] = d[A];
  }), r = ne && ne.__setModuleDefault || (Object.create ? function(y, d) {
    Object.defineProperty(y, "default", { enumerable: !0, value: d });
  } : function(y, d) {
    y.default = d;
  }), i = ne && ne.__importStar || function(y) {
    if (y && y.__esModule) return y;
    var d = {};
    if (y != null) for (var A in y) A !== "default" && Object.prototype.hasOwnProperty.call(y, A) && e(d, y, A);
    return r(d, y), d;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ipldEquals = t.ipldToJson = t.jsonToIpld = void 0;
  const a = Fs, c = i(Rp), h = (y) => {
    if (Array.isArray(y))
      return y.map((d) => (0, t.jsonToIpld)(d));
    if (y && typeof y == "object") {
      if (typeof y.$link == "string" && Object.keys(y).length === 1)
        return a.CID.parse(y.$link);
      if (typeof y.$bytes == "string" && Object.keys(y).length === 1)
        return c.fromString(y.$bytes, "base64");
      const d = {};
      for (const A of Object.keys(y))
        d[A] = (0, t.jsonToIpld)(y[A]);
      return d;
    }
    return y;
  };
  t.jsonToIpld = h;
  const m = (y) => {
    if (Array.isArray(y))
      return y.map((d) => (0, t.ipldToJson)(d));
    if (y && typeof y == "object") {
      if (y instanceof Uint8Array)
        return {
          $bytes: c.toString(y, "base64")
        };
      if (a.CID.asCID(y))
        return {
          $link: y.toString()
        };
      const d = {};
      for (const A of Object.keys(y))
        d[A] = (0, t.ipldToJson)(y[A]);
      return d;
    }
    return y;
  };
  t.ipldToJson = m;
  const p = (y, d) => {
    if (Array.isArray(y) && Array.isArray(d)) {
      if (y.length !== d.length)
        return !1;
      for (let A = 0; A < y.length; A++)
        if (!(0, t.ipldEquals)(y[A], d[A]))
          return !1;
      return !0;
    }
    if (y && d && typeof y == "object" && typeof d == "object") {
      if (y instanceof Uint8Array && d instanceof Uint8Array)
        return c.equals(y, d);
      if (a.CID.asCID(y) && a.CID.asCID(d))
        return a.CID.asCID(y)?.equals(a.CID.asCID(d));
      if (Object.keys(y).length !== Object.keys(d).length)
        return !1;
      for (const A of Object.keys(y))
        if (!(0, t.ipldEquals)(y[A], d[A]))
          return !1;
      return !0;
    }
    return y === d;
  };
  t.ipldEquals = p;
})(yp);
var La = {};
Object.defineProperty(La, "__esModule", { value: !0 });
La.retry = Ap;
La.createRetryable = wE;
La.backoffMs = _p;
const _E = As;
async function Ap(t, e = {}) {
  const { maxRetries: r = 3, retryable: i = () => !0, getWaitMs: a = _p } = e;
  let c = 0, h;
  for (; !h; )
    try {
      return await t();
    } catch (m) {
      const p = a(c);
      c < r && p !== null && i(m) ? (c += 1, p !== 0 && await (0, _E.wait)(p)) : h = m;
    }
  throw h;
}
function wE(t) {
  return async (e, r) => Ap(e, { ...r, retryable: t });
}
function _p(t, e = 100, r = 1e3) {
  const i = Math.pow(2, t) * e, a = Math.min(i, r);
  return TE(a);
}
function TE(t) {
  const e = t * 0.15;
  return t + CE(-e, e);
}
function CE(t, e) {
  return Math.random() * (e - t) + t;
}
var wp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.def = t.schema = void 0;
  const e = Fs, r = os, i = r.z.any().refine((a) => e.CID.asCID(a) !== null, {
    message: "Not a CID"
  }).transform((a) => e.CID.asCID(a));
  t.schema = {
    cid: i,
    bytes: r.z.instanceof(Uint8Array),
    string: r.z.string(),
    array: r.z.array(r.z.unknown()),
    map: r.z.record(r.z.string(), r.z.unknown()),
    unknown: r.z.unknown()
  }, t.def = {
    cid: {
      name: "cid",
      schema: t.schema.cid
    },
    bytes: {
      name: "bytes",
      schema: t.schema.bytes
    },
    string: {
      name: "string",
      schema: t.schema.string
    },
    map: {
      name: "map",
      schema: t.schema.map
    },
    unknown: {
      name: "unknown",
      schema: t.schema.unknown
    }
  };
})(wp);
var Tp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.addHoursToDate = t.lessThanAgoMs = t.DAY = t.HOUR = t.MINUTE = t.SECOND = void 0, t.SECOND = 1e3, t.MINUTE = t.SECOND * 60, t.HOUR = t.MINUTE * 60, t.DAY = t.HOUR * 24;
  const e = (i, a) => Date.now() < i.getTime() + a;
  t.lessThanAgoMs = e;
  const r = (i, a) => {
    const c = a ? new Date(a) : /* @__PURE__ */ new Date();
    return c.setHours(c.getHours() + i), c;
  };
  t.addHoursToDate = r;
})(Tp);
var yr = {}, Vc = {}, jc = {}, Fc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.EXTENDED_PICTOGRAPHIC = t.CLUSTER_BREAK = void 0, function(e) {
    e[e.CR = 0] = "CR", e[e.LF = 1] = "LF", e[e.CONTROL = 2] = "CONTROL", e[e.EXTEND = 3] = "EXTEND", e[e.REGIONAL_INDICATOR = 4] = "REGIONAL_INDICATOR", e[e.SPACINGMARK = 5] = "SPACINGMARK", e[e.L = 6] = "L", e[e.V = 7] = "V", e[e.T = 8] = "T", e[e.LV = 9] = "LV", e[e.LVT = 10] = "LVT", e[e.OTHER = 11] = "OTHER", e[e.PREPEND = 12] = "PREPEND", e[e.E_BASE = 13] = "E_BASE", e[e.E_MODIFIER = 14] = "E_MODIFIER", e[e.ZWJ = 15] = "ZWJ", e[e.GLUE_AFTER_ZWJ = 16] = "GLUE_AFTER_ZWJ", e[e.E_BASE_GAZ = 17] = "E_BASE_GAZ";
  }(t.CLUSTER_BREAK || (t.CLUSTER_BREAK = {})), t.EXTENDED_PICTOGRAPHIC = 101;
})(Fc);
var $c = {};
Object.defineProperty($c, "__esModule", { value: !0 });
const $e = Fc, Li = 0, pc = 1, SE = 2, LE = 3, kE = 4;
class DE {
  /**
   * Check if the the character at the position {pos} of the string is surrogate
   * @param str {string}
   * @param pos {number}
   * @returns {boolean}
   */
  static isSurrogate(e, r) {
    return 55296 <= e.charCodeAt(r) && e.charCodeAt(r) <= 56319 && 56320 <= e.charCodeAt(r + 1) && e.charCodeAt(r + 1) <= 57343;
  }
  /**
   * The String.prototype.codePointAt polyfill
   * Private function, gets a Unicode code point from a JavaScript UTF-16 string
   * handling surrogate pairs appropriately
   * @param str {string}
   * @param idx {number}
   * @returns {number}
   */
  static codePointAt(e, r) {
    r === void 0 && (r = 0);
    const i = e.charCodeAt(r);
    if (55296 <= i && i <= 56319 && r < e.length - 1) {
      const a = i, c = e.charCodeAt(r + 1);
      return 56320 <= c && c <= 57343 ? (a - 55296) * 1024 + (c - 56320) + 65536 : a;
    }
    if (56320 <= i && i <= 57343 && r >= 1) {
      const a = e.charCodeAt(r - 1), c = i;
      return 55296 <= a && a <= 56319 ? (a - 55296) * 1024 + (c - 56320) + 65536 : c;
    }
    return i;
  }
  //
  /**
   * Private function, returns whether a break is allowed between the two given grapheme breaking classes
   * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
   * @param start {number}
   * @param mid {Array<number>}
   * @param end {number}
   * @param startEmoji {number}
   * @param midEmoji {Array<number>}
   * @param endEmoji {number}
   * @returns {number}
   */
  static shouldBreak(e, r, i, a, c, h) {
    const m = [e].concat(r).concat([i]), p = [a].concat(c).concat([h]), y = m[m.length - 2], d = i, A = h, B = m.lastIndexOf($e.CLUSTER_BREAK.REGIONAL_INDICATOR);
    if (B > 0 && m.slice(1, B).every(function(O) {
      return O === $e.CLUSTER_BREAK.REGIONAL_INDICATOR;
    }) && [$e.CLUSTER_BREAK.PREPEND, $e.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(y) === -1)
      return m.filter(function(O) {
        return O === $e.CLUSTER_BREAK.REGIONAL_INDICATOR;
      }).length % 2 === 1 ? LE : kE;
    if (y === $e.CLUSTER_BREAK.CR && d === $e.CLUSTER_BREAK.LF)
      return Li;
    if (y === $e.CLUSTER_BREAK.CONTROL || y === $e.CLUSTER_BREAK.CR || y === $e.CLUSTER_BREAK.LF)
      return pc;
    if (d === $e.CLUSTER_BREAK.CONTROL || d === $e.CLUSTER_BREAK.CR || d === $e.CLUSTER_BREAK.LF)
      return pc;
    if (y === $e.CLUSTER_BREAK.L && (d === $e.CLUSTER_BREAK.L || d === $e.CLUSTER_BREAK.V || d === $e.CLUSTER_BREAK.LV || d === $e.CLUSTER_BREAK.LVT))
      return Li;
    if ((y === $e.CLUSTER_BREAK.LV || y === $e.CLUSTER_BREAK.V) && (d === $e.CLUSTER_BREAK.V || d === $e.CLUSTER_BREAK.T))
      return Li;
    if ((y === $e.CLUSTER_BREAK.LVT || y === $e.CLUSTER_BREAK.T) && d === $e.CLUSTER_BREAK.T)
      return Li;
    if (d === $e.CLUSTER_BREAK.EXTEND || d === $e.CLUSTER_BREAK.ZWJ)
      return Li;
    if (d === $e.CLUSTER_BREAK.SPACINGMARK)
      return Li;
    if (y === $e.CLUSTER_BREAK.PREPEND)
      return Li;
    const K = p.slice(0, -1).lastIndexOf($e.EXTENDED_PICTOGRAPHIC);
    return K !== -1 && p[K] === $e.EXTENDED_PICTOGRAPHIC && m.slice(K + 1, -2).every(function(O) {
      return O === $e.CLUSTER_BREAK.EXTEND;
    }) && y === $e.CLUSTER_BREAK.ZWJ && A === $e.EXTENDED_PICTOGRAPHIC ? Li : r.indexOf($e.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1 ? SE : y === $e.CLUSTER_BREAK.REGIONAL_INDICATOR && d === $e.CLUSTER_BREAK.REGIONAL_INDICATOR ? Li : pc;
  }
}
$c.default = DE;
var Gc = {};
Object.defineProperty(Gc, "__esModule", { value: !0 });
class PE {
  constructor(e, r) {
    this._index = 0, this._str = e, this._nextBreak = r;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let e;
    if ((e = this._nextBreak(this._str, this._index)) < this._str.length) {
      const r = this._str.slice(this._index, e);
      return this._index = e, { value: r, done: !1 };
    }
    if (this._index < this._str.length) {
      const r = this._str.slice(this._index);
      return this._index = this._str.length, { value: r, done: !1 };
    }
    return { value: void 0, done: !0 };
  }
}
Gc.default = PE;
var Cp = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(jc, "__esModule", { value: !0 });
const n = Fc, iu = Cp($c), BE = Cp(Gc);
class Pi {
  /**
   * Returns the next grapheme break in the string after the given index
   * @param string {string}
   * @param index {number}
   * @returns {number}
   */
  static nextBreak(e, r) {
    if (r === void 0 && (r = 0), r < 0)
      return 0;
    if (r >= e.length - 1)
      return e.length;
    const i = iu.default.codePointAt(e, r), a = Pi.getGraphemeBreakProperty(i), c = Pi.getEmojiProperty(i), h = [], m = [];
    for (let p = r + 1; p < e.length; p++) {
      if (iu.default.isSurrogate(e, p - 1))
        continue;
      const y = iu.default.codePointAt(e, p), d = Pi.getGraphemeBreakProperty(y), A = Pi.getEmojiProperty(y);
      if (iu.default.shouldBreak(a, h, d, c, m, A))
        return p;
      h.push(d), m.push(A);
    }
    return e.length;
  }
  /**
   * Breaks the given string into an array of grapheme clusters
   * @param str {string}
   * @returns {string[]}
   */
  splitGraphemes(e) {
    const r = [];
    let i = 0, a;
    for (; (a = Pi.nextBreak(e, i)) < e.length; )
      r.push(e.slice(i, a)), i = a;
    return i < e.length && r.push(e.slice(i)), r;
  }
  /**
   * Returns an iterator of grapheme clusters in the given string
   * @param str {string}
   * @returns {GraphemerIterator}
   */
  iterateGraphemes(e) {
    return new BE.default(e, Pi.nextBreak);
  }
  /**
   * Returns the number of grapheme clusters in the given string
   * @param str {string}
   * @returns {number}
   */
  countGraphemes(e) {
    let r = 0, i = 0, a;
    for (; (a = Pi.nextBreak(e, i)) < e.length; )
      i = a, r++;
    return i < e.length && r++, r;
  }
  /**
   * Given a Unicode code point, determines this symbol's grapheme break property
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getGraphemeBreakProperty(e) {
    if (e < 48905) {
      if (e < 44116) {
        if (e < 4141) {
          if (e < 2818) {
            if (e < 2363)
              if (e < 1759) {
                if (e < 1471) {
                  if (e < 127) {
                    if (e < 11) {
                      if (e < 10) {
                        if (0 <= e && e <= 9)
                          return n.CLUSTER_BREAK.CONTROL;
                      } else if (e === 10)
                        return n.CLUSTER_BREAK.LF;
                    } else if (e < 13) {
                      if (11 <= e && e <= 12)
                        return n.CLUSTER_BREAK.CONTROL;
                    } else if (e < 14) {
                      if (e === 13)
                        return n.CLUSTER_BREAK.CR;
                    } else if (14 <= e && e <= 31)
                      return n.CLUSTER_BREAK.CONTROL;
                  } else if (e < 768) {
                    if (e < 173) {
                      if (127 <= e && e <= 159)
                        return n.CLUSTER_BREAK.CONTROL;
                    } else if (e === 173)
                      return n.CLUSTER_BREAK.CONTROL;
                  } else if (e < 1155) {
                    if (768 <= e && e <= 879)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1425) {
                    if (1155 <= e && e <= 1161)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (1425 <= e && e <= 1469)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 1552) {
                  if (e < 1476) {
                    if (e < 1473) {
                      if (e === 1471)
                        return n.CLUSTER_BREAK.EXTEND;
                    } else if (1473 <= e && e <= 1474)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1479) {
                    if (1476 <= e && e <= 1477)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1536) {
                    if (e === 1479)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (1536 <= e && e <= 1541)
                    return n.CLUSTER_BREAK.PREPEND;
                } else if (e < 1648) {
                  if (e < 1564) {
                    if (1552 <= e && e <= 1562)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1611) {
                    if (e === 1564)
                      return n.CLUSTER_BREAK.CONTROL;
                  } else if (1611 <= e && e <= 1631)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 1750) {
                  if (e === 1648)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 1757) {
                  if (1750 <= e && e <= 1756)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 1757)
                  return n.CLUSTER_BREAK.PREPEND;
              } else if (e < 2075) {
                if (e < 1840)
                  if (e < 1770) {
                    if (e < 1767) {
                      if (1759 <= e && e <= 1764)
                        return n.CLUSTER_BREAK.EXTEND;
                    } else if (1767 <= e && e <= 1768)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1807) {
                    if (1770 <= e && e <= 1773)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else {
                    if (e === 1807)
                      return n.CLUSTER_BREAK.PREPEND;
                    if (e === 1809)
                      return n.CLUSTER_BREAK.EXTEND;
                  }
                else if (e < 2027) {
                  if (e < 1958) {
                    if (1840 <= e && e <= 1866)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (1958 <= e && e <= 1968)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2045) {
                  if (2027 <= e && e <= 2035)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2070) {
                  if (e === 2045)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (2070 <= e && e <= 2073)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2200) {
                if (e < 2089) {
                  if (e < 2085) {
                    if (2075 <= e && e <= 2083)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (2085 <= e && e <= 2087)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2137) {
                  if (2089 <= e && e <= 2093)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2192) {
                  if (2137 <= e && e <= 2139)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (2192 <= e && e <= 2193)
                  return n.CLUSTER_BREAK.PREPEND;
              } else if (e < 2275) {
                if (e < 2250) {
                  if (2200 <= e && e <= 2207)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2274) {
                  if (2250 <= e && e <= 2273)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 2274)
                  return n.CLUSTER_BREAK.PREPEND;
              } else if (e < 2307) {
                if (2275 <= e && e <= 2306)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 2307)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2362)
                  return n.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 2561) {
              if (e < 2434) {
                if (e < 2381) {
                  if (e < 2366) {
                    if (e === 2363)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                    if (e === 2364)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2369) {
                    if (2366 <= e && e <= 2368)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2377) {
                    if (2369 <= e && e <= 2376)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (2377 <= e && e <= 2380)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2385) {
                  if (e < 2382) {
                    if (e === 2381)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (2382 <= e && e <= 2383)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2402) {
                  if (2385 <= e && e <= 2391)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2433) {
                  if (2402 <= e && e <= 2403)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 2433)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2503) {
                if (e < 2494) {
                  if (e < 2492) {
                    if (2434 <= e && e <= 2435)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 2492)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2495) {
                  if (e === 2494)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2497) {
                  if (2495 <= e && e <= 2496)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (2497 <= e && e <= 2500)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2519) {
                if (e < 2507) {
                  if (2503 <= e && e <= 2504)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2509) {
                  if (2507 <= e && e <= 2508)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 2509)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2530) {
                if (e === 2519)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2558) {
                if (2530 <= e && e <= 2531)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 2558)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2691) {
              if (e < 2631) {
                if (e < 2620) {
                  if (e < 2563) {
                    if (2561 <= e && e <= 2562)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2563)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2622) {
                  if (e === 2620)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2625) {
                  if (2622 <= e && e <= 2624)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (2625 <= e && e <= 2626)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2672) {
                if (e < 2635) {
                  if (2631 <= e && e <= 2632)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2641) {
                  if (2635 <= e && e <= 2637)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 2641)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2677) {
                if (2672 <= e && e <= 2673)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2689) {
                if (e === 2677)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (2689 <= e && e <= 2690)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2761) {
              if (e < 2750) {
                if (e === 2691)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2748)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2753) {
                if (2750 <= e && e <= 2752)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2759) {
                if (2753 <= e && e <= 2757)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (2759 <= e && e <= 2760)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2786) {
              if (e < 2763) {
                if (e === 2761)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2765) {
                if (2763 <= e && e <= 2764)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 2765)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2810) {
              if (2786 <= e && e <= 2787)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2817) {
              if (2810 <= e && e <= 2815)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 2817)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3315) {
            if (e < 3076) {
              if (e < 2946) {
                if (e < 2887) {
                  if (e < 2878) {
                    if (e < 2876) {
                      if (2818 <= e && e <= 2819)
                        return n.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 2876)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2880) {
                    if (2878 <= e && e <= 2879)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2881) {
                    if (e === 2880)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2881 <= e && e <= 2884)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2893) {
                  if (e < 2891) {
                    if (2887 <= e && e <= 2888)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2891 <= e && e <= 2892)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2901) {
                  if (e === 2893)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2914) {
                  if (2901 <= e && e <= 2903)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (2914 <= e && e <= 2915)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3014) {
                if (e < 3007) {
                  if (e === 2946 || e === 3006)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3008) {
                  if (e === 3007)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3009) {
                  if (e === 3008)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (3009 <= e && e <= 3010)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3031) {
                if (e < 3018) {
                  if (3014 <= e && e <= 3016)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3021) {
                  if (3018 <= e && e <= 3020)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3021)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3072) {
                if (e === 3031)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3073) {
                if (e === 3072)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (3073 <= e && e <= 3075)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3262) {
              if (e < 3146) {
                if (e < 3134) {
                  if (e === 3076 || e === 3132)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3137) {
                  if (3134 <= e && e <= 3136)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3142) {
                  if (3137 <= e && e <= 3140)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (3142 <= e && e <= 3144)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3201) {
                if (e < 3157) {
                  if (3146 <= e && e <= 3149)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3170) {
                  if (3157 <= e && e <= 3158)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (3170 <= e && e <= 3171)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3202) {
                if (e === 3201)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3260) {
                if (3202 <= e && e <= 3203)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3260)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3270) {
              if (e < 3264) {
                if (e === 3262)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 3263)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3266) {
                if (3264 <= e && e <= 3265)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3267) {
                if (e === 3266)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (3267 <= e && e <= 3268)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3276) {
              if (e < 3271) {
                if (e === 3270)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3274) {
                if (3271 <= e && e <= 3272)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (3274 <= e && e <= 3275)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3285) {
              if (3276 <= e && e <= 3277)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3298) {
              if (3285 <= e && e <= 3286)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (3298 <= e && e <= 3299)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3551) {
            if (e < 3406) {
              if (e < 3391) {
                if (e < 3330) {
                  if (e < 3328) {
                    if (e === 3315)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3328 <= e && e <= 3329)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3387) {
                  if (3330 <= e && e <= 3331)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3390) {
                  if (3387 <= e && e <= 3388)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 3390)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3398) {
                if (e < 3393) {
                  if (3391 <= e && e <= 3392)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (3393 <= e && e <= 3396)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3402) {
                if (3398 <= e && e <= 3400)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3405) {
                if (3402 <= e && e <= 3404)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3405)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3530) {
              if (e < 3426) {
                if (e === 3406)
                  return n.CLUSTER_BREAK.PREPEND;
                if (e === 3415)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3457) {
                if (3426 <= e && e <= 3427)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3458) {
                if (e === 3457)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (3458 <= e && e <= 3459)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3538) {
              if (e < 3535) {
                if (e === 3530)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3536) {
                if (e === 3535)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (3536 <= e && e <= 3537)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3542) {
              if (3538 <= e && e <= 3540)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3544) {
              if (e === 3542)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (3544 <= e && e <= 3550)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 3893) {
            if (e < 3655) {
              if (e < 3633) {
                if (e < 3570) {
                  if (e === 3551)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (3570 <= e && e <= 3571)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3635) {
                if (e === 3633)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3636) {
                if (e === 3635)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (3636 <= e && e <= 3642)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3764)
              if (e < 3761) {
                if (3655 <= e && e <= 3662)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 3761)
                  return n.CLUSTER_BREAK.EXTEND;
                if (e === 3763)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 3784) {
              if (3764 <= e && e <= 3772)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3864) {
              if (3784 <= e && e <= 3790)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (3864 <= e && e <= 3865)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3967) {
            if (e < 3897) {
              if (e === 3893 || e === 3895)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3902) {
              if (e === 3897)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3953) {
              if (3902 <= e && e <= 3903)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (3953 <= e && e <= 3966)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3981) {
            if (e < 3968) {
              if (e === 3967)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3974) {
              if (3968 <= e && e <= 3972)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (3974 <= e && e <= 3975)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3993) {
            if (3981 <= e && e <= 3991)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 4038) {
            if (3993 <= e && e <= 4028)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 4038)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 7204) {
          if (e < 6448) {
            if (e < 5938) {
              if (e < 4226) {
                if (e < 4157) {
                  if (e < 4146) {
                    if (e < 4145) {
                      if (4141 <= e && e <= 4144)
                        return n.CLUSTER_BREAK.EXTEND;
                    } else if (e === 4145)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4153) {
                    if (4146 <= e && e <= 4151)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 4155) {
                    if (4153 <= e && e <= 4154)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (4155 <= e && e <= 4156)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4184) {
                  if (e < 4182) {
                    if (4157 <= e && e <= 4158)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (4182 <= e && e <= 4183)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4190) {
                  if (4184 <= e && e <= 4185)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 4209) {
                  if (4190 <= e && e <= 4192)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (4209 <= e && e <= 4212)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 4352) {
                if (e < 4229) {
                  if (e === 4226)
                    return n.CLUSTER_BREAK.EXTEND;
                  if (e === 4228)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4237) {
                  if (4229 <= e && e <= 4230)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 4237 || e === 4253)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 4957) {
                if (e < 4448) {
                  if (4352 <= e && e <= 4447)
                    return n.CLUSTER_BREAK.L;
                } else if (e < 4520) {
                  if (4448 <= e && e <= 4519)
                    return n.CLUSTER_BREAK.V;
                } else if (4520 <= e && e <= 4607)
                  return n.CLUSTER_BREAK.T;
              } else if (e < 5906) {
                if (4957 <= e && e <= 4959)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 5909) {
                if (5906 <= e && e <= 5908)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 5909)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6089) {
              if (e < 6070) {
                if (e < 5970) {
                  if (e < 5940) {
                    if (5938 <= e && e <= 5939)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e === 5940)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6002) {
                  if (5970 <= e && e <= 5971)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 6068) {
                  if (6002 <= e && e <= 6003)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (6068 <= e && e <= 6069)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6078) {
                if (e < 6071) {
                  if (e === 6070)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (6071 <= e && e <= 6077)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6086) {
                if (6078 <= e && e <= 6085)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6087) {
                if (e === 6086)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6087 <= e && e <= 6088)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6277)
              if (e < 6155) {
                if (e < 6109) {
                  if (6089 <= e && e <= 6099)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 6109)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6158) {
                if (6155 <= e && e <= 6157)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 6158)
                  return n.CLUSTER_BREAK.CONTROL;
                if (e === 6159)
                  return n.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 6435) {
              if (e < 6313) {
                if (6277 <= e && e <= 6278)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6432) {
                if (e === 6313)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6432 <= e && e <= 6434)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 6439) {
              if (6435 <= e && e <= 6438)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6441) {
              if (6439 <= e && e <= 6440)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (6441 <= e && e <= 6443)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 6971) {
            if (e < 6744)
              if (e < 6681) {
                if (e < 6451) {
                  if (e < 6450) {
                    if (6448 <= e && e <= 6449)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 6450)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 6457) {
                  if (6451 <= e && e <= 6456)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6679) {
                  if (6457 <= e && e <= 6459)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (6679 <= e && e <= 6680)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6741) {
                if (e < 6683) {
                  if (6681 <= e && e <= 6682)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 6683)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6742) {
                if (e === 6741)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else {
                if (e === 6742)
                  return n.CLUSTER_BREAK.EXTEND;
                if (e === 6743)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 6771) {
              if (e < 6754) {
                if (e < 6752) {
                  if (6744 <= e && e <= 6750)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 6752)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6757) {
                if (e === 6754)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6765) {
                if (6757 <= e && e <= 6764)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6765 <= e && e <= 6770)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6912) {
              if (e < 6783) {
                if (6771 <= e && e <= 6780)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6832) {
                if (e === 6783)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6832 <= e && e <= 6862)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 6916) {
              if (6912 <= e && e <= 6915)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 6964) {
              if (e === 6916)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (6964 <= e && e <= 6970)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 7080) {
            if (e < 7019) {
              if (e < 6973) {
                if (e === 6971)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 6972)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6978) {
                if (6973 <= e && e <= 6977)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6979) {
                if (e === 6978)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6979 <= e && e <= 6980)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7073) {
              if (e < 7040) {
                if (7019 <= e && e <= 7027)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 7042) {
                if (7040 <= e && e <= 7041)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 7042)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7074) {
              if (e === 7073)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7078) {
              if (7074 <= e && e <= 7077)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (7078 <= e && e <= 7079)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7144)
            if (e < 7083) {
              if (e < 7082) {
                if (7080 <= e && e <= 7081)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 7082)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7142) {
              if (7083 <= e && e <= 7085)
                return n.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 7142)
                return n.CLUSTER_BREAK.EXTEND;
              if (e === 7143)
                return n.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 7150) {
            if (e < 7146) {
              if (7144 <= e && e <= 7145)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 7149) {
              if (7146 <= e && e <= 7148)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 7149)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 7151) {
            if (e === 7150)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7154) {
            if (7151 <= e && e <= 7153)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (7154 <= e && e <= 7155)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 43346) {
          if (e < 11647) {
            if (e < 7415) {
              if (e < 7380) {
                if (e < 7220) {
                  if (e < 7212) {
                    if (7204 <= e && e <= 7211)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (7212 <= e && e <= 7219)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 7222) {
                  if (7220 <= e && e <= 7221)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 7376) {
                  if (7222 <= e && e <= 7223)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (7376 <= e && e <= 7378)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 7394) {
                if (e < 7393) {
                  if (7380 <= e && e <= 7392)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 7393)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7405) {
                if (7394 <= e && e <= 7400)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 7405 || e === 7412)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 8205)
              if (e < 7616) {
                if (e < 7416) {
                  if (e === 7415)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (7416 <= e && e <= 7417)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 8203) {
                if (7616 <= e && e <= 7679)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 8203)
                  return n.CLUSTER_BREAK.CONTROL;
                if (e === 8204)
                  return n.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 8288) {
              if (e < 8206) {
                if (e === 8205)
                  return n.CLUSTER_BREAK.ZWJ;
              } else if (e < 8232) {
                if (8206 <= e && e <= 8207)
                  return n.CLUSTER_BREAK.CONTROL;
              } else if (8232 <= e && e <= 8238)
                return n.CLUSTER_BREAK.CONTROL;
            } else if (e < 8400) {
              if (8288 <= e && e <= 8303)
                return n.CLUSTER_BREAK.CONTROL;
            } else if (e < 11503) {
              if (8400 <= e && e <= 8432)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (11503 <= e && e <= 11505)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43043) {
            if (e < 42612) {
              if (e < 12330) {
                if (e < 11744) {
                  if (e === 11647)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (11744 <= e && e <= 11775)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 12441) {
                if (12330 <= e && e <= 12335)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 42607) {
                if (12441 <= e && e <= 12442)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (42607 <= e && e <= 42610)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43010) {
              if (e < 42654) {
                if (42612 <= e && e <= 42621)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 42736) {
                if (42654 <= e && e <= 42655)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (42736 <= e && e <= 42737)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43014) {
              if (e === 43010)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 43014 || e === 43019)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43188) {
            if (e < 43047) {
              if (e < 43045) {
                if (43043 <= e && e <= 43044)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (43045 <= e && e <= 43046)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43052) {
              if (e === 43047)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43136) {
              if (e === 43052)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (43136 <= e && e <= 43137)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43263) {
            if (e < 43204) {
              if (43188 <= e && e <= 43203)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43232) {
              if (43204 <= e && e <= 43205)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (43232 <= e && e <= 43249)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43302) {
            if (e === 43263)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43335) {
            if (43302 <= e && e <= 43309)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (43335 <= e && e <= 43345)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 43698) {
          if (e < 43493) {
            if (e < 43444)
              if (e < 43392) {
                if (e < 43360) {
                  if (43346 <= e && e <= 43347)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (43360 <= e && e <= 43388)
                  return n.CLUSTER_BREAK.L;
              } else if (e < 43395) {
                if (43392 <= e && e <= 43394)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 43395)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 43443)
                  return n.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 43450) {
              if (e < 43446) {
                if (43444 <= e && e <= 43445)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (43446 <= e && e <= 43449)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43452) {
              if (43450 <= e && e <= 43451)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43454) {
              if (43452 <= e && e <= 43453)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (43454 <= e && e <= 43456)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43573) {
            if (e < 43567) {
              if (e < 43561) {
                if (e === 43493)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (43561 <= e && e <= 43566)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43569) {
              if (43567 <= e && e <= 43568)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43571) {
              if (43569 <= e && e <= 43570)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (43571 <= e && e <= 43572)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43597) {
            if (e < 43587) {
              if (43573 <= e && e <= 43574)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 43587 || e === 43596)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43644) {
            if (e === 43597)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 43644 || e === 43696)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 44006) {
          if (e < 43756)
            if (e < 43710) {
              if (e < 43703) {
                if (43698 <= e && e <= 43700)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (43703 <= e && e <= 43704)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43713) {
              if (43710 <= e && e <= 43711)
                return n.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 43713)
                return n.CLUSTER_BREAK.EXTEND;
              if (e === 43755)
                return n.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 43766) {
            if (e < 43758) {
              if (43756 <= e && e <= 43757)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43765) {
              if (43758 <= e && e <= 43759)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 43765)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 44003) {
            if (e === 43766)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 44005) {
            if (44003 <= e && e <= 44004)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 44005)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 44032)
          if (e < 44009) {
            if (e < 44008) {
              if (44006 <= e && e <= 44007)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 44008)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 44012) {
            if (44009 <= e && e <= 44010)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else {
            if (e === 44012)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 44013)
              return n.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 44061) {
          if (e < 44033) {
            if (e === 44032)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 44060) {
            if (44033 <= e && e <= 44059)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 44060)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 44088) {
          if (44061 <= e && e <= 44087)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 44089) {
          if (e === 44088)
            return n.CLUSTER_BREAK.LV;
        } else if (44089 <= e && e <= 44115)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 46497) {
        if (e < 45293) {
          if (e < 44704) {
            if (e < 44397) {
              if (e < 44256) {
                if (e < 44173) {
                  if (e < 44144) {
                    if (e < 44117) {
                      if (e === 44116)
                        return n.CLUSTER_BREAK.LV;
                    } else if (44117 <= e && e <= 44143)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e < 44145) {
                    if (e === 44144)
                      return n.CLUSTER_BREAK.LV;
                  } else if (e < 44172) {
                    if (44145 <= e && e <= 44171)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 44172)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44201) {
                  if (e < 44200) {
                    if (44173 <= e && e <= 44199)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 44200)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44228) {
                  if (44201 <= e && e <= 44227)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44229) {
                  if (e === 44228)
                    return n.CLUSTER_BREAK.LV;
                } else if (44229 <= e && e <= 44255)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44313) {
                if (e < 44284) {
                  if (e < 44257) {
                    if (e === 44256)
                      return n.CLUSTER_BREAK.LV;
                  } else if (44257 <= e && e <= 44283)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44285) {
                  if (e === 44284)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44312) {
                  if (44285 <= e && e <= 44311)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 44312)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44368) {
                if (e < 44340) {
                  if (44313 <= e && e <= 44339)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44341) {
                  if (e === 44340)
                    return n.CLUSTER_BREAK.LV;
                } else if (44341 <= e && e <= 44367)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44369) {
                if (e === 44368)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44396) {
                if (44369 <= e && e <= 44395)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 44396)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44537) {
              if (e < 44480) {
                if (e < 44425) {
                  if (e < 44424) {
                    if (44397 <= e && e <= 44423)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 44424)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44452) {
                  if (44425 <= e && e <= 44451)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44453) {
                  if (e === 44452)
                    return n.CLUSTER_BREAK.LV;
                } else if (44453 <= e && e <= 44479)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44508) {
                if (e < 44481) {
                  if (e === 44480)
                    return n.CLUSTER_BREAK.LV;
                } else if (44481 <= e && e <= 44507)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44509) {
                if (e === 44508)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44536) {
                if (44509 <= e && e <= 44535)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 44536)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44620) {
              if (e < 44565) {
                if (e < 44564) {
                  if (44537 <= e && e <= 44563)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 44564)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44592) {
                if (44565 <= e && e <= 44591)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44593) {
                if (e === 44592)
                  return n.CLUSTER_BREAK.LV;
              } else if (44593 <= e && e <= 44619)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 44649) {
              if (e < 44621) {
                if (e === 44620)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44648) {
                if (44621 <= e && e <= 44647)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 44648)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44676) {
              if (44649 <= e && e <= 44675)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 44677) {
              if (e === 44676)
                return n.CLUSTER_BREAK.LV;
            } else if (44677 <= e && e <= 44703)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 44985) {
            if (e < 44844) {
              if (e < 44761) {
                if (e < 44732) {
                  if (e < 44705) {
                    if (e === 44704)
                      return n.CLUSTER_BREAK.LV;
                  } else if (44705 <= e && e <= 44731)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44733) {
                  if (e === 44732)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44760) {
                  if (44733 <= e && e <= 44759)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 44760)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44789) {
                if (e < 44788) {
                  if (44761 <= e && e <= 44787)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 44788)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44816) {
                if (44789 <= e && e <= 44815)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44817) {
                if (e === 44816)
                  return n.CLUSTER_BREAK.LV;
              } else if (44817 <= e && e <= 44843)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 44901) {
              if (e < 44872) {
                if (e < 44845) {
                  if (e === 44844)
                    return n.CLUSTER_BREAK.LV;
                } else if (44845 <= e && e <= 44871)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44873) {
                if (e === 44872)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44900) {
                if (44873 <= e && e <= 44899)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 44900)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44956) {
              if (e < 44928) {
                if (44901 <= e && e <= 44927)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44929) {
                if (e === 44928)
                  return n.CLUSTER_BREAK.LV;
              } else if (44929 <= e && e <= 44955)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 44957) {
              if (e === 44956)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44984) {
              if (44957 <= e && e <= 44983)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 44984)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45152) {
            if (e < 45068) {
              if (e < 45013) {
                if (e < 45012) {
                  if (44985 <= e && e <= 45011)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 45012)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45040) {
                if (45013 <= e && e <= 45039)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45041) {
                if (e === 45040)
                  return n.CLUSTER_BREAK.LV;
              } else if (45041 <= e && e <= 45067)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45097) {
              if (e < 45069) {
                if (e === 45068)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45096) {
                if (45069 <= e && e <= 45095)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45096)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45124) {
              if (45097 <= e && e <= 45123)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45125) {
              if (e === 45124)
                return n.CLUSTER_BREAK.LV;
            } else if (45125 <= e && e <= 45151)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45209) {
            if (e < 45180) {
              if (e < 45153) {
                if (e === 45152)
                  return n.CLUSTER_BREAK.LV;
              } else if (45153 <= e && e <= 45179)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45181) {
              if (e === 45180)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45208) {
              if (45181 <= e && e <= 45207)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 45208)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45264) {
            if (e < 45236) {
              if (45209 <= e && e <= 45235)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45237) {
              if (e === 45236)
                return n.CLUSTER_BREAK.LV;
            } else if (45237 <= e && e <= 45263)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45265) {
            if (e === 45264)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45292) {
            if (45265 <= e && e <= 45291)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 45292)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 45908) {
          if (e < 45600) {
            if (e < 45433) {
              if (e < 45376) {
                if (e < 45321) {
                  if (e < 45320) {
                    if (45293 <= e && e <= 45319)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 45320)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 45348) {
                  if (45321 <= e && e <= 45347)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 45349) {
                  if (e === 45348)
                    return n.CLUSTER_BREAK.LV;
                } else if (45349 <= e && e <= 45375)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45404) {
                if (e < 45377) {
                  if (e === 45376)
                    return n.CLUSTER_BREAK.LV;
                } else if (45377 <= e && e <= 45403)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45405) {
                if (e === 45404)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45432) {
                if (45405 <= e && e <= 45431)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45432)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45516) {
              if (e < 45461) {
                if (e < 45460) {
                  if (45433 <= e && e <= 45459)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 45460)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45488) {
                if (45461 <= e && e <= 45487)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45489) {
                if (e === 45488)
                  return n.CLUSTER_BREAK.LV;
              } else if (45489 <= e && e <= 45515)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45545) {
              if (e < 45517) {
                if (e === 45516)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45544) {
                if (45517 <= e && e <= 45543)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45544)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45572) {
              if (45545 <= e && e <= 45571)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45573) {
              if (e === 45572)
                return n.CLUSTER_BREAK.LV;
            } else if (45573 <= e && e <= 45599)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45741) {
            if (e < 45657) {
              if (e < 45628) {
                if (e < 45601) {
                  if (e === 45600)
                    return n.CLUSTER_BREAK.LV;
                } else if (45601 <= e && e <= 45627)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45629) {
                if (e === 45628)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45656) {
                if (45629 <= e && e <= 45655)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45656)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45712) {
              if (e < 45684) {
                if (45657 <= e && e <= 45683)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45685) {
                if (e === 45684)
                  return n.CLUSTER_BREAK.LV;
              } else if (45685 <= e && e <= 45711)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45713) {
              if (e === 45712)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45740) {
              if (45713 <= e && e <= 45739)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 45740)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45824) {
            if (e < 45769) {
              if (e < 45768) {
                if (45741 <= e && e <= 45767)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45768)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45796) {
              if (45769 <= e && e <= 45795)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45797) {
              if (e === 45796)
                return n.CLUSTER_BREAK.LV;
            } else if (45797 <= e && e <= 45823)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45853) {
            if (e < 45825) {
              if (e === 45824)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45852) {
              if (45825 <= e && e <= 45851)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 45852)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45880) {
            if (45853 <= e && e <= 45879)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45881) {
            if (e === 45880)
              return n.CLUSTER_BREAK.LV;
          } else if (45881 <= e && e <= 45907)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 46189) {
          if (e < 46048) {
            if (e < 45965) {
              if (e < 45936) {
                if (e < 45909) {
                  if (e === 45908)
                    return n.CLUSTER_BREAK.LV;
                } else if (45909 <= e && e <= 45935)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45937) {
                if (e === 45936)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45964) {
                if (45937 <= e && e <= 45963)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45964)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45993) {
              if (e < 45992) {
                if (45965 <= e && e <= 45991)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45992)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46020) {
              if (45993 <= e && e <= 46019)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46021) {
              if (e === 46020)
                return n.CLUSTER_BREAK.LV;
            } else if (46021 <= e && e <= 46047)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46105) {
            if (e < 46076) {
              if (e < 46049) {
                if (e === 46048)
                  return n.CLUSTER_BREAK.LV;
              } else if (46049 <= e && e <= 46075)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46077) {
              if (e === 46076)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46104) {
              if (46077 <= e && e <= 46103)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 46104)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 46160) {
            if (e < 46132) {
              if (46105 <= e && e <= 46131)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46133) {
              if (e === 46132)
                return n.CLUSTER_BREAK.LV;
            } else if (46133 <= e && e <= 46159)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46161) {
            if (e === 46160)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 46188) {
            if (46161 <= e && e <= 46187)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 46188)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 46356) {
          if (e < 46272) {
            if (e < 46217) {
              if (e < 46216) {
                if (46189 <= e && e <= 46215)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46216)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46244) {
              if (46217 <= e && e <= 46243)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46245) {
              if (e === 46244)
                return n.CLUSTER_BREAK.LV;
            } else if (46245 <= e && e <= 46271)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46301) {
            if (e < 46273) {
              if (e === 46272)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46300) {
              if (46273 <= e && e <= 46299)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 46300)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 46328) {
            if (46301 <= e && e <= 46327)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46329) {
            if (e === 46328)
              return n.CLUSTER_BREAK.LV;
          } else if (46329 <= e && e <= 46355)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 46413) {
          if (e < 46384) {
            if (e < 46357) {
              if (e === 46356)
                return n.CLUSTER_BREAK.LV;
            } else if (46357 <= e && e <= 46383)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46385) {
            if (e === 46384)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 46412) {
            if (46385 <= e && e <= 46411)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 46412)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 46468) {
          if (e < 46440) {
            if (46413 <= e && e <= 46439)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46441) {
            if (e === 46440)
              return n.CLUSTER_BREAK.LV;
          } else if (46441 <= e && e <= 46467)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 46469) {
          if (e === 46468)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 46496) {
          if (46469 <= e && e <= 46495)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 46496)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 47701) {
        if (e < 47112) {
          if (e < 46804) {
            if (e < 46637) {
              if (e < 46580) {
                if (e < 46525) {
                  if (e < 46524) {
                    if (46497 <= e && e <= 46523)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 46524)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 46552) {
                  if (46525 <= e && e <= 46551)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 46553) {
                  if (e === 46552)
                    return n.CLUSTER_BREAK.LV;
                } else if (46553 <= e && e <= 46579)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46608) {
                if (e < 46581) {
                  if (e === 46580)
                    return n.CLUSTER_BREAK.LV;
                } else if (46581 <= e && e <= 46607)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46609) {
                if (e === 46608)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 46636) {
                if (46609 <= e && e <= 46635)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46636)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46720) {
              if (e < 46665) {
                if (e < 46664) {
                  if (46637 <= e && e <= 46663)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 46664)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 46692) {
                if (46665 <= e && e <= 46691)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46693) {
                if (e === 46692)
                  return n.CLUSTER_BREAK.LV;
              } else if (46693 <= e && e <= 46719)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46749) {
              if (e < 46721) {
                if (e === 46720)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 46748) {
                if (46721 <= e && e <= 46747)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46748)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46776) {
              if (46749 <= e && e <= 46775)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46777) {
              if (e === 46776)
                return n.CLUSTER_BREAK.LV;
            } else if (46777 <= e && e <= 46803)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46945) {
            if (e < 46861) {
              if (e < 46832) {
                if (e < 46805) {
                  if (e === 46804)
                    return n.CLUSTER_BREAK.LV;
                } else if (46805 <= e && e <= 46831)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46833) {
                if (e === 46832)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 46860) {
                if (46833 <= e && e <= 46859)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46860)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46916) {
              if (e < 46888) {
                if (46861 <= e && e <= 46887)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46889) {
                if (e === 46888)
                  return n.CLUSTER_BREAK.LV;
              } else if (46889 <= e && e <= 46915)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46917) {
              if (e === 46916)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46944) {
              if (46917 <= e && e <= 46943)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 46944)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47028) {
            if (e < 46973) {
              if (e < 46972) {
                if (46945 <= e && e <= 46971)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46972)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47e3) {
              if (46973 <= e && e <= 46999)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47001) {
              if (e === 47e3)
                return n.CLUSTER_BREAK.LV;
            } else if (47001 <= e && e <= 47027)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47057) {
            if (e < 47029) {
              if (e === 47028)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47056) {
              if (47029 <= e && e <= 47055)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47056)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47084) {
            if (47057 <= e && e <= 47083)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47085) {
            if (e === 47084)
              return n.CLUSTER_BREAK.LV;
          } else if (47085 <= e && e <= 47111)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 47393) {
          if (e < 47252) {
            if (e < 47169) {
              if (e < 47140) {
                if (e < 47113) {
                  if (e === 47112)
                    return n.CLUSTER_BREAK.LV;
                } else if (47113 <= e && e <= 47139)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 47141) {
                if (e === 47140)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 47168) {
                if (47141 <= e && e <= 47167)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 47168)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47197) {
              if (e < 47196) {
                if (47169 <= e && e <= 47195)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 47196)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47224) {
              if (47197 <= e && e <= 47223)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47225) {
              if (e === 47224)
                return n.CLUSTER_BREAK.LV;
            } else if (47225 <= e && e <= 47251)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47309) {
            if (e < 47280) {
              if (e < 47253) {
                if (e === 47252)
                  return n.CLUSTER_BREAK.LV;
              } else if (47253 <= e && e <= 47279)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47281) {
              if (e === 47280)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47308) {
              if (47281 <= e && e <= 47307)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47308)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47364) {
            if (e < 47336) {
              if (47309 <= e && e <= 47335)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47337) {
              if (e === 47336)
                return n.CLUSTER_BREAK.LV;
            } else if (47337 <= e && e <= 47363)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47365) {
            if (e === 47364)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47392) {
            if (47365 <= e && e <= 47391)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 47392)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 47560) {
          if (e < 47476) {
            if (e < 47421) {
              if (e < 47420) {
                if (47393 <= e && e <= 47419)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 47420)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47448) {
              if (47421 <= e && e <= 47447)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47449) {
              if (e === 47448)
                return n.CLUSTER_BREAK.LV;
            } else if (47449 <= e && e <= 47475)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47505) {
            if (e < 47477) {
              if (e === 47476)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47504) {
              if (47477 <= e && e <= 47503)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47504)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47532) {
            if (47505 <= e && e <= 47531)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47533) {
            if (e === 47532)
              return n.CLUSTER_BREAK.LV;
          } else if (47533 <= e && e <= 47559)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 47617) {
          if (e < 47588) {
            if (e < 47561) {
              if (e === 47560)
                return n.CLUSTER_BREAK.LV;
            } else if (47561 <= e && e <= 47587)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47589) {
            if (e === 47588)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47616) {
            if (47589 <= e && e <= 47615)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 47616)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 47672) {
          if (e < 47644) {
            if (47617 <= e && e <= 47643)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47645) {
            if (e === 47644)
              return n.CLUSTER_BREAK.LV;
          } else if (47645 <= e && e <= 47671)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 47673) {
          if (e === 47672)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 47700) {
          if (47673 <= e && e <= 47699)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 47700)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 48316) {
        if (e < 48008) {
          if (e < 47841) {
            if (e < 47784) {
              if (e < 47729) {
                if (e < 47728) {
                  if (47701 <= e && e <= 47727)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 47728)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 47756) {
                if (47729 <= e && e <= 47755)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 47757) {
                if (e === 47756)
                  return n.CLUSTER_BREAK.LV;
              } else if (47757 <= e && e <= 47783)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47812) {
              if (e < 47785) {
                if (e === 47784)
                  return n.CLUSTER_BREAK.LV;
              } else if (47785 <= e && e <= 47811)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47813) {
              if (e === 47812)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47840) {
              if (47813 <= e && e <= 47839)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47840)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47924) {
            if (e < 47869) {
              if (e < 47868) {
                if (47841 <= e && e <= 47867)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 47868)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47896) {
              if (47869 <= e && e <= 47895)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47897) {
              if (e === 47896)
                return n.CLUSTER_BREAK.LV;
            } else if (47897 <= e && e <= 47923)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47953) {
            if (e < 47925) {
              if (e === 47924)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47952) {
              if (47925 <= e && e <= 47951)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47952)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47980) {
            if (47953 <= e && e <= 47979)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47981) {
            if (e === 47980)
              return n.CLUSTER_BREAK.LV;
          } else if (47981 <= e && e <= 48007)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48149) {
          if (e < 48065) {
            if (e < 48036) {
              if (e < 48009) {
                if (e === 48008)
                  return n.CLUSTER_BREAK.LV;
              } else if (48009 <= e && e <= 48035)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 48037) {
              if (e === 48036)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 48064) {
              if (48037 <= e && e <= 48063)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48064)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48120) {
            if (e < 48092) {
              if (48065 <= e && e <= 48091)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 48093) {
              if (e === 48092)
                return n.CLUSTER_BREAK.LV;
            } else if (48093 <= e && e <= 48119)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48121) {
            if (e === 48120)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48148) {
            if (48121 <= e && e <= 48147)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 48148)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48232) {
          if (e < 48177) {
            if (e < 48176) {
              if (48149 <= e && e <= 48175)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48176)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48204) {
            if (48177 <= e && e <= 48203)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48205) {
            if (e === 48204)
              return n.CLUSTER_BREAK.LV;
          } else if (48205 <= e && e <= 48231)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48261) {
          if (e < 48233) {
            if (e === 48232)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48260) {
            if (48233 <= e && e <= 48259)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 48260)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48288) {
          if (48261 <= e && e <= 48287)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48289) {
          if (e === 48288)
            return n.CLUSTER_BREAK.LV;
        } else if (48289 <= e && e <= 48315)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 48597) {
        if (e < 48456) {
          if (e < 48373) {
            if (e < 48344) {
              if (e < 48317) {
                if (e === 48316)
                  return n.CLUSTER_BREAK.LV;
              } else if (48317 <= e && e <= 48343)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 48345) {
              if (e === 48344)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 48372) {
              if (48345 <= e && e <= 48371)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48372)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48401) {
            if (e < 48400) {
              if (48373 <= e && e <= 48399)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48400)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48428) {
            if (48401 <= e && e <= 48427)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48429) {
            if (e === 48428)
              return n.CLUSTER_BREAK.LV;
          } else if (48429 <= e && e <= 48455)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48513) {
          if (e < 48484) {
            if (e < 48457) {
              if (e === 48456)
                return n.CLUSTER_BREAK.LV;
            } else if (48457 <= e && e <= 48483)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48485) {
            if (e === 48484)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48512) {
            if (48485 <= e && e <= 48511)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 48512)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48568) {
          if (e < 48540) {
            if (48513 <= e && e <= 48539)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48541) {
            if (e === 48540)
              return n.CLUSTER_BREAK.LV;
          } else if (48541 <= e && e <= 48567)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48569) {
          if (e === 48568)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48596) {
          if (48569 <= e && e <= 48595)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 48596)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 48764) {
        if (e < 48680) {
          if (e < 48625) {
            if (e < 48624) {
              if (48597 <= e && e <= 48623)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48624)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48652) {
            if (48625 <= e && e <= 48651)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48653) {
            if (e === 48652)
              return n.CLUSTER_BREAK.LV;
          } else if (48653 <= e && e <= 48679)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48709) {
          if (e < 48681) {
            if (e === 48680)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48708) {
            if (48681 <= e && e <= 48707)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 48708)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48736) {
          if (48709 <= e && e <= 48735)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48737) {
          if (e === 48736)
            return n.CLUSTER_BREAK.LV;
        } else if (48737 <= e && e <= 48763)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 48821) {
        if (e < 48792) {
          if (e < 48765) {
            if (e === 48764)
              return n.CLUSTER_BREAK.LV;
          } else if (48765 <= e && e <= 48791)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48793) {
          if (e === 48792)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48820) {
          if (48793 <= e && e <= 48819)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 48820)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 48876) {
        if (e < 48848) {
          if (48821 <= e && e <= 48847)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48849) {
          if (e === 48848)
            return n.CLUSTER_BREAK.LV;
        } else if (48849 <= e && e <= 48875)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 48877) {
        if (e === 48876)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 48904) {
        if (48877 <= e && e <= 48903)
          return n.CLUSTER_BREAK.LVT;
      } else if (e === 48904)
        return n.CLUSTER_BREAK.LV;
    } else if (e < 53720) {
      if (e < 51312) {
        if (e < 50108) {
          if (e < 49493) {
            if (e < 49212) {
              if (e < 49045) {
                if (e < 48988) {
                  if (e < 48933) {
                    if (e < 48932) {
                      if (48905 <= e && e <= 48931)
                        return n.CLUSTER_BREAK.LVT;
                    } else if (e === 48932)
                      return n.CLUSTER_BREAK.LV;
                  } else if (e < 48960) {
                    if (48933 <= e && e <= 48959)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e < 48961) {
                    if (e === 48960)
                      return n.CLUSTER_BREAK.LV;
                  } else if (48961 <= e && e <= 48987)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49016) {
                  if (e < 48989) {
                    if (e === 48988)
                      return n.CLUSTER_BREAK.LV;
                  } else if (48989 <= e && e <= 49015)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49017) {
                  if (e === 49016)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49044) {
                  if (49017 <= e && e <= 49043)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49044)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49128) {
                if (e < 49073) {
                  if (e < 49072) {
                    if (49045 <= e && e <= 49071)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 49072)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49100) {
                  if (49073 <= e && e <= 49099)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49101) {
                  if (e === 49100)
                    return n.CLUSTER_BREAK.LV;
                } else if (49101 <= e && e <= 49127)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49157) {
                if (e < 49129) {
                  if (e === 49128)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49156) {
                  if (49129 <= e && e <= 49155)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49156)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49184) {
                if (49157 <= e && e <= 49183)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49185) {
                if (e === 49184)
                  return n.CLUSTER_BREAK.LV;
              } else if (49185 <= e && e <= 49211)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49352) {
              if (e < 49269) {
                if (e < 49240) {
                  if (e < 49213) {
                    if (e === 49212)
                      return n.CLUSTER_BREAK.LV;
                  } else if (49213 <= e && e <= 49239)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49241) {
                  if (e === 49240)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49268) {
                  if (49241 <= e && e <= 49267)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49268)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49297) {
                if (e < 49296) {
                  if (49269 <= e && e <= 49295)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49296)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49324) {
                if (49297 <= e && e <= 49323)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49325) {
                if (e === 49324)
                  return n.CLUSTER_BREAK.LV;
              } else if (49325 <= e && e <= 49351)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49409) {
              if (e < 49380) {
                if (e < 49353) {
                  if (e === 49352)
                    return n.CLUSTER_BREAK.LV;
                } else if (49353 <= e && e <= 49379)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49381) {
                if (e === 49380)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49408) {
                if (49381 <= e && e <= 49407)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49408)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49464) {
              if (e < 49436) {
                if (49409 <= e && e <= 49435)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49437) {
                if (e === 49436)
                  return n.CLUSTER_BREAK.LV;
              } else if (49437 <= e && e <= 49463)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49465) {
              if (e === 49464)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49492) {
              if (49465 <= e && e <= 49491)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 49492)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 49800) {
            if (e < 49633) {
              if (e < 49576) {
                if (e < 49521) {
                  if (e < 49520) {
                    if (49493 <= e && e <= 49519)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 49520)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49548) {
                  if (49521 <= e && e <= 49547)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49549) {
                  if (e === 49548)
                    return n.CLUSTER_BREAK.LV;
                } else if (49549 <= e && e <= 49575)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49604) {
                if (e < 49577) {
                  if (e === 49576)
                    return n.CLUSTER_BREAK.LV;
                } else if (49577 <= e && e <= 49603)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49605) {
                if (e === 49604)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49632) {
                if (49605 <= e && e <= 49631)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49632)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49716) {
              if (e < 49661) {
                if (e < 49660) {
                  if (49633 <= e && e <= 49659)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49660)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49688) {
                if (49661 <= e && e <= 49687)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49689) {
                if (e === 49688)
                  return n.CLUSTER_BREAK.LV;
              } else if (49689 <= e && e <= 49715)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49745) {
              if (e < 49717) {
                if (e === 49716)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49744) {
                if (49717 <= e && e <= 49743)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49744)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49772) {
              if (49745 <= e && e <= 49771)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49773) {
              if (e === 49772)
                return n.CLUSTER_BREAK.LV;
            } else if (49773 <= e && e <= 49799)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 49941) {
            if (e < 49857) {
              if (e < 49828) {
                if (e < 49801) {
                  if (e === 49800)
                    return n.CLUSTER_BREAK.LV;
                } else if (49801 <= e && e <= 49827)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49829) {
                if (e === 49828)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49856) {
                if (49829 <= e && e <= 49855)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49856)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49912) {
              if (e < 49884) {
                if (49857 <= e && e <= 49883)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49885) {
                if (e === 49884)
                  return n.CLUSTER_BREAK.LV;
              } else if (49885 <= e && e <= 49911)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49913) {
              if (e === 49912)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49940) {
              if (49913 <= e && e <= 49939)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 49940)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50024) {
            if (e < 49969) {
              if (e < 49968) {
                if (49941 <= e && e <= 49967)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49968)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49996) {
              if (49969 <= e && e <= 49995)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49997) {
              if (e === 49996)
                return n.CLUSTER_BREAK.LV;
            } else if (49997 <= e && e <= 50023)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50053) {
            if (e < 50025) {
              if (e === 50024)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50052) {
              if (50025 <= e && e <= 50051)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50052)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50080) {
            if (50053 <= e && e <= 50079)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50081) {
            if (e === 50080)
              return n.CLUSTER_BREAK.LV;
          } else if (50081 <= e && e <= 50107)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 50697) {
          if (e < 50389) {
            if (e < 50248) {
              if (e < 50165) {
                if (e < 50136) {
                  if (e < 50109) {
                    if (e === 50108)
                      return n.CLUSTER_BREAK.LV;
                  } else if (50109 <= e && e <= 50135)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 50137) {
                  if (e === 50136)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 50164) {
                  if (50137 <= e && e <= 50163)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 50164)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50193) {
                if (e < 50192) {
                  if (50165 <= e && e <= 50191)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 50192)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50220) {
                if (50193 <= e && e <= 50219)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50221) {
                if (e === 50220)
                  return n.CLUSTER_BREAK.LV;
              } else if (50221 <= e && e <= 50247)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50305) {
              if (e < 50276) {
                if (e < 50249) {
                  if (e === 50248)
                    return n.CLUSTER_BREAK.LV;
                } else if (50249 <= e && e <= 50275)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50277) {
                if (e === 50276)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50304) {
                if (50277 <= e && e <= 50303)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 50304)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50360) {
              if (e < 50332) {
                if (50305 <= e && e <= 50331)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50333) {
                if (e === 50332)
                  return n.CLUSTER_BREAK.LV;
              } else if (50333 <= e && e <= 50359)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50361) {
              if (e === 50360)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50388) {
              if (50361 <= e && e <= 50387)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50388)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50556) {
            if (e < 50472) {
              if (e < 50417) {
                if (e < 50416) {
                  if (50389 <= e && e <= 50415)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 50416)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50444) {
                if (50417 <= e && e <= 50443)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50445) {
                if (e === 50444)
                  return n.CLUSTER_BREAK.LV;
              } else if (50445 <= e && e <= 50471)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50501) {
              if (e < 50473) {
                if (e === 50472)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50500) {
                if (50473 <= e && e <= 50499)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 50500)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50528) {
              if (50501 <= e && e <= 50527)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50529) {
              if (e === 50528)
                return n.CLUSTER_BREAK.LV;
            } else if (50529 <= e && e <= 50555)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50613) {
            if (e < 50584) {
              if (e < 50557) {
                if (e === 50556)
                  return n.CLUSTER_BREAK.LV;
              } else if (50557 <= e && e <= 50583)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50585) {
              if (e === 50584)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50612) {
              if (50585 <= e && e <= 50611)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50612)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50668) {
            if (e < 50640) {
              if (50613 <= e && e <= 50639)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50641) {
              if (e === 50640)
                return n.CLUSTER_BREAK.LV;
            } else if (50641 <= e && e <= 50667)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50669) {
            if (e === 50668)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50696) {
            if (50669 <= e && e <= 50695)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 50696)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 51004) {
          if (e < 50837) {
            if (e < 50780) {
              if (e < 50725) {
                if (e < 50724) {
                  if (50697 <= e && e <= 50723)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 50724)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50752) {
                if (50725 <= e && e <= 50751)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50753) {
                if (e === 50752)
                  return n.CLUSTER_BREAK.LV;
              } else if (50753 <= e && e <= 50779)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50808) {
              if (e < 50781) {
                if (e === 50780)
                  return n.CLUSTER_BREAK.LV;
              } else if (50781 <= e && e <= 50807)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50809) {
              if (e === 50808)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50836) {
              if (50809 <= e && e <= 50835)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50836)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50920) {
            if (e < 50865) {
              if (e < 50864) {
                if (50837 <= e && e <= 50863)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 50864)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50892) {
              if (50865 <= e && e <= 50891)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50893) {
              if (e === 50892)
                return n.CLUSTER_BREAK.LV;
            } else if (50893 <= e && e <= 50919)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50949) {
            if (e < 50921) {
              if (e === 50920)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50948) {
              if (50921 <= e && e <= 50947)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50948)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50976) {
            if (50949 <= e && e <= 50975)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50977) {
            if (e === 50976)
              return n.CLUSTER_BREAK.LV;
          } else if (50977 <= e && e <= 51003)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 51145) {
          if (e < 51061) {
            if (e < 51032) {
              if (e < 51005) {
                if (e === 51004)
                  return n.CLUSTER_BREAK.LV;
              } else if (51005 <= e && e <= 51031)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51033) {
              if (e === 51032)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51060) {
              if (51033 <= e && e <= 51059)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 51060)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51116) {
            if (e < 51088) {
              if (51061 <= e && e <= 51087)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51089) {
              if (e === 51088)
                return n.CLUSTER_BREAK.LV;
            } else if (51089 <= e && e <= 51115)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 51117) {
            if (e === 51116)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51144) {
            if (51117 <= e && e <= 51143)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 51144)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 51228) {
          if (e < 51173) {
            if (e < 51172) {
              if (51145 <= e && e <= 51171)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 51172)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51200) {
            if (51173 <= e && e <= 51199)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 51201) {
            if (e === 51200)
              return n.CLUSTER_BREAK.LV;
          } else if (51201 <= e && e <= 51227)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 51257) {
          if (e < 51229) {
            if (e === 51228)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51256) {
            if (51229 <= e && e <= 51255)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 51256)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 51284) {
          if (51257 <= e && e <= 51283)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 51285) {
          if (e === 51284)
            return n.CLUSTER_BREAK.LV;
        } else if (51285 <= e && e <= 51311)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 52516) {
        if (e < 51901) {
          if (e < 51593) {
            if (e < 51452) {
              if (e < 51369) {
                if (e < 51340) {
                  if (e < 51313) {
                    if (e === 51312)
                      return n.CLUSTER_BREAK.LV;
                  } else if (51313 <= e && e <= 51339)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 51341) {
                  if (e === 51340)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 51368) {
                  if (51341 <= e && e <= 51367)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 51368)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51397) {
                if (e < 51396) {
                  if (51369 <= e && e <= 51395)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 51396)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51424) {
                if (51397 <= e && e <= 51423)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51425) {
                if (e === 51424)
                  return n.CLUSTER_BREAK.LV;
              } else if (51425 <= e && e <= 51451)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51509) {
              if (e < 51480) {
                if (e < 51453) {
                  if (e === 51452)
                    return n.CLUSTER_BREAK.LV;
                } else if (51453 <= e && e <= 51479)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51481) {
                if (e === 51480)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51508) {
                if (51481 <= e && e <= 51507)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 51508)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51564) {
              if (e < 51536) {
                if (51509 <= e && e <= 51535)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51537) {
                if (e === 51536)
                  return n.CLUSTER_BREAK.LV;
              } else if (51537 <= e && e <= 51563)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51565) {
              if (e === 51564)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51592) {
              if (51565 <= e && e <= 51591)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 51592)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51760) {
            if (e < 51676) {
              if (e < 51621) {
                if (e < 51620) {
                  if (51593 <= e && e <= 51619)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 51620)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51648) {
                if (51621 <= e && e <= 51647)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51649) {
                if (e === 51648)
                  return n.CLUSTER_BREAK.LV;
              } else if (51649 <= e && e <= 51675)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51705) {
              if (e < 51677) {
                if (e === 51676)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51704) {
                if (51677 <= e && e <= 51703)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 51704)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51732) {
              if (51705 <= e && e <= 51731)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51733) {
              if (e === 51732)
                return n.CLUSTER_BREAK.LV;
            } else if (51733 <= e && e <= 51759)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 51817) {
            if (e < 51788) {
              if (e < 51761) {
                if (e === 51760)
                  return n.CLUSTER_BREAK.LV;
              } else if (51761 <= e && e <= 51787)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51789) {
              if (e === 51788)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51816) {
              if (51789 <= e && e <= 51815)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 51816)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51872) {
            if (e < 51844) {
              if (51817 <= e && e <= 51843)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51845) {
              if (e === 51844)
                return n.CLUSTER_BREAK.LV;
            } else if (51845 <= e && e <= 51871)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 51873) {
            if (e === 51872)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51900) {
            if (51873 <= e && e <= 51899)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 51900)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 52208) {
          if (e < 52041) {
            if (e < 51984) {
              if (e < 51929) {
                if (e < 51928) {
                  if (51901 <= e && e <= 51927)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 51928)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51956) {
                if (51929 <= e && e <= 51955)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51957) {
                if (e === 51956)
                  return n.CLUSTER_BREAK.LV;
              } else if (51957 <= e && e <= 51983)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52012) {
              if (e < 51985) {
                if (e === 51984)
                  return n.CLUSTER_BREAK.LV;
              } else if (51985 <= e && e <= 52011)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52013) {
              if (e === 52012)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52040) {
              if (52013 <= e && e <= 52039)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52040)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52124) {
            if (e < 52069) {
              if (e < 52068) {
                if (52041 <= e && e <= 52067)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 52068)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52096) {
              if (52069 <= e && e <= 52095)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52097) {
              if (e === 52096)
                return n.CLUSTER_BREAK.LV;
            } else if (52097 <= e && e <= 52123)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52153) {
            if (e < 52125) {
              if (e === 52124)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52152) {
              if (52125 <= e && e <= 52151)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52152)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52180) {
            if (52153 <= e && e <= 52179)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52181) {
            if (e === 52180)
              return n.CLUSTER_BREAK.LV;
          } else if (52181 <= e && e <= 52207)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 52349) {
          if (e < 52265) {
            if (e < 52236) {
              if (e < 52209) {
                if (e === 52208)
                  return n.CLUSTER_BREAK.LV;
              } else if (52209 <= e && e <= 52235)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52237) {
              if (e === 52236)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52264) {
              if (52237 <= e && e <= 52263)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52264)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52320) {
            if (e < 52292) {
              if (52265 <= e && e <= 52291)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52293) {
              if (e === 52292)
                return n.CLUSTER_BREAK.LV;
            } else if (52293 <= e && e <= 52319)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52321) {
            if (e === 52320)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52348) {
            if (52321 <= e && e <= 52347)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 52348)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 52432) {
          if (e < 52377) {
            if (e < 52376) {
              if (52349 <= e && e <= 52375)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52376)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52404) {
            if (52377 <= e && e <= 52403)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52405) {
            if (e === 52404)
              return n.CLUSTER_BREAK.LV;
          } else if (52405 <= e && e <= 52431)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 52461) {
          if (e < 52433) {
            if (e === 52432)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52460) {
            if (52433 <= e && e <= 52459)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 52460)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 52488) {
          if (52461 <= e && e <= 52487)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 52489) {
          if (e === 52488)
            return n.CLUSTER_BREAK.LV;
        } else if (52489 <= e && e <= 52515)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 53105) {
        if (e < 52797) {
          if (e < 52656) {
            if (e < 52573) {
              if (e < 52544) {
                if (e < 52517) {
                  if (e === 52516)
                    return n.CLUSTER_BREAK.LV;
                } else if (52517 <= e && e <= 52543)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 52545) {
                if (e === 52544)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 52572) {
                if (52545 <= e && e <= 52571)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 52572)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52601) {
              if (e < 52600) {
                if (52573 <= e && e <= 52599)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 52600)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52628) {
              if (52601 <= e && e <= 52627)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52629) {
              if (e === 52628)
                return n.CLUSTER_BREAK.LV;
            } else if (52629 <= e && e <= 52655)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52713) {
            if (e < 52684) {
              if (e < 52657) {
                if (e === 52656)
                  return n.CLUSTER_BREAK.LV;
              } else if (52657 <= e && e <= 52683)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52685) {
              if (e === 52684)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52712) {
              if (52685 <= e && e <= 52711)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52712)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52768) {
            if (e < 52740) {
              if (52713 <= e && e <= 52739)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52741) {
              if (e === 52740)
                return n.CLUSTER_BREAK.LV;
            } else if (52741 <= e && e <= 52767)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52769) {
            if (e === 52768)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52796) {
            if (52769 <= e && e <= 52795)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 52796)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 52964) {
          if (e < 52880) {
            if (e < 52825) {
              if (e < 52824) {
                if (52797 <= e && e <= 52823)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 52824)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52852) {
              if (52825 <= e && e <= 52851)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52853) {
              if (e === 52852)
                return n.CLUSTER_BREAK.LV;
            } else if (52853 <= e && e <= 52879)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52909) {
            if (e < 52881) {
              if (e === 52880)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52908) {
              if (52881 <= e && e <= 52907)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52908)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52936) {
            if (52909 <= e && e <= 52935)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52937) {
            if (e === 52936)
              return n.CLUSTER_BREAK.LV;
          } else if (52937 <= e && e <= 52963)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53021) {
          if (e < 52992) {
            if (e < 52965) {
              if (e === 52964)
                return n.CLUSTER_BREAK.LV;
            } else if (52965 <= e && e <= 52991)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52993) {
            if (e === 52992)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53020) {
            if (52993 <= e && e <= 53019)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53020)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53076) {
          if (e < 53048) {
            if (53021 <= e && e <= 53047)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53049) {
            if (e === 53048)
              return n.CLUSTER_BREAK.LV;
          } else if (53049 <= e && e <= 53075)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53077) {
          if (e === 53076)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53104) {
          if (53077 <= e && e <= 53103)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 53104)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 53412) {
        if (e < 53245) {
          if (e < 53188) {
            if (e < 53133) {
              if (e < 53132) {
                if (53105 <= e && e <= 53131)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 53132)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 53160) {
              if (53133 <= e && e <= 53159)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 53161) {
              if (e === 53160)
                return n.CLUSTER_BREAK.LV;
            } else if (53161 <= e && e <= 53187)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53216) {
            if (e < 53189) {
              if (e === 53188)
                return n.CLUSTER_BREAK.LV;
            } else if (53189 <= e && e <= 53215)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53217) {
            if (e === 53216)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53244) {
            if (53217 <= e && e <= 53243)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53244)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53328) {
          if (e < 53273) {
            if (e < 53272) {
              if (53245 <= e && e <= 53271)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 53272)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53300) {
            if (53273 <= e && e <= 53299)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53301) {
            if (e === 53300)
              return n.CLUSTER_BREAK.LV;
          } else if (53301 <= e && e <= 53327)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53357) {
          if (e < 53329) {
            if (e === 53328)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53356) {
            if (53329 <= e && e <= 53355)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53356)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53384) {
          if (53357 <= e && e <= 53383)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53385) {
          if (e === 53384)
            return n.CLUSTER_BREAK.LV;
        } else if (53385 <= e && e <= 53411)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 53553) {
        if (e < 53469) {
          if (e < 53440) {
            if (e < 53413) {
              if (e === 53412)
                return n.CLUSTER_BREAK.LV;
            } else if (53413 <= e && e <= 53439)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53441) {
            if (e === 53440)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53468) {
            if (53441 <= e && e <= 53467)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53468)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53524) {
          if (e < 53496) {
            if (53469 <= e && e <= 53495)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53497) {
            if (e === 53496)
              return n.CLUSTER_BREAK.LV;
          } else if (53497 <= e && e <= 53523)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53525) {
          if (e === 53524)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53552) {
          if (53525 <= e && e <= 53551)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 53552)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 53636) {
        if (e < 53581) {
          if (e < 53580) {
            if (53553 <= e && e <= 53579)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53580)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53608) {
          if (53581 <= e && e <= 53607)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53609) {
          if (e === 53608)
            return n.CLUSTER_BREAK.LV;
        } else if (53609 <= e && e <= 53635)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 53665) {
        if (e < 53637) {
          if (e === 53636)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53664) {
          if (53637 <= e && e <= 53663)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 53664)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 53692) {
        if (53665 <= e && e <= 53691)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 53693) {
        if (e === 53692)
          return n.CLUSTER_BREAK.LV;
      } else if (53693 <= e && e <= 53719)
        return n.CLUSTER_BREAK.LVT;
    } else if (e < 70459) {
      if (e < 54897) {
        if (e < 54308) {
          if (e < 54001) {
            if (e < 53860) {
              if (e < 53777) {
                if (e < 53748) {
                  if (e < 53721) {
                    if (e === 53720)
                      return n.CLUSTER_BREAK.LV;
                  } else if (53721 <= e && e <= 53747)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 53749) {
                  if (e === 53748)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 53776) {
                  if (53749 <= e && e <= 53775)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 53776)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 53805) {
                if (e < 53804) {
                  if (53777 <= e && e <= 53803)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 53804)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 53832) {
                if (53805 <= e && e <= 53831)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 53833) {
                if (e === 53832)
                  return n.CLUSTER_BREAK.LV;
              } else if (53833 <= e && e <= 53859)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 53917) {
              if (e < 53888) {
                if (e < 53861) {
                  if (e === 53860)
                    return n.CLUSTER_BREAK.LV;
                } else if (53861 <= e && e <= 53887)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 53889) {
                if (e === 53888)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 53916) {
                if (53889 <= e && e <= 53915)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 53916)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 53972) {
              if (e < 53944) {
                if (53917 <= e && e <= 53943)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 53945) {
                if (e === 53944)
                  return n.CLUSTER_BREAK.LV;
              } else if (53945 <= e && e <= 53971)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 53973) {
              if (e === 53972)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54e3) {
              if (53973 <= e && e <= 53999)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54e3)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54141) {
            if (e < 54084) {
              if (e < 54029) {
                if (e < 54028) {
                  if (54001 <= e && e <= 54027)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 54028)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 54056) {
                if (54029 <= e && e <= 54055)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 54057) {
                if (e === 54056)
                  return n.CLUSTER_BREAK.LV;
              } else if (54057 <= e && e <= 54083)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54112) {
              if (e < 54085) {
                if (e === 54084)
                  return n.CLUSTER_BREAK.LV;
              } else if (54085 <= e && e <= 54111)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54113) {
              if (e === 54112)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54140) {
              if (54113 <= e && e <= 54139)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54140)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54224) {
            if (e < 54169) {
              if (e < 54168) {
                if (54141 <= e && e <= 54167)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 54168)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54196) {
              if (54169 <= e && e <= 54195)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54197) {
              if (e === 54196)
                return n.CLUSTER_BREAK.LV;
            } else if (54197 <= e && e <= 54223)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54253) {
            if (e < 54225) {
              if (e === 54224)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54252) {
              if (54225 <= e && e <= 54251)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54252)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54280) {
            if (54253 <= e && e <= 54279)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54281) {
            if (e === 54280)
              return n.CLUSTER_BREAK.LV;
          } else if (54281 <= e && e <= 54307)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 54589) {
          if (e < 54448) {
            if (e < 54365) {
              if (e < 54336) {
                if (e < 54309) {
                  if (e === 54308)
                    return n.CLUSTER_BREAK.LV;
                } else if (54309 <= e && e <= 54335)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 54337) {
                if (e === 54336)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 54364) {
                if (54337 <= e && e <= 54363)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 54364)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54393) {
              if (e < 54392) {
                if (54365 <= e && e <= 54391)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 54392)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54420) {
              if (54393 <= e && e <= 54419)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54421) {
              if (e === 54420)
                return n.CLUSTER_BREAK.LV;
            } else if (54421 <= e && e <= 54447)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54505) {
            if (e < 54476) {
              if (e < 54449) {
                if (e === 54448)
                  return n.CLUSTER_BREAK.LV;
              } else if (54449 <= e && e <= 54475)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54477) {
              if (e === 54476)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54504) {
              if (54477 <= e && e <= 54503)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54504)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54560) {
            if (e < 54532) {
              if (54505 <= e && e <= 54531)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54533) {
              if (e === 54532)
                return n.CLUSTER_BREAK.LV;
            } else if (54533 <= e && e <= 54559)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54561) {
            if (e === 54560)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54588) {
            if (54561 <= e && e <= 54587)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 54588)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 54756) {
          if (e < 54672) {
            if (e < 54617) {
              if (e < 54616) {
                if (54589 <= e && e <= 54615)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 54616)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54644) {
              if (54617 <= e && e <= 54643)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54645) {
              if (e === 54644)
                return n.CLUSTER_BREAK.LV;
            } else if (54645 <= e && e <= 54671)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54701) {
            if (e < 54673) {
              if (e === 54672)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54700) {
              if (54673 <= e && e <= 54699)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54700)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54728) {
            if (54701 <= e && e <= 54727)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54729) {
            if (e === 54728)
              return n.CLUSTER_BREAK.LV;
          } else if (54729 <= e && e <= 54755)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 54813) {
          if (e < 54784) {
            if (e < 54757) {
              if (e === 54756)
                return n.CLUSTER_BREAK.LV;
            } else if (54757 <= e && e <= 54783)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54785) {
            if (e === 54784)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54812) {
            if (54785 <= e && e <= 54811)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 54812)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 54868) {
          if (e < 54840) {
            if (54813 <= e && e <= 54839)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54841) {
            if (e === 54840)
              return n.CLUSTER_BREAK.LV;
          } else if (54841 <= e && e <= 54867)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 54869) {
          if (e === 54868)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 54896) {
          if (54869 <= e && e <= 54895)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 54896)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 69632) {
        if (e < 55216) {
          if (e < 55037) {
            if (e < 54980) {
              if (e < 54925) {
                if (e < 54924) {
                  if (54897 <= e && e <= 54923)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 54924)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 54952) {
                if (54925 <= e && e <= 54951)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 54953) {
                if (e === 54952)
                  return n.CLUSTER_BREAK.LV;
              } else if (54953 <= e && e <= 54979)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 55008) {
              if (e < 54981) {
                if (e === 54980)
                  return n.CLUSTER_BREAK.LV;
              } else if (54981 <= e && e <= 55007)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 55009) {
              if (e === 55008)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 55036) {
              if (55009 <= e && e <= 55035)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 55036)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 55120) {
            if (e < 55065) {
              if (e < 55064) {
                if (55037 <= e && e <= 55063)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 55064)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 55092) {
              if (55065 <= e && e <= 55091)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 55093) {
              if (e === 55092)
                return n.CLUSTER_BREAK.LV;
            } else if (55093 <= e && e <= 55119)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 55149) {
            if (e < 55121) {
              if (e === 55120)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 55148) {
              if (55121 <= e && e <= 55147)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 55148)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 55176) {
            if (55149 <= e && e <= 55175)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 55177) {
            if (e === 55176)
              return n.CLUSTER_BREAK.LV;
          } else if (55177 <= e && e <= 55203)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 68097) {
          if (e < 65279) {
            if (e < 64286) {
              if (e < 55243) {
                if (55216 <= e && e <= 55238)
                  return n.CLUSTER_BREAK.V;
              } else if (55243 <= e && e <= 55291)
                return n.CLUSTER_BREAK.T;
            } else if (e < 65024) {
              if (e === 64286)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 65056) {
              if (65024 <= e && e <= 65039)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (65056 <= e && e <= 65071)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 66045) {
            if (e < 65438) {
              if (e === 65279)
                return n.CLUSTER_BREAK.CONTROL;
            } else if (e < 65520) {
              if (65438 <= e && e <= 65439)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (65520 <= e && e <= 65531)
              return n.CLUSTER_BREAK.CONTROL;
          } else if (e < 66272) {
            if (e === 66045)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 66422) {
            if (e === 66272)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (66422 <= e && e <= 66426)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 68325) {
          if (e < 68108) {
            if (e < 68101) {
              if (68097 <= e && e <= 68099)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (68101 <= e && e <= 68102)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 68152) {
            if (68108 <= e && e <= 68111)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 68159) {
            if (68152 <= e && e <= 68154)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 68159)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 69373) {
          if (e < 68900) {
            if (68325 <= e && e <= 68326)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69291) {
            if (68900 <= e && e <= 68903)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (69291 <= e && e <= 69292)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 69446) {
          if (69373 <= e && e <= 69375)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 69506) {
          if (69446 <= e && e <= 69456)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (69506 <= e && e <= 69509)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70016) {
        if (e < 69815) {
          if (e < 69747) {
            if (e < 69634) {
              if (e === 69632)
                return n.CLUSTER_BREAK.SPACINGMARK;
              if (e === 69633)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 69688) {
              if (e === 69634)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 69744) {
              if (69688 <= e && e <= 69702)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 69744)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69762) {
            if (e < 69759) {
              if (69747 <= e && e <= 69748)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (69759 <= e && e <= 69761)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69808) {
            if (e === 69762)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 69811) {
            if (69808 <= e && e <= 69810)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (69811 <= e && e <= 69814)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 69888)
          if (e < 69821) {
            if (e < 69817) {
              if (69815 <= e && e <= 69816)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (69817 <= e && e <= 69818)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69826) {
            if (e === 69821)
              return n.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 69826)
              return n.CLUSTER_BREAK.EXTEND;
            if (e === 69837)
              return n.CLUSTER_BREAK.PREPEND;
          }
        else if (e < 69933) {
          if (e < 69927) {
            if (69888 <= e && e <= 69890)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69932) {
            if (69927 <= e && e <= 69931)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 69932)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 69957) {
          if (69933 <= e && e <= 69940)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 70003) {
          if (69957 <= e && e <= 69958)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e === 70003)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70194) {
        if (e < 70082) {
          if (e < 70067) {
            if (e < 70018) {
              if (70016 <= e && e <= 70017)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 70018)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70070) {
            if (70067 <= e && e <= 70069)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70079) {
            if (70070 <= e && e <= 70078)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (70079 <= e && e <= 70080)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70095) {
          if (e < 70089) {
            if (70082 <= e && e <= 70083)
              return n.CLUSTER_BREAK.PREPEND;
          } else if (e < 70094) {
            if (70089 <= e && e <= 70092)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 70094)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70188) {
          if (e === 70095)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 70191) {
          if (70188 <= e && e <= 70190)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (70191 <= e && e <= 70193)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70209) {
        if (e < 70197) {
          if (e < 70196) {
            if (70194 <= e && e <= 70195)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 70196)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 70198) {
          if (e === 70197)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70206) {
          if (70198 <= e && e <= 70199)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e === 70206)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70371) {
        if (e < 70367) {
          if (e === 70209)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 70368) {
          if (e === 70367)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (70368 <= e && e <= 70370)
          return n.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 70400) {
        if (70371 <= e && e <= 70378)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70402) {
        if (70400 <= e && e <= 70401)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (70402 <= e && e <= 70403)
        return n.CLUSTER_BREAK.SPACINGMARK;
    } else if (e < 72343) {
      if (e < 71339) {
        if (e < 70841) {
          if (e < 70512) {
            if (e < 70471) {
              if (e < 70463) {
                if (e < 70462) {
                  if (70459 <= e && e <= 70460)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 70462)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 70464) {
                if (e === 70463)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70465) {
                if (e === 70464)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (70465 <= e && e <= 70468)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70487) {
              if (e < 70475) {
                if (70471 <= e && e <= 70472)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (70475 <= e && e <= 70477)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70498) {
              if (e === 70487)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 70502) {
              if (70498 <= e && e <= 70499)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (70502 <= e && e <= 70508)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 70725) {
            if (e < 70712) {
              if (e < 70709) {
                if (70512 <= e && e <= 70516)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (70709 <= e && e <= 70711)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70720) {
              if (70712 <= e && e <= 70719)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 70722) {
              if (70720 <= e && e <= 70721)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (70722 <= e && e <= 70724)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 70832) {
            if (e < 70726) {
              if (e === 70725)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 70726 || e === 70750)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 70833) {
            if (e === 70832)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 70835) {
            if (70833 <= e && e <= 70834)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (70835 <= e && e <= 70840)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71096) {
          if (e < 70847)
            if (e < 70843) {
              if (e === 70841)
                return n.CLUSTER_BREAK.SPACINGMARK;
              if (e === 70842)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 70845) {
              if (70843 <= e && e <= 70844)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else {
              if (e === 70845)
                return n.CLUSTER_BREAK.EXTEND;
              if (e === 70846)
                return n.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 71087) {
            if (e < 70849) {
              if (70847 <= e && e <= 70848)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 70850) {
              if (e === 70849)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (70850 <= e && e <= 70851)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71088) {
            if (e === 71087)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71090) {
            if (71088 <= e && e <= 71089)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (71090 <= e && e <= 71093)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71216) {
          if (e < 71102) {
            if (e < 71100) {
              if (71096 <= e && e <= 71099)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (71100 <= e && e <= 71101)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71103) {
            if (e === 71102)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71132) {
            if (71103 <= e && e <= 71104)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (71132 <= e && e <= 71133)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71229) {
          if (e < 71219) {
            if (71216 <= e && e <= 71218)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71227) {
            if (71219 <= e && e <= 71226)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (71227 <= e && e <= 71228)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71230) {
          if (e === 71229)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71231) {
          if (e === 71230)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (71231 <= e && e <= 71232)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 71999)
        if (e < 71463) {
          if (e < 71350) {
            if (e < 71341) {
              if (e === 71339)
                return n.CLUSTER_BREAK.EXTEND;
              if (e === 71340)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71342) {
              if (e === 71341)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 71344) {
              if (71342 <= e && e <= 71343)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (71344 <= e && e <= 71349)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71453) {
            if (e === 71350)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 71351)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71458) {
            if (71453 <= e && e <= 71455)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71462) {
            if (71458 <= e && e <= 71461)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 71462)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71984) {
          if (e < 71727) {
            if (e < 71724) {
              if (71463 <= e && e <= 71467)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (71724 <= e && e <= 71726)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71736) {
            if (71727 <= e && e <= 71735)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71737) {
            if (e === 71736)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (71737 <= e && e <= 71738)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71995) {
          if (e < 71985) {
            if (e === 71984)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71991) {
            if (71985 <= e && e <= 71989)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (71991 <= e && e <= 71992)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71997) {
          if (71995 <= e && e <= 71996)
            return n.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 71997)
            return n.CLUSTER_BREAK.SPACINGMARK;
          if (e === 71998)
            return n.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 72193)
        if (e < 72145)
          if (e < 72001) {
            if (e === 71999)
              return n.CLUSTER_BREAK.PREPEND;
            if (e === 72e3)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72002) {
            if (e === 72001)
              return n.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 72002)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72003)
              return n.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 72156) {
          if (e < 72148) {
            if (72145 <= e && e <= 72147)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72154) {
            if (72148 <= e && e <= 72151)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (72154 <= e && e <= 72155)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 72160) {
          if (72156 <= e && e <= 72159)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else {
          if (e === 72160)
            return n.CLUSTER_BREAK.EXTEND;
          if (e === 72164)
            return n.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 72263) {
        if (e < 72249) {
          if (e < 72243) {
            if (72193 <= e && e <= 72202)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (72243 <= e && e <= 72248)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 72250) {
          if (e === 72249)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 72251) {
          if (e === 72250)
            return n.CLUSTER_BREAK.PREPEND;
        } else if (72251 <= e && e <= 72254)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 72281) {
        if (e < 72273) {
          if (e === 72263)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 72279) {
          if (72273 <= e && e <= 72278)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (72279 <= e && e <= 72280)
          return n.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 72324) {
        if (72281 <= e && e <= 72283)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 72330) {
        if (72324 <= e && e <= 72329)
          return n.CLUSTER_BREAK.PREPEND;
      } else if (72330 <= e && e <= 72342)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 94033) {
      if (e < 73104) {
        if (e < 72881) {
          if (e < 72766) {
            if (e < 72751) {
              if (e < 72344) {
                if (e === 72343)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (72344 <= e && e <= 72345)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 72752) {
              if (e === 72751)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72760) {
              if (72752 <= e && e <= 72758)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (72760 <= e && e <= 72765)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 72850) {
            if (e === 72766)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72767)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 72873) {
            if (72850 <= e && e <= 72871)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 72874) {
            if (e === 72873)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (72874 <= e && e <= 72880)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 73018) {
          if (e < 72884) {
            if (e < 72882) {
              if (e === 72881)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (72882 <= e && e <= 72883)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 72885) {
            if (e === 72884)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73009) {
            if (72885 <= e && e <= 72886)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (73009 <= e && e <= 73014)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 73030) {
          if (e < 73020) {
            if (e === 73018)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 73023) {
            if (73020 <= e && e <= 73021)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (73023 <= e && e <= 73029)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 73031) {
          if (e === 73030)
            return n.CLUSTER_BREAK.PREPEND;
        } else if (e < 73098) {
          if (e === 73031)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (73098 <= e && e <= 73102)
          return n.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 73526) {
        if (e < 73459)
          if (e < 73109) {
            if (e < 73107) {
              if (73104 <= e && e <= 73105)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (73107 <= e && e <= 73108)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73110) {
            if (e === 73109)
              return n.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 73110)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 73111)
              return n.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 73474) {
          if (e < 73461) {
            if (73459 <= e && e <= 73460)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 73472) {
            if (73461 <= e && e <= 73462)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (73472 <= e && e <= 73473)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 73475) {
          if (e === 73474)
            return n.CLUSTER_BREAK.PREPEND;
        } else if (e < 73524) {
          if (e === 73475)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (73524 <= e && e <= 73525)
          return n.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 78896)
        if (e < 73536) {
          if (e < 73534) {
            if (73526 <= e && e <= 73530)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (73534 <= e && e <= 73535)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 73537) {
          if (e === 73536)
            return n.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 73537)
            return n.CLUSTER_BREAK.SPACINGMARK;
          if (e === 73538)
            return n.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 92912) {
        if (e < 78912) {
          if (78896 <= e && e <= 78911)
            return n.CLUSTER_BREAK.CONTROL;
        } else if (e < 78919) {
          if (e === 78912)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (78919 <= e && e <= 78933)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 92976) {
        if (92912 <= e && e <= 92916)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 94031) {
        if (92976 <= e && e <= 92982)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e === 94031)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 121476) {
      if (e < 119143)
        if (e < 113824) {
          if (e < 94180) {
            if (e < 94095) {
              if (94033 <= e && e <= 94087)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (94095 <= e && e <= 94098)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 94192) {
            if (e === 94180)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 113821) {
            if (94192 <= e && e <= 94193)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (113821 <= e && e <= 113822)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 118576) {
          if (e < 118528) {
            if (113824 <= e && e <= 113827)
              return n.CLUSTER_BREAK.CONTROL;
          } else if (118528 <= e && e <= 118573)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 119141) {
          if (118576 <= e && e <= 118598)
            return n.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 119141)
            return n.CLUSTER_BREAK.EXTEND;
          if (e === 119142)
            return n.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 119173) {
        if (e < 119150) {
          if (e < 119149) {
            if (119143 <= e && e <= 119145)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 119149)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 119155) {
          if (119150 <= e && e <= 119154)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 119163) {
          if (119155 <= e && e <= 119162)
            return n.CLUSTER_BREAK.CONTROL;
        } else if (119163 <= e && e <= 119170)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 121344) {
        if (e < 119210) {
          if (119173 <= e && e <= 119179)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 119362) {
          if (119210 <= e && e <= 119213)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (119362 <= e && e <= 119364)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 121403) {
        if (121344 <= e && e <= 121398)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 121461) {
        if (121403 <= e && e <= 121452)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e === 121461)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 123628) {
      if (e < 122907) {
        if (e < 121505) {
          if (e < 121499) {
            if (e === 121476)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (121499 <= e && e <= 121503)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 122880) {
          if (121505 <= e && e <= 121519)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 122888) {
          if (122880 <= e && e <= 122886)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (122888 <= e && e <= 122904)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 123023) {
        if (e < 122915) {
          if (122907 <= e && e <= 122913)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 122918) {
          if (122915 <= e && e <= 122916)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (122918 <= e && e <= 122922)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 123184) {
        if (e === 123023)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 123566) {
        if (123184 <= e && e <= 123190)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e === 123566)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 127995) {
      if (e < 125136) {
        if (e < 124140) {
          if (123628 <= e && e <= 123631)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (124140 <= e && e <= 124143)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 125252) {
        if (125136 <= e && e <= 125142)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 127462) {
        if (125252 <= e && e <= 125258)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (127462 <= e && e <= 127487)
        return n.CLUSTER_BREAK.REGIONAL_INDICATOR;
    } else if (e < 917632) {
      if (e < 917504) {
        if (127995 <= e && e <= 127999)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 917536) {
        if (917504 <= e && e <= 917535)
          return n.CLUSTER_BREAK.CONTROL;
      } else if (917536 <= e && e <= 917631)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 917760) {
      if (917632 <= e && e <= 917759)
        return n.CLUSTER_BREAK.CONTROL;
    } else if (e < 918e3) {
      if (917760 <= e && e <= 917999)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (918e3 <= e && e <= 921599)
      return n.CLUSTER_BREAK.CONTROL;
    return n.CLUSTER_BREAK.OTHER;
  }
  /**
   * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getEmojiProperty(e) {
    if (e < 10160) {
      if (e < 9728) {
        if (e < 9e3) {
          if (e < 8482) {
            if (e < 8252) {
              if (e === 169 || e === 174)
                return n.EXTENDED_PICTOGRAPHIC;
            } else if (e === 8252 || e === 8265)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8596) {
            if (e === 8482 || e === 8505)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8617) {
            if (8596 <= e && e <= 8601)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8986) {
            if (8617 <= e && e <= 8618)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (8986 <= e && e <= 8987)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9410) {
          if (e < 9167) {
            if (e === 9e3 || e === 9096)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9193) {
            if (e === 9167)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9208) {
            if (9193 <= e && e <= 9203)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (9208 <= e && e <= 9210)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9654) {
          if (e < 9642) {
            if (e === 9410)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (9642 <= e && e <= 9643)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9664) {
          if (e === 9654)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9723) {
          if (e === 9664)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (9723 <= e && e <= 9726)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10035) {
        if (e < 10004) {
          if (e < 9748) {
            if (e < 9735) {
              if (9728 <= e && e <= 9733)
                return n.EXTENDED_PICTOGRAPHIC;
            } else if (9735 <= e && e <= 9746)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9872) {
            if (9748 <= e && e <= 9861)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9992) {
            if (9872 <= e && e <= 9989)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (9992 <= e && e <= 10002)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10013) {
          if (e === 10004 || e === 10006)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10017) {
          if (e === 10013)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10017 || e === 10024)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10067) {
        if (e < 10055) {
          if (e < 10052) {
            if (10035 <= e && e <= 10036)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10052)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10060) {
          if (e === 10055)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10060 || e === 10062)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10083) {
        if (e < 10071) {
          if (10067 <= e && e <= 10069)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10071)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10133) {
        if (10083 <= e && e <= 10087)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10145) {
        if (10133 <= e && e <= 10135)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e === 10145)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 127489) {
      if (e < 12951) {
        if (e < 11035) {
          if (e < 10548) {
            if (e === 10160 || e === 10175)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 11013) {
            if (10548 <= e && e <= 10549)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (11013 <= e && e <= 11015)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 11093) {
          if (e < 11088) {
            if (11035 <= e && e <= 11036)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e === 11088)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 12336) {
          if (e === 11093)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 12336 || e === 12349)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127340) {
        if (e < 126976) {
          if (e === 12951 || e === 12953)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127245) {
          if (126976 <= e && e <= 127231)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127279) {
          if (127245 <= e && e <= 127247)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 127279)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127374) {
        if (e < 127358) {
          if (127340 <= e && e <= 127345)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (127358 <= e && e <= 127359)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127377) {
        if (e === 127374)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127405) {
        if (127377 <= e && e <= 127386)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (127405 <= e && e <= 127461)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 128981) {
      if (e < 127561) {
        if (e < 127535) {
          if (e < 127514) {
            if (127489 <= e && e <= 127503)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e === 127514)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127538) {
          if (e === 127535)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127548) {
          if (127538 <= e && e <= 127546)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (127548 <= e && e <= 127551)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128326) {
        if (e < 128e3) {
          if (127561 <= e && e <= 127994)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (128e3 <= e && e <= 128317)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128640) {
        if (128326 <= e && e <= 128591)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128884) {
        if (128640 <= e && e <= 128767)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (128884 <= e && e <= 128895)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129198) {
      if (e < 129096) {
        if (e < 129036) {
          if (128981 <= e && e <= 129023)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (129036 <= e && e <= 129039)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129114) {
        if (129096 <= e && e <= 129103)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129160) {
        if (129114 <= e && e <= 129119)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (129160 <= e && e <= 129167)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129340) {
      if (e < 129292) {
        if (129198 <= e && e <= 129279)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (129292 <= e && e <= 129338)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129351) {
      if (129340 <= e && e <= 129349)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 130048) {
      if (129351 <= e && e <= 129791)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (130048 <= e && e <= 131069)
      return n.EXTENDED_PICTOGRAPHIC;
    return n.CLUSTER_BREAK.OTHER;
  }
}
jc.default = Pi;
var IE = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Vc, "__esModule", { value: !0 });
const UE = IE(jc);
Vc.default = UE.default;
var OE = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), KE = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), ME = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && OE(e, t, r);
  return KE(e, t), e;
}, NE = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(yr, "__esModule", { value: !0 });
yr.validateLanguage = yr.parseLanguage = yr.b64UrlToUtf8 = yr.utf8ToB64Url = yr.graphemeLen = yr.utf8Len = void 0;
const VE = NE(Vc), Eu = ME(Rp), jE = (t) => new TextEncoder().encode(t).byteLength;
yr.utf8Len = jE;
const FE = (t) => new VE.default().countGraphemes(t);
yr.graphemeLen = FE;
const $E = (t) => Eu.toString(Eu.fromString(t, "utf8"), "base64url");
yr.utf8ToB64Url = $E;
const GE = (t) => Eu.toString(Eu.fromString(t, "base64url"), "utf8");
yr.b64UrlToUtf8 = GE;
const qE = (t) => {
  const e = t.match(Sp);
  if (!e?.groups)
    return null;
  const r = e.groups;
  return {
    grandfathered: r.grandfathered,
    language: r.language,
    extlang: r.extlang,
    script: r.script,
    region: r.region,
    variant: r.variant,
    extension: r.extension,
    privateUse: r.privateUseA || r.privateUseB
  };
};
yr.parseLanguage = qE;
const zE = (t) => Sp.test(t);
yr.validateLanguage = zE;
const Sp = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
var Lp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.didDocument = t.getServiceEndpoint = t.getNotifEndpoint = t.getFeedGenEndpoint = t.getPdsEndpoint = t.getSigningDidKey = t.getVerificationMaterial = t.getSigningKey = t.getHandle = t.getDid = t.isValidDidDoc = void 0;
  const e = os, r = (H) => t.didDocument.safeParse(H).success;
  t.isValidDidDoc = r;
  const i = (H) => {
    const V = H.id;
    if (typeof V != "string")
      throw new Error("No `id` on document");
    return V;
  };
  t.getDid = i;
  const a = (H) => {
    const V = H.alsoKnownAs;
    if (V)
      for (let G = 0; G < V.length; G++) {
        const Z = V[G];
        if (Z.startsWith("at://"))
          return Z.slice(5);
      }
  };
  t.getHandle = a;
  const c = (H) => (0, t.getVerificationMaterial)(H, "atproto");
  t.getSigningKey = c;
  const h = (H, V) => {
    const G = B(H, "verificationMethod", `#${V}`);
    if (G && G.publicKeyMultibase)
      return {
        type: G.type,
        publicKeyMultibase: G.publicKeyMultibase
      };
  };
  t.getVerificationMaterial = h;
  const m = (H) => {
    const V = (0, t.getSigningKey)(H);
    if (V)
      return `did:key:${V.publicKeyMultibase}`;
  };
  t.getSigningDidKey = m;
  const p = (H) => (0, t.getServiceEndpoint)(H, {
    id: "#atproto_pds",
    type: "AtprotoPersonalDataServer"
  });
  t.getPdsEndpoint = p;
  const y = (H) => (0, t.getServiceEndpoint)(H, {
    id: "#bsky_fg",
    type: "BskyFeedGenerator"
  });
  t.getFeedGenEndpoint = y;
  const d = (H) => (0, t.getServiceEndpoint)(H, {
    id: "#bsky_notif",
    type: "BskyNotificationService"
  });
  t.getNotifEndpoint = d;
  const A = (H, V) => {
    const G = B(H, "service", V.id);
    if (G && !(V.type && G.type !== V.type) && typeof G.serviceEndpoint == "string")
      return K(G.serviceEndpoint);
  };
  t.getServiceEndpoint = A;
  function B(H, V, G) {
    const Z = H[V];
    if (Z)
      for (let ae = 0; ae < Z.length; ae++) {
        const se = Z[ae], be = se.id;
        if (be[0] === "#" ? be === G : (
          // Optimized version of: itemId === `${doc.id}${id}`
          be.length === H.id.length + G.length && be[H.id.length] === "#" && be.endsWith(G) && be.startsWith(H.id)
        ))
          return se;
      }
  }
  const K = (H) => {
    if (!(!H.startsWith("http://") && !H.startsWith("https://")) && O(H))
      return H;
  }, O = URL.canParse ?? // URL.canParse is not available in Node.js < 18.17.0
  ((H) => {
    try {
      return new URL(H), !0;
    } catch {
      return !1;
    }
  }), z = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    controller: e.z.string(),
    publicKeyMultibase: e.z.string().optional()
  }), X = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    serviceEndpoint: e.z.union([e.z.string(), e.z.record(e.z.unknown())])
  });
  t.didDocument = e.z.object({
    id: e.z.string(),
    alsoKnownAs: e.z.array(e.z.string()).optional(),
    verificationMethod: e.z.array(z).optional(),
    service: e.z.array(X).optional()
  });
})(Lp);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(c, h, m, p) {
    p === void 0 && (p = m);
    var y = Object.getOwnPropertyDescriptor(h, m);
    (!y || ("get" in y ? !h.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return h[m];
    } }), Object.defineProperty(c, p, y);
  } : function(c, h, m, p) {
    p === void 0 && (p = m), c[p] = h[m];
  }), r = ne && ne.__setModuleDefault || (Object.create ? function(c, h) {
    Object.defineProperty(c, "default", { enumerable: !0, value: h });
  } : function(c, h) {
    c.default = h;
  }), i = ne && ne.__importStar || function(c) {
    if (c && c.__esModule) return c;
    var h = {};
    if (c != null) for (var m in c) m !== "default" && Object.prototype.hasOwnProperty.call(c, m) && e(h, c, m);
    return r(h, c), h;
  }, a = ne && ne.__exportStar || function(c, h) {
    for (var m in c) m !== "default" && !Object.prototype.hasOwnProperty.call(h, m) && e(h, c, m);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.util = t.check = void 0, t.check = i(ri), t.util = i(As), a(_s, t), a(mp, t), a(As, t), a(Ca, t), a(yp, t), a(La, t), a(wp, t), a(Tp, t), a(yr, t), a(Lp, t);
})(vi);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.BlobRef = t.jsonBlobRef = t.untypedJsonBlobRef = t.typedJsonBlobRef = void 0;
  const e = vi, r = Fs, i = os;
  t.typedJsonBlobRef = i.z.object({
    $type: i.z.literal("blob"),
    ref: e.schema.cid,
    mimeType: i.z.string(),
    size: i.z.number()
  }).strict(), t.untypedJsonBlobRef = i.z.object({
    cid: i.z.string(),
    mimeType: i.z.string()
  }).strict(), t.jsonBlobRef = i.z.union([t.typedJsonBlobRef, t.untypedJsonBlobRef]);
  class a {
    constructor(h, m, p, y) {
      Object.defineProperty(this, "ref", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "mimeType", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      }), Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "original", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.original = y ?? {
        $type: "blob",
        ref: h,
        mimeType: m,
        size: p
      };
    }
    static asBlobRef(h) {
      return e.check.is(h, t.jsonBlobRef) ? a.fromJsonRef(h) : null;
    }
    static fromJsonRef(h) {
      return e.check.is(h, t.typedJsonBlobRef) ? new a(h.ref, h.mimeType, h.size) : new a(r.CID.parse(h.cid), h.mimeType, -1, h);
    }
    ipld() {
      return {
        $type: "blob",
        ref: this.ref,
        mimeType: this.mimeType,
        size: this.size
      };
    }
    toJSON() {
      return (0, e.ipldToJson)(this.ipld());
    }
  }
  t.BlobRef = a;
})(Iu);
Object.defineProperty(Kc, "__esModule", { value: !0 });
Kc.blob = ZE;
const XE = Iu, HE = Rn;
function ZE(t, e, r, i) {
  return !i || !(i instanceof XE.BlobRef) ? {
    success: !1,
    error: new HE.ValidationError(`${e} should be a blob ref`)
  } : { success: !0, value: i };
}
var Ri = {}, Lr = {}, kp = {};
(function(t) {
  (() => {
    var e = { d: (d, A) => {
      for (var B in A) e.o(A, B) && !e.o(d, B) && Object.defineProperty(d, B, { enumerable: !0, get: A[B] });
    }, o: (d, A) => Object.prototype.hasOwnProperty.call(d, A), r: (d) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(d, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(d, "__esModule", { value: !0 });
    } }, r = {};
    function i(d, A) {
      return A === void 0 && (A = "-"), new RegExp("^(?!0{4}" + A + "0{2}" + A + "0{2})((?=[0-9]{4}" + A + "(((0[^2])|1[0-2])|02(?=" + A + "(([0-1][0-9])|2[0-8])))" + A + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + A + "02" + A + "29))([0-9]{4})" + A + "(?!((0[469])|11)" + A + "31)((0[1,3-9]|1[0-2])|(02(?!" + A + "3)))" + A + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(d);
    }
    function a(d) {
      var A = /\D/.exec(d);
      return A ? A[0] : "";
    }
    function c(d, A, B) {
      A === void 0 && (A = ":"), B === void 0 && (B = !1);
      var K = new RegExp("^([0-1]|2(?=([0-3])|4" + A + "00))[0-9]" + A + "[0-5][0-9](" + A + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
      if (!B || !/[Z+\-]/.test(d)) return K.test(d);
      if (/Z$/.test(d)) return K.test(d.replace("Z", ""));
      var O = d.includes("+"), z = d.split(/[+-]/), X = z[0], H = z[1];
      return K.test(X) && function(V, G, Z) {
        return Z === void 0 && (Z = ":"), new RegExp(G ? "^(0(?!(2" + Z + "4)|0" + Z + "3)|1(?=([0-1]|2(?=" + Z + "[04])|[34](?=" + Z + "0))))([03469](?=" + Z + "[03])|[17](?=" + Z + "0)|2(?=" + Z + "[04])|5(?=" + Z + "[034])|8(?=" + Z + "[04]))" + Z + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + Z + "[03])|[0-24-8](?=" + Z + "00))" + Z + "[03]0$").test(V);
      }(H, O, a(H));
    }
    function h(d) {
      var A = d.split("T"), B = A[0], K = A[1], O = i(B, a(B));
      if (!K) return !1;
      var z, X = (z = K.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(z) ? z[0] : "");
      return O && c(K, X, !0);
    }
    function m(d, A) {
      return A === void 0 && (A = "-"), new RegExp("^[0-9]{4}" + A + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(d);
    }
    e.r(r), e.d(r, { isValidDate: () => i, isValidISODateString: () => h, isValidTime: () => c, isValidYearMonth: () => m });
    var p = t;
    for (var y in r) p[y] = r[y];
    r.__esModule && Object.defineProperty(p, "__esModule", { value: !0 });
  })();
})(kp);
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.datetime = QE;
Lr.uri = ev;
Lr.atUri = tv;
Lr.did = Dp;
Lr.handle = Pp;
Lr.atIdentifier = rv;
Lr.nsid = iv;
Lr.cid = nv;
Lr.language = sv;
Lr.tid = av;
Lr.recordKey = ov;
const WE = kp, YE = Fs, Xr = Rn, $s = as, JE = vi;
function QE(t, e) {
  try {
    if (!(0, WE.isValidISODateString)(e))
      throw new Error();
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
    };
  }
  return { success: !0, value: e };
}
function ev(t, e) {
  return e.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null ? { success: !0, value: e } : {
    success: !1,
    error: new Xr.ValidationError(`${t} must be a uri`)
  };
}
function tv(t, e) {
  try {
    (0, $s.ensureValidAtUri)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid at-uri`)
    };
  }
  return { success: !0, value: e };
}
function Dp(t, e) {
  try {
    (0, $s.ensureValidDid)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid did`)
    };
  }
  return { success: !0, value: e };
}
function Pp(t, e) {
  try {
    (0, $s.ensureValidHandle)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid handle`)
    };
  }
  return { success: !0, value: e };
}
function rv(t, e) {
  if (e.startsWith("did:")) {
    const r = Dp(t, e);
    if (r.success)
      return r;
  } else {
    const r = Pp(t, e);
    if (r.success)
      return r;
  }
  return {
    success: !1,
    error: new Xr.ValidationError(`${t} must be a valid did or a handle`)
  };
}
function iv(t, e) {
  try {
    (0, $s.ensureValidNsid)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid nsid`)
    };
  }
  return { success: !0, value: e };
}
function nv(t, e) {
  try {
    YE.CID.parse(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a cid string`)
    };
  }
  return { success: !0, value: e };
}
function sv(t, e) {
  return (0, JE.validateLanguage)(e) ? { success: !0, value: e } : {
    success: !1,
    error: new Xr.ValidationError(`${t} must be a well-formed BCP 47 language tag`)
  };
}
function av(t, e) {
  try {
    (0, $s.ensureValidTid)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid TID (timestamp identifier)`)
    };
  }
  return { success: !0, value: e };
}
function ov(t, e) {
  try {
    (0, $s.ensureValidRecordKey)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid Record Key`)
    };
  }
  return { success: !0, value: e };
}
var lv = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), uv = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), cv = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && lv(e, t, r);
  return uv(e, t), e;
};
Object.defineProperty(Ri, "__esModule", { value: !0 });
Ri.validate = fv;
Ri.boolean = Bp;
Ri.integer = Ip;
Ri.string = Up;
Ri.bytes = Op;
Ri.cidLink = Kp;
Ri.unknown = Mp;
const Kd = vi, dv = Fs, Or = cv(Lr), st = Rn;
function fv(t, e, r, i) {
  switch (r.type) {
    case "boolean":
      return Bp(t, e, r, i);
    case "integer":
      return Ip(t, e, r, i);
    case "string":
      return Up(t, e, r, i);
    case "bytes":
      return Op(t, e, r, i);
    case "cid-link":
      return Kp(t, e, r, i);
    case "unknown":
      return Mp(t, e, r, i);
    default:
      return {
        success: !1,
        error: new st.ValidationError(`Unexpected lexicon type: ${r.type}`)
      };
  }
}
function Bp(t, e, r, i) {
  r = r;
  const a = typeof i;
  return a === "undefined" ? typeof r.default == "boolean" ? { success: !0, value: r.default } : {
    success: !1,
    error: new st.ValidationError(`${e} must be a boolean`)
  } : a !== "boolean" ? {
    success: !1,
    error: new st.ValidationError(`${e} must be a boolean`)
  } : typeof r.const == "boolean" && i !== r.const ? {
    success: !1,
    error: new st.ValidationError(`${e} must be ${r.const}`)
  } : { success: !0, value: i };
}
function Ip(t, e, r, i) {
  return r = r, typeof i === "undefined" ? typeof r.default == "number" ? { success: !0, value: r.default } : {
    success: !1,
    error: new st.ValidationError(`${e} must be an integer`)
  } : Number.isInteger(i) ? typeof r.const == "number" && i !== r.const ? {
    success: !1,
    error: new st.ValidationError(`${e} must be ${r.const}`)
  } : Array.isArray(r.enum) && !r.enum.includes(i) ? {
    success: !1,
    error: new st.ValidationError(`${e} must be one of (${r.enum.join("|")})`)
  } : typeof r.maximum == "number" && i > r.maximum ? {
    success: !1,
    error: new st.ValidationError(`${e} can not be greater than ${r.maximum}`)
  } : typeof r.minimum == "number" && i < r.minimum ? {
    success: !1,
    error: new st.ValidationError(`${e} can not be less than ${r.minimum}`)
  } : { success: !0, value: i } : {
    success: !1,
    error: new st.ValidationError(`${e} must be an integer`)
  };
}
function Up(t, e, r, i) {
  if (r = r, typeof i > "u")
    return typeof r.default == "string" ? { success: !0, value: r.default } : {
      success: !1,
      error: new st.ValidationError(`${e} must be a string`)
    };
  if (typeof i != "string")
    return {
      success: !1,
      error: new st.ValidationError(`${e} must be a string`)
    };
  if (typeof r.const == "string" && i !== r.const)
    return {
      success: !1,
      error: new st.ValidationError(`${e} must be ${r.const}`)
    };
  if (Array.isArray(r.enum) && !r.enum.includes(i))
    return {
      success: !1,
      error: new st.ValidationError(`${e} must be one of (${r.enum.join("|")})`)
    };
  if (typeof r.minLength == "number" || typeof r.maxLength == "number") {
    if (typeof r.minLength == "number" && i.length * 3 < r.minLength)
      return {
        success: !1,
        error: new st.ValidationError(`${e} must not be shorter than ${r.minLength} characters`)
      };
    let a = !1;
    if (typeof r.minLength > "u" && typeof r.maxLength == "number" && i.length * 3 <= r.maxLength && (a = !0), !a) {
      const c = (0, Kd.utf8Len)(i);
      if (typeof r.maxLength == "number" && c > r.maxLength)
        return {
          success: !1,
          error: new st.ValidationError(`${e} must not be longer than ${r.maxLength} characters`)
        };
      if (typeof r.minLength == "number" && c < r.minLength)
        return {
          success: !1,
          error: new st.ValidationError(`${e} must not be shorter than ${r.minLength} characters`)
        };
    }
  }
  if (typeof r.maxGraphemes == "number" || typeof r.minGraphemes == "number") {
    let a = !1, c = !1;
    if (typeof r.maxGraphemes == "number" && (i.length <= r.maxGraphemes ? a = !1 : a = !0), typeof r.minGraphemes == "number") {
      if (i.length < r.minGraphemes)
        return {
          success: !1,
          error: new st.ValidationError(`${e} must not be shorter than ${r.minGraphemes} graphemes`)
        };
      c = !0;
    }
    if (a || c) {
      const h = (0, Kd.graphemeLen)(i);
      if (typeof r.maxGraphemes == "number" && h > r.maxGraphemes)
        return {
          success: !1,
          error: new st.ValidationError(`${e} must not be longer than ${r.maxGraphemes} graphemes`)
        };
      if (typeof r.minGraphemes == "number" && h < r.minGraphemes)
        return {
          success: !1,
          error: new st.ValidationError(`${e} must not be shorter than ${r.minGraphemes} graphemes`)
        };
    }
  }
  if (typeof r.format == "string")
    switch (r.format) {
      case "datetime":
        return Or.datetime(e, i);
      case "uri":
        return Or.uri(e, i);
      case "at-uri":
        return Or.atUri(e, i);
      case "did":
        return Or.did(e, i);
      case "handle":
        return Or.handle(e, i);
      case "at-identifier":
        return Or.atIdentifier(e, i);
      case "nsid":
        return Or.nsid(e, i);
      case "cid":
        return Or.cid(e, i);
      case "language":
        return Or.language(e, i);
      case "tid":
        return Or.tid(e, i);
      case "record-key":
        return Or.recordKey(e, i);
    }
  return { success: !0, value: i };
}
function Op(t, e, r, i) {
  return r = r, !i || !(i instanceof Uint8Array) ? {
    success: !1,
    error: new st.ValidationError(`${e} must be a byte array`)
  } : typeof r.maxLength == "number" && i.byteLength > r.maxLength ? {
    success: !1,
    error: new st.ValidationError(`${e} must not be larger than ${r.maxLength} bytes`)
  } : typeof r.minLength == "number" && i.byteLength < r.minLength ? {
    success: !1,
    error: new st.ValidationError(`${e} must not be smaller than ${r.minLength} bytes`)
  } : { success: !0, value: i };
}
function Kp(t, e, r, i) {
  return dv.CID.asCID(i) === null ? {
    success: !1,
    error: new st.ValidationError(`${e} must be a CID`)
  } : { success: !0, value: i };
}
function Mp(t, e, r, i) {
  return !i || typeof i != "object" ? {
    success: !1,
    error: new st.ValidationError(`${e} must be an object`)
  } : { success: !0, value: i };
}
Object.defineProperty(An, "__esModule", { value: !0 });
An.validate = Np;
An.array = Vp;
An.object = qc;
An.validateOneOf = zc;
const ii = Rn, Sc = ls, pv = Kc, hs = Ri;
function Np(t, e, r, i) {
  switch (r.type) {
    case "boolean":
      return (0, hs.boolean)(t, e, r, i);
    case "integer":
      return (0, hs.integer)(t, e, r, i);
    case "string":
      return (0, hs.string)(t, e, r, i);
    case "bytes":
      return (0, hs.bytes)(t, e, r, i);
    case "cid-link":
      return (0, hs.cidLink)(t, e, r, i);
    case "unknown":
      return (0, hs.unknown)(t, e, r, i);
    case "object":
      return qc(t, e, r, i);
    case "array":
      return Vp(t, e, r, i);
    case "blob":
      return (0, pv.blob)(t, e, r, i);
    default:
      return {
        success: !1,
        error: new ii.ValidationError(`Unexpected lexicon type: ${r.type}`)
      };
  }
}
function Vp(t, e, r, i) {
  if (!Array.isArray(i))
    return {
      success: !1,
      error: new ii.ValidationError(`${e} must be an array`)
    };
  if (typeof r.maxLength == "number" && i.length > r.maxLength)
    return {
      success: !1,
      error: new ii.ValidationError(`${e} must not have more than ${r.maxLength} elements`)
    };
  if (typeof r.minLength == "number" && i.length < r.minLength)
    return {
      success: !1,
      error: new ii.ValidationError(`${e} must not have fewer than ${r.minLength} elements`)
    };
  const a = r.items;
  for (let c = 0; c < i.length; c++) {
    const h = i[c], m = `${e}/${c}`, p = zc(t, m, a, h);
    if (!p.success)
      return p;
  }
  return { success: !0, value: i };
}
function qc(t, e, r, i) {
  if (r = r, !i || typeof i != "object")
    return {
      success: !1,
      error: new ii.ValidationError(`${e} must be an object`)
    };
  const a = new Set(r.required), c = new Set(r.nullable);
  let h = i;
  if (typeof r.properties == "object")
    for (const m in r.properties) {
      if (i[m] === null && c.has(m))
        continue;
      const p = r.properties[m];
      if (typeof i[m] > "u" && !a.has(m))
        if (p.type === "integer" || p.type === "boolean" || p.type === "string") {
          if (typeof p.default > "u")
            continue;
        } else
          continue;
      const y = `${e}/${m}`, d = zc(t, y, p, i[m]), A = d.success ? d.value : i[m], B = typeof A > "u";
      if (B && a.has(m))
        return {
          success: !1,
          error: new ii.ValidationError(`${e} must have the property "${m}"`)
        };
      if (!B && !d.success)
        return d;
      A !== i[m] && (h === i && (h = { ...i }), h[m] = A);
    }
  return { success: !0, value: h };
}
function zc(t, e, r, i, a = !1) {
  let c, h;
  if (r.type === "union") {
    if (!(0, ii.isDiscriminatedObject)(i))
      return {
        success: !1,
        error: new ii.ValidationError(`${e} must be an object which includes the "$type" property`)
      };
    if (hv(r.refs, i.$type))
      h = (0, Sc.toConcreteTypes)(t, {
        type: "ref",
        ref: i.$type
      });
    else
      return r.closed ? {
        success: !1,
        error: new ii.ValidationError(`${e} $type must be one of ${r.refs.join(", ")}`)
      } : { success: !0, value: i };
  } else
    h = (0, Sc.toConcreteTypes)(t, r);
  for (const m of h) {
    const p = a ? qc(t, e, m, i) : Np(t, e, m, i);
    if (p.success)
      return p;
    c ?? (c = p.error);
  }
  return h.length > 1 ? {
    success: !1,
    error: new ii.ValidationError(`${e} did not match any of the expected definitions`)
  } : { success: !1, error: c };
}
const hv = (t, e) => {
  const r = (0, Sc.toLexUri)(e);
  return t.includes(r) ? !0 : r.endsWith("#main") ? t.includes(r.replace("#main", "")) : t.includes(r + "#main");
};
var Xc = {}, mv = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), yv = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), bv = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && mv(e, t, r);
  return yv(e, t), e;
};
Object.defineProperty(Xc, "__esModule", { value: !0 });
Xc.params = vv;
const gv = Rn, xv = bv(Ri), Ev = An;
function vv(t, e, r, i) {
  const a = i && typeof i == "object" ? i : {}, c = new Set(r.required ?? []);
  let h = a;
  if (typeof r.properties == "object")
    for (const m in r.properties) {
      const p = r.properties[m], y = p.type === "array" ? (0, Ev.array)(t, m, p, a[m]) : xv.validate(t, m, p, a[m]), d = y.success ? y.value : a[m], A = typeof d > "u";
      if (A && c.has(m))
        return {
          success: !1,
          error: new gv.ValidationError(`${e} must have the property "${m}"`)
        };
      if (!A && !y.success)
        return y;
      d !== a[m] && (h === a && (h = { ...a }), h[m] = d);
    }
  return { success: !0, value: h };
}
Object.defineProperty(us, "__esModule", { value: !0 });
us.assertValidRecord = Av;
us.assertValidXrpcParams = _v;
us.assertValidXrpcInput = wv;
us.assertValidXrpcOutput = Tv;
us.assertValidXrpcMessage = Cv;
const jp = An, Rv = Xc;
function Av(t, e, r) {
  const i = (0, jp.object)(t, "Record", e.record, r);
  if (!i.success)
    throw i.error;
  return i.value;
}
function _v(t, e, r) {
  if (e.parameters) {
    const i = (0, Rv.params)(t, "Params", e.parameters, r);
    if (!i.success)
      throw i.error;
    return i.value;
  }
}
function wv(t, e, r) {
  if (e.input?.schema)
    return Hc(t, "Input", e.input.schema, r, !0);
}
function Tv(t, e, r) {
  if (e.output?.schema)
    return Hc(t, "Output", e.output.schema, r, !0);
}
function Cv(t, e, r) {
  if (e.message?.schema)
    return Hc(t, "Message", e.message.schema, r, !0);
}
function Hc(t, e, r, i, a = !1) {
  const c = (0, jp.validateOneOf)(t, e, r, i, a);
  if (!c.success)
    throw c.error;
  return c.value;
}
var Sv = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), Lv = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), kv = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Sv(e, t, r);
  return Lv(e, t), e;
};
Object.defineProperty(Bu, "__esModule", { value: !0 });
Bu.Lexicons = void 0;
const Jr = Rn, Qs = us, Wt = ls, Md = kv(An);
class Dv {
  constructor(e) {
    if (Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "defs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), e)
      for (const r of e)
        this.add(r);
  }
  /**
   * @example clone a lexicon:
   * ```ts
   * const clone = new Lexicons(originalLexicon)
   * ```
   *
   * @example get docs array:
   * ```ts
   * const docs = Array.from(lexicons)
   * ```
   */
  [Symbol.iterator]() {
    return this.docs.values();
  }
  /**
   * Add a lexicon doc.
   */
  add(e) {
    const r = (0, Wt.toLexUri)(e.id);
    if (this.docs.has(r))
      throw new Error(`${r} has already been registered`);
    Lc(e, r), this.docs.set(r, e);
    for (const [i, a] of Nd(e))
      this.defs.set(i, a);
  }
  /**
   * Remove a lexicon doc.
   */
  remove(e) {
    e = (0, Wt.toLexUri)(e);
    const r = this.docs.get(e);
    if (!r)
      throw new Error(`Unable to remove "${e}": does not exist`);
    for (const [i, a] of Nd(r))
      this.defs.delete(i);
    this.docs.delete(e);
  }
  /**
   * Get a lexicon doc.
   */
  get(e) {
    return e = (0, Wt.toLexUri)(e), this.docs.get(e);
  }
  /**
   * Get a definition.
   */
  getDef(e) {
    return e = (0, Wt.toLexUri)(e), this.defs.get(e);
  }
  getDefOrThrow(e, r) {
    const i = this.getDef(e);
    if (!i)
      throw new Jr.LexiconDefNotFoundError(`Lexicon not found: ${e}`);
    if (r && !r.includes(i.type))
      throw new Jr.InvalidLexiconError(`Not a ${r.join(" or ")} lexicon: ${e}`);
    return i;
  }
  /**
   * Validate a record or object.
   */
  validate(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["record", "object"]);
    if (!(0, Jr.isObj)(r))
      throw new Jr.ValidationError("Value must be an object");
    if (i.type === "record")
      return Md.object(this, "Record", i.record, r);
    if (i.type === "object")
      return Md.object(this, "Object", i, r);
    throw new Jr.InvalidLexiconError("Definition must be a record or object");
  }
  /**
   * Validate a record and throw on any error.
   */
  assertValidRecord(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["record"]);
    if (!(0, Jr.isObj)(r))
      throw new Jr.ValidationError("Record must be an object");
    if (!(0, Jr.hasProp)(r, "$type") || typeof r.$type != "string")
      throw new Jr.ValidationError("Record/$type must be a string");
    const a = r.$type || "";
    if ((0, Wt.toLexUri)(a) !== e)
      throw new Jr.ValidationError(`Invalid $type: must be ${e}, got ${a}`);
    return (0, Qs.assertValidRecord)(this, i, r);
  }
  /**
   * Validate xrpc query params and throw on any error.
   */
  assertValidXrpcParams(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, [
      "query",
      "procedure",
      "subscription"
    ]);
    return (0, Qs.assertValidXrpcParams)(this, i, r);
  }
  /**
   * Validate xrpc input body and throw on any error.
   */
  assertValidXrpcInput(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["procedure"]);
    return (0, Qs.assertValidXrpcInput)(this, i, r);
  }
  /**
   * Validate xrpc output body and throw on any error.
   */
  assertValidXrpcOutput(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["query", "procedure"]);
    return (0, Qs.assertValidXrpcOutput)(this, i, r);
  }
  /**
   * Validate xrpc subscription message and throw on any error.
   */
  assertValidXrpcMessage(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["subscription"]);
    return (0, Qs.assertValidXrpcMessage)(this, i, r);
  }
  /**
   * Resolve a lex uri given a ref
   */
  resolveLexUri(e, r) {
    return e = (0, Wt.toLexUri)(e), (0, Wt.toLexUri)(r, e);
  }
}
Bu.Lexicons = Dv;
function* Nd(t) {
  for (const e in t.defs)
    yield [`lex:${t.id}#${e}`, t.defs[e]], e === "main" && (yield [`lex:${t.id}`, t.defs[e]]);
}
function Lc(t, e) {
  for (const r in t)
    t.type === "ref" ? t.ref = (0, Wt.toLexUri)(t.ref, e) : t.type === "union" ? t.refs = t.refs.map((i) => (0, Wt.toLexUri)(i, e)) : Array.isArray(t[r]) ? t[r] = t[r].map((i) => typeof i == "string" ? i.startsWith("#") ? (0, Wt.toLexUri)(i, e) : i : i && typeof i == "object" ? Lc(i, e) : i) : t[r] && typeof t[r] == "object" && (t[r] = Lc(t[r], e));
  return t;
}
var Fp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.ipldToLex = t.lexToIpld = void 0;
  const e = vi, r = Fs, i = Iu, a = (d) => {
    if (Array.isArray(d))
      return d.map((A) => (0, t.lexToIpld)(A));
    if (d && typeof d == "object") {
      if (d instanceof i.BlobRef)
        return d.original;
      if (r.CID.asCID(d) || d instanceof Uint8Array)
        return d;
      const A = {};
      for (const B of Object.keys(d))
        A[B] = (0, t.lexToIpld)(d[B]);
      return A;
    }
    return d;
  };
  t.lexToIpld = a;
  const c = (d) => {
    if (Array.isArray(d))
      return d.map((A) => (0, t.ipldToLex)(A));
    if (d && typeof d == "object") {
      if ((d.$type === "blob" || typeof d.cid == "string" && typeof d.mimeType == "string") && e.check.is(d, i.jsonBlobRef))
        return i.BlobRef.fromJsonRef(d);
      if (r.CID.asCID(d) || d instanceof Uint8Array)
        return d;
      const A = {};
      for (const B of Object.keys(d))
        A[B] = (0, t.ipldToLex)(d[B]);
      return A;
    }
    return d;
  };
  t.ipldToLex = c;
  const h = (d) => (0, e.ipldToJson)((0, t.lexToIpld)(d));
  t.lexToJson = h;
  const m = (d) => JSON.stringify((0, t.lexToJson)(d));
  t.stringifyLex = m;
  const p = (d) => (0, t.ipldToLex)((0, e.jsonToIpld)(d));
  t.jsonToLex = p;
  const y = (d) => (0, t.jsonToLex)(JSON.parse(d));
  t.jsonStringToLex = y;
})(Fp);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(i, a, c, h) {
    h === void 0 && (h = c);
    var m = Object.getOwnPropertyDescriptor(a, c);
    (!m || ("get" in m ? !a.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(i, h, m);
  } : function(i, a, c, h) {
    h === void 0 && (h = c), i[h] = a[c];
  }), r = ne && ne.__exportStar || function(i, a) {
    for (var c in i) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && e(a, i, c);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Rn, t), r(Bu, t), r(Iu, t), r(Fp, t);
})(_a);
var $p = {};
Object.defineProperty($p, "__esModule", { value: !0 });
var ka = {};
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.BSKY_LABELER_DID = void 0;
ka.BSKY_LABELER_DID = "did:plc:ar7c4by46qjdydhdevvrndac";
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.validateSavedFeed = Nr.getSavedFeedType = Nr.savedFeedsToUriArrays = Nr.sanitizeMutedWordValue = void 0;
const Gp = as, Pv = vi;
function Bv(t) {
  return t.trim().replace(/^#(?!\ufe0f)/, "").replace(/[\r\n\u00AD\u2060\u200D\u200C\u200B]+/, "");
}
Nr.sanitizeMutedWordValue = Bv;
function Iv(t) {
  const e = [], r = [];
  for (const i of t)
    i.pinned && e.push(i.value), r.push(i.value);
  return {
    pinned: e,
    saved: r
  };
}
Nr.savedFeedsToUriArrays = Iv;
function Uv(t) {
  switch (new Gp.AtUri(t).collection) {
    case "app.bsky.feed.generator":
      return "feed";
    case "app.bsky.graph.list":
      return "list";
    default:
      return "unknown";
  }
}
Nr.getSavedFeedType = Uv;
function Ov(t) {
  if (new Pv.TID(t.id), ["feed", "list"].includes(t.type)) {
    const e = new Gp.AtUri(t.value), r = e.collection === "app.bsky.feed.generator", i = e.collection === "app.bsky.graph.list";
    if (t.type === "feed" && !r)
      throw new Error(`Saved feed of type 'feed' must be a feed, got ${e.collection}`);
    if (t.type === "list" && !i)
      throw new Error(`Saved feed of type 'list' must be a list, got ${e.collection}`);
  }
}
Nr.validateSavedFeed = Ov;
var x = {}, q = {}, Ou = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.XRPCInvalidResponseError = t.XRPCError = t.XRPCResponse = t.ResponseTypeStrings = t.ResponseTypeNames = t.ResponseType = t.errorResponseBody = void 0;
  const e = os;
  t.errorResponseBody = e.z.object({
    error: e.z.string().optional(),
    message: e.z.string().optional()
  });
  var r;
  (function(h) {
    h[h.Unknown = 1] = "Unknown", h[h.InvalidResponse = 2] = "InvalidResponse", h[h.Success = 200] = "Success", h[h.InvalidRequest = 400] = "InvalidRequest", h[h.AuthRequired = 401] = "AuthRequired", h[h.Forbidden = 403] = "Forbidden", h[h.XRPCNotSupported = 404] = "XRPCNotSupported", h[h.PayloadTooLarge = 413] = "PayloadTooLarge", h[h.RateLimitExceeded = 429] = "RateLimitExceeded", h[h.InternalServerError = 500] = "InternalServerError", h[h.MethodNotImplemented = 501] = "MethodNotImplemented", h[h.UpstreamFailure = 502] = "UpstreamFailure", h[h.NotEnoughResources = 503] = "NotEnoughResources", h[h.UpstreamTimeout = 504] = "UpstreamTimeout";
  })(r || (t.ResponseType = r = {})), t.ResponseTypeNames = {
    [r.InvalidResponse]: "InvalidResponse",
    [r.Success]: "Success",
    [r.InvalidRequest]: "InvalidRequest",
    [r.AuthRequired]: "AuthenticationRequired",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPCNotSupported",
    [r.PayloadTooLarge]: "PayloadTooLarge",
    [r.RateLimitExceeded]: "RateLimitExceeded",
    [r.InternalServerError]: "InternalServerError",
    [r.MethodNotImplemented]: "MethodNotImplemented",
    [r.UpstreamFailure]: "UpstreamFailure",
    [r.NotEnoughResources]: "NotEnoughResources",
    [r.UpstreamTimeout]: "UpstreamTimeout"
  }, t.ResponseTypeStrings = {
    [r.InvalidResponse]: "Invalid Response",
    [r.Success]: "Success",
    [r.InvalidRequest]: "Invalid Request",
    [r.AuthRequired]: "Authentication Required",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPC Not Supported",
    [r.PayloadTooLarge]: "Payload Too Large",
    [r.RateLimitExceeded]: "Rate Limit Exceeded",
    [r.InternalServerError]: "Internal Server Error",
    [r.MethodNotImplemented]: "Method Not Implemented",
    [r.UpstreamFailure]: "Upstream Failure",
    [r.NotEnoughResources]: "Not Enough Resources",
    [r.UpstreamTimeout]: "Upstream Timeout"
  };
  class i {
    constructor(m, p) {
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !0
      });
    }
  }
  t.XRPCResponse = i;
  class a extends Error {
    constructor(m, p, y, d) {
      super(y || p || t.ResponseTypeStrings[m]), Object.defineProperty(this, "status", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      }), Object.defineProperty(this, "error", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.error || (this.error = t.ResponseTypeNames[m]), this.headers = d;
    }
  }
  t.XRPCError = a;
  class c extends a {
    constructor(m, p, y) {
      super(r.InvalidResponse, t.ResponseTypeStrings[r.InvalidResponse], "The server gave an invalid response and may be out of date."), Object.defineProperty(this, "lexiconNsid", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      }), Object.defineProperty(this, "validationError", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "responseBody", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: y
      });
    }
  }
  t.XRPCInvalidResponseError = c;
})(Ou);
var Mi = {}, It = {};
Object.defineProperty(It, "__esModule", { value: !0 });
It.httpResponseBodyParse = It.httpResponseCodeToEnum = It.encodeMethodCallBody = It.constructMethodCallHeaders = It.normalizeHeaders = It.encodeQueryParam = It.constructMethodCallUri = It.getMethodSchemaHTTPMethod = void 0;
const qp = _a, ti = Ou;
function Kv(t) {
  return t.type === "procedure" ? "post" : "get";
}
It.getMethodSchemaHTTPMethod = Kv;
function Mv(t, e, r, i) {
  const a = new URL(r);
  if (a.pathname = `/xrpc/${t}`, i)
    for (const [c, h] of Object.entries(i)) {
      const m = e.parameters?.properties?.[c];
      if (!m)
        throw new Error(`Invalid query parameter: ${c}`);
      h !== void 0 && (m.type === "array" ? [].concat(h).forEach((y) => {
        a.searchParams.append(c, kc(m.items.type, y));
      }) : a.searchParams.set(c, kc(m.type, h)));
    }
  return a.toString();
}
It.constructMethodCallUri = Mv;
function kc(t, e) {
  if (t === "string" || t === "unknown")
    return String(e);
  if (t === "float")
    return String(Number(e));
  if (t === "integer")
    return String(Number(e) | 0);
  if (t === "boolean")
    return e ? "true" : "false";
  if (t === "datetime")
    return e instanceof Date ? e.toISOString() : String(e);
  throw new Error(`Unsupported query param type: ${t}`);
}
It.encodeQueryParam = kc;
function Nv(t) {
  const e = {};
  for (const [r, i] of Object.entries(t))
    e[r.toLowerCase()] = i;
  return e;
}
It.normalizeHeaders = Nv;
function Vv(t, e, r) {
  const i = r?.headers || {};
  return t.type === "procedure" && (r?.encoding && (i["Content-Type"] = r.encoding), e && typeof e == "object" && (i["Content-Type"] || (i["Content-Type"] = "application/json"))), i;
}
It.constructMethodCallHeaders = Vv;
function jv(t, e) {
  if (!(!t["content-type"] || typeof e > "u"))
    return e instanceof ArrayBuffer ? e : t["content-type"].startsWith("text/") ? new TextEncoder().encode(e.toString()) : t["content-type"].startsWith("application/json") ? new TextEncoder().encode((0, qp.stringifyLex)(e)) : e;
}
It.encodeMethodCallBody = jv;
function Fv(t) {
  let e;
  return t in ti.ResponseType ? e = t : t >= 100 && t < 200 ? e = ti.ResponseType.XRPCNotSupported : t >= 200 && t < 300 ? e = ti.ResponseType.Success : t >= 300 && t < 400 ? e = ti.ResponseType.XRPCNotSupported : t >= 400 && t < 500 ? e = ti.ResponseType.InvalidRequest : e = ti.ResponseType.InternalServerError, e;
}
It.httpResponseCodeToEnum = Fv;
function $v(t, e) {
  if (t) {
    if (t.includes("application/json") && e?.byteLength)
      try {
        const r = new TextDecoder().decode(e);
        return (0, qp.jsonStringToLex)(r);
      } catch (r) {
        throw new ti.XRPCError(ti.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
    if (t.startsWith("text/") && e?.byteLength)
      try {
        return new TextDecoder().decode(e);
      } catch (r) {
        throw new ti.XRPCError(ti.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
  }
  return e instanceof ArrayBuffer ? new Uint8Array(e) : e;
}
It.httpResponseBodyParse = $v;
Object.defineProperty(Mi, "__esModule", { value: !0 });
Mi.defaultFetchHandler = Mi.ServiceClient = Mi.Client = void 0;
const zp = _a, Un = It, un = Ou;
class Gv {
  constructor() {
    Object.defineProperty(this, "fetch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Hp
    }), Object.defineProperty(this, "lex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new zp.Lexicons()
    });
  }
  // method calls
  //
  async call(e, r, i, a, c) {
    return this.service(e).call(r, i, a, c);
  }
  service(e) {
    return new Xp(this, e);
  }
  // schemas
  // =
  addLexicon(e) {
    this.lex.add(e);
  }
  addLexicons(e) {
    for (const r of e)
      this.addLexicon(r);
  }
  removeLexicon(e) {
    this.lex.remove(e);
  }
}
Mi.Client = Gv;
class Xp {
  constructor(e, r) {
    Object.defineProperty(this, "baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uri", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this.baseClient = e, this.uri = typeof r == "string" ? new URL(r) : r;
  }
  setHeader(e, r) {
    this.headers[e] = r;
  }
  unsetHeader(e) {
    delete this.headers[e];
  }
  async call(e, r, i, a) {
    const c = this.baseClient.lex.getDefOrThrow(e);
    if (!c || c.type !== "query" && c.type !== "procedure")
      throw new Error(`Invalid lexicon: ${e}. Must be a query or procedure.`);
    const h = (0, Un.getMethodSchemaHTTPMethod)(c), m = (0, Un.constructMethodCallUri)(e, c, this.uri, r), p = (0, Un.constructMethodCallHeaders)(c, i, {
      headers: {
        ...this.headers,
        ...a?.headers
      },
      encoding: a?.encoding
    }), y = await this.baseClient.fetch(m, h, p, i), d = (0, Un.httpResponseCodeToEnum)(y.status);
    if (d === un.ResponseType.Success) {
      try {
        this.baseClient.lex.assertValidXrpcOutput(e, y.body);
      } catch (A) {
        throw A instanceof zp.ValidationError ? new un.XRPCInvalidResponseError(e, A, y.body) : A;
      }
      return new un.XRPCResponse(y.body, y.headers);
    } else
      throw y.body && qv(y.body) ? new un.XRPCError(d, y.body.error, y.body.message, y.headers) : new un.XRPCError(d);
  }
}
Mi.ServiceClient = Xp;
async function Hp(t, e, r, i) {
  try {
    const a = (0, Un.normalizeHeaders)(r), c = {
      method: e,
      headers: a,
      body: (0, Un.encodeMethodCallBody)(a, i),
      duplex: "half"
    }, h = await fetch(t, c), m = await h.arrayBuffer();
    return {
      status: h.status,
      headers: Object.fromEntries(h.headers.entries()),
      body: (0, Un.httpResponseBodyParse)(h.headers.get("content-type"), m)
    };
  } catch (a) {
    throw new un.XRPCError(un.ResponseType.Unknown, String(a));
  }
}
Mi.defaultFetchHandler = Hp;
function qv(t) {
  return un.errorResponseBody.safeParse(t).success;
}
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(c, h, m, p) {
    p === void 0 && (p = m);
    var y = Object.getOwnPropertyDescriptor(h, m);
    (!y || ("get" in y ? !h.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return h[m];
    } }), Object.defineProperty(c, p, y);
  } : function(c, h, m, p) {
    p === void 0 && (p = m), c[p] = h[m];
  }), r = ne && ne.__exportStar || function(c, h) {
    for (var m in c) m !== "default" && !Object.prototype.hasOwnProperty.call(h, m) && e(h, c, m);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Ou, t), r(Mi, t);
  const i = Mi, a = new i.Client();
  t.default = a;
})(q);
var Le = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ids = t.lexicons = t.schemas = t.schemaDict = void 0;
  const e = _a;
  t.schemaDict = {
    ComAtprotoAdminDefs: {
      lexicon: 1,
      id: "com.atproto.admin.defs",
      defs: {
        statusAttr: {
          type: "object",
          required: ["applied"],
          properties: {
            applied: {
              type: "boolean"
            },
            ref: {
              type: "string"
            }
          }
        },
        accountView: {
          type: "object",
          required: ["did", "handle", "indexedAt"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            inviteNote: {
              type: "string"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoRef: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        repoBlobRef: {
          type: "object",
          required: ["did", "cid"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoAdminDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.admin.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.disableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for disabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.disableInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Disable some set of codes and/or all codes associated with a set of users.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminEnableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.enableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Re-enable an account's ability to receive invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for enabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfo: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfo",
      defs: {
        main: {
          type: "query",
          description: "Get details about an account.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.admin.defs#accountView"
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfos: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfos",
      defs: {
        main: {
          type: "query",
          description: "Get details about some accounts.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["infos"],
              properties: {
                infos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.getInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get an admin view of invite codes.",
          parameters: {
            type: "params",
            properties: {
              sort: {
                type: "string",
                knownValues: ["recent", "usage"],
                default: "recent"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 500,
                default: 100
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                cursor: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.getSubjectStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the service-specific admin status of a subject (account, record, or blob).",
          parameters: {
            type: "params",
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              uri: {
                type: "string",
                format: "at-uri"
              },
              blob: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                },
                deactivated: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSearchAccounts: {
      lexicon: 1,
      id: "com.atproto.admin.searchAccounts",
      defs: {
        main: {
          type: "query",
          description: "Get list of accounts that matches your search query.",
          parameters: {
            type: "params",
            properties: {
              email: {
                type: "string"
              },
              cursor: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accounts"],
              properties: {
                cursor: {
                  type: "string"
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSendEmail: {
      lexicon: 1,
      id: "com.atproto.admin.sendEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Send email to a user's account email address.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["recipientDid", "content", "senderDid"],
              properties: {
                recipientDid: {
                  type: "string",
                  format: "did"
                },
                content: {
                  type: "string"
                },
                subject: {
                  type: "string"
                },
                senderDid: {
                  type: "string",
                  format: "did"
                },
                comment: {
                  type: "string",
                  description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["sent"],
              properties: {
                sent: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountEmail: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account", "email"],
              properties: {
                account: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountHandle: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's handle.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountPassword: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Update the password for a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.updateSubjectStatus",
      defs: {
        main: {
          type: "procedure",
          description: "Update the service-specific admin status of a subject (account, record, or blob).",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                },
                deactivated: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityGetRecommendedDidCredentials: {
      lexicon: 1,
      id: "com.atproto.identity.getRecommendedDidCredentials",
      defs: {
        main: {
          type: "query",
          description: "Describe the credentials that should be included in the DID doc of an account that is migrating to this service.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                rotationKeys: {
                  description: "Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs.",
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityRequestPlcOperationSignature: {
      lexicon: 1,
      id: "com.atproto.identity.requestPlcOperationSignature",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to in order to request a signed PLC operation. Requires Auth."
        }
      }
    },
    ComAtprotoIdentityResolveHandle: {
      lexicon: 1,
      id: "com.atproto.identity.resolveHandle",
      defs: {
        main: {
          type: "query",
          description: "Resolves a handle (domain name) to a DID.",
          parameters: {
            type: "params",
            required: ["handle"],
            properties: {
              handle: {
                type: "string",
                format: "handle",
                description: "The handle to resolve."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySignPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.signPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Signs a PLC operation to update some value(s) in the requesting DID's document.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                token: {
                  description: "A token received through com.atproto.identity.requestPlcOperationSignature",
                  type: "string"
                },
                rotationKeys: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown",
                  description: "A signed DID PLC operation."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySubmitPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.submitPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityUpdateHandle: {
      lexicon: 1,
      id: "com.atproto.identity.updateHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The new handle."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelDefs: {
      lexicon: 1,
      id: "com.atproto.label.defs",
      defs: {
        label: {
          type: "object",
          description: "Metadata tag on an atproto resource (eg, repo or record).",
          required: ["src", "uri", "val", "cts"],
          properties: {
            ver: {
              type: "integer",
              description: "The AT Protocol version of the label object."
            },
            src: {
              type: "string",
              format: "did",
              description: "DID of the actor who created this label."
            },
            uri: {
              type: "string",
              format: "uri",
              description: "AT URI of the record, repository (account), or other resource that this label applies to."
            },
            cid: {
              type: "string",
              format: "cid",
              description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
            },
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            },
            neg: {
              type: "boolean",
              description: "If true, this is a negation label, overwriting a previous label."
            },
            cts: {
              type: "string",
              format: "datetime",
              description: "Timestamp when this label was created."
            },
            exp: {
              type: "string",
              format: "datetime",
              description: "Timestamp at which this label expires (no longer applies)."
            },
            sig: {
              type: "bytes",
              description: "Signature of dag-cbor encoded label."
            }
          }
        },
        selfLabels: {
          type: "object",
          description: "Metadata tags on an atproto record, published by the author within the record.",
          required: ["values"],
          properties: {
            values: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#selfLabel"
              },
              maxLength: 10
            }
          }
        },
        selfLabel: {
          type: "object",
          description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
          required: ["val"],
          properties: {
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            }
          }
        },
        labelValueDefinition: {
          type: "object",
          description: "Declares a label value and its expected interpretations and behaviors.",
          required: ["identifier", "severity", "blurs", "locales"],
          properties: {
            identifier: {
              type: "string",
              description: "The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).",
              maxLength: 100,
              maxGraphemes: 100
            },
            severity: {
              type: "string",
              description: "How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.",
              knownValues: ["inform", "alert", "none"]
            },
            blurs: {
              type: "string",
              description: "What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.",
              knownValues: ["content", "media", "none"]
            },
            defaultSetting: {
              type: "string",
              description: "The default setting for this label.",
              knownValues: ["ignore", "warn", "hide"],
              default: "warn"
            },
            adultOnly: {
              type: "boolean",
              description: "Does the user need to have adult content enabled in order to configure this label?"
            },
            locales: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinitionStrings"
              }
            }
          }
        },
        labelValueDefinitionStrings: {
          type: "object",
          description: "Strings which describe the label in the UI, localized into a specific language.",
          required: ["lang", "name", "description"],
          properties: {
            lang: {
              type: "string",
              description: "The code of the language these strings are written in.",
              format: "language"
            },
            name: {
              type: "string",
              description: "A short human-readable name for the label.",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              description: "A longer description of what the label means and why it might be applied.",
              maxGraphemes: 1e4,
              maxLength: 1e5
            }
          }
        },
        labelValue: {
          type: "string",
          knownValues: [
            "!hide",
            "!no-promote",
            "!warn",
            "!no-unauthenticated",
            "dmca-violation",
            "doxxing",
            "porn",
            "sexual",
            "nudity",
            "nsfl",
            "gore"
          ]
        }
      }
    },
    ComAtprotoLabelQueryLabels: {
      lexicon: 1,
      id: "com.atproto.label.queryLabels",
      defs: {
        main: {
          type: "query",
          description: "Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.",
          parameters: {
            type: "params",
            required: ["uriPatterns"],
            properties: {
              uriPatterns: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
              },
              sources: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                },
                description: "Optional list of label sources (DIDs) to filter on."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                cursor: {
                  type: "string"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelSubscribeLabels: {
      lexicon: 1,
      id: "com.atproto.label.subscribeLabels",
      defs: {
        main: {
          type: "subscription",
          description: "Subscribe to stream of labels (and negations). Public endpoint implemented by mod services. Uses same sequencing scheme as repo event stream.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.label.subscribeLabels#labels",
                "lex:com.atproto.label.subscribeLabels#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            }
          ]
        },
        labels: {
          type: "object",
          required: ["seq", "labels"],
          properties: {
            seq: {
              type: "integer"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoModerationCreateReport: {
      lexicon: 1,
      id: "com.atproto.moderation.createReport",
      defs: {
        main: {
          type: "procedure",
          description: "Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["reasonType", "subject"],
              properties: {
                reasonType: {
                  type: "ref",
                  description: "Indicates the broad category of violation the report is for.",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4,
                  description: "Additional context about the content and violation."
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoModerationDefs: {
      lexicon: 1,
      id: "com.atproto.moderation.defs",
      defs: {
        reasonType: {
          type: "string",
          knownValues: [
            "com.atproto.moderation.defs#reasonSpam",
            "com.atproto.moderation.defs#reasonViolation",
            "com.atproto.moderation.defs#reasonMisleading",
            "com.atproto.moderation.defs#reasonSexual",
            "com.atproto.moderation.defs#reasonRude",
            "com.atproto.moderation.defs#reasonOther",
            "com.atproto.moderation.defs#reasonAppeal"
          ]
        },
        reasonSpam: {
          type: "token",
          description: "Spam: frequent unwanted promotion, replies, mentions"
        },
        reasonViolation: {
          type: "token",
          description: "Direct violation of server rules, laws, terms of service"
        },
        reasonMisleading: {
          type: "token",
          description: "Misleading identity, affiliation, or content"
        },
        reasonSexual: {
          type: "token",
          description: "Unwanted or mislabeled sexual content"
        },
        reasonRude: {
          type: "token",
          description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
        },
        reasonOther: {
          type: "token",
          description: "Other: reports not falling under another report category"
        },
        reasonAppeal: {
          type: "token",
          description: "Appeal: appeal a previously taken moderation action"
        }
      }
    },
    ComAtprotoRepoApplyWrites: {
      lexicon: 1,
      id: "com.atproto.repo.applyWrites",
      defs: {
        main: {
          type: "procedure",
          description: "Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "writes"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data, for all operations."
                },
                writes: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.repo.applyWrites#create",
                      "lex:com.atproto.repo.applyWrites#update",
                      "lex:com.atproto.repo.applyWrites#delete"
                    ],
                    closed: !0
                  }
                },
                swapCommit: {
                  type: "string",
                  description: "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that the 'swapCommit' parameter did not match current commit."
            }
          ]
        },
        create: {
          type: "object",
          description: "Operation which creates a new record.",
          required: ["collection", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string",
              maxLength: 15
            },
            value: {
              type: "unknown"
            }
          }
        },
        update: {
          type: "object",
          description: "Operation which updates an existing record.",
          required: ["collection", "rkey", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            },
            value: {
              type: "unknown"
            }
          }
        },
        delete: {
          type: "object",
          description: "Operation which deletes an existing record.",
          required: ["collection", "rkey"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoRepoCreateRecord: {
      lexicon: 1,
      id: "com.atproto.repo.createRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Create a single new repository record. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "record"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record itself. Must contain a $type field."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that 'swapCommit' didn't match current repo commit."
            }
          ]
        }
      }
    },
    ComAtprotoRepoDeleteRecord: {
      lexicon: 1,
      id: "com.atproto.repo.deleteRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoDescribeRepo: {
      lexicon: 1,
      id: "com.atproto.repo.describeRepo",
      defs: {
        main: {
          type: "query",
          description: "Get information about an account and repository, including the list of collections. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "handle",
                "did",
                "didDoc",
                "collections",
                "handleIsCorrect"
              ],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown",
                  description: "The complete DID document for this account."
                },
                collections: {
                  type: "array",
                  description: "List of all the collections (NSIDs) for which this repo contains at least one record.",
                  items: {
                    type: "string",
                    format: "nsid"
                  }
                },
                handleIsCorrect: {
                  type: "boolean",
                  description: "Indicates if handle is currently valid (resolves bi-directionally)"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoGetRecord: {
      lexicon: 1,
      id: "com.atproto.repo.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get a single record from a repository. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection", "rkey"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record collection."
              },
              rkey: {
                type: "string",
                description: "The Record Key."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the version of the record. If not specified, then return the most recent version."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoImportRepo: {
      lexicon: 1,
      id: "com.atproto.repo.importRepo",
      defs: {
        main: {
          type: "procedure",
          description: "Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.",
          input: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoRepoListMissingBlobs: {
      lexicon: 1,
      id: "com.atproto.repo.listMissingBlobs",
      defs: {
        main: {
          type: "query",
          description: "Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blobs"],
              properties: {
                cursor: {
                  type: "string"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listMissingBlobs#recordBlob"
                  }
                }
              }
            }
          }
        },
        recordBlob: {
          type: "object",
          required: ["cid", "recordUri"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoRepoListRecords: {
      lexicon: 1,
      id: "com.atproto.repo.listRecords",
      defs: {
        main: {
          type: "query",
          description: "List a range of records in a repository, matching a specific collection. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record type."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50,
                description: "The number of records to return."
              },
              cursor: {
                type: "string"
              },
              rkeyStart: {
                type: "string",
                description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
              },
              rkeyEnd: {
                type: "string",
                description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
              },
              reverse: {
                type: "boolean",
                description: "Flag to reverse the order of the returned records."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["records"],
              properties: {
                cursor: {
                  type: "string"
                },
                records: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listRecords#record"
                  }
                }
              }
            }
          }
        },
        record: {
          type: "object",
          required: ["uri", "cid", "value"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            }
          }
        }
      }
    },
    ComAtprotoRepoPutRecord: {
      lexicon: 1,
      id: "com.atproto.repo.putRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey", "record"],
              nullable: ["swapRecord"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record to write."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation"
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoStrongRef: {
      lexicon: 1,
      id: "com.atproto.repo.strongRef",
      description: "A URI with a content-hash fingerprint.",
      defs: {
        main: {
          type: "object",
          required: ["uri", "cid"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            }
          }
        }
      }
    },
    ComAtprotoRepoUploadBlob: {
      lexicon: 1,
      id: "com.atproto.repo.uploadBlob",
      defs: {
        main: {
          type: "procedure",
          description: "Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.",
          input: {
            encoding: "*/*"
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blob"],
              properties: {
                blob: {
                  type: "blob"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerActivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.activateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup."
        }
      }
    },
    ComAtprotoServerCheckAccountStatus: {
      lexicon: 1,
      id: "com.atproto.server.checkAccountStatus",
      defs: {
        main: {
          type: "query",
          description: "Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "activated",
                "validDid",
                "repoCommit",
                "repoRev",
                "repoBlocks",
                "indexedRecords",
                "privateStateValues",
                "expectedBlobs",
                "importedBlobs"
              ],
              properties: {
                activated: {
                  type: "boolean"
                },
                validDid: {
                  type: "boolean"
                },
                repoCommit: {
                  type: "string",
                  format: "cid"
                },
                repoRev: {
                  type: "string"
                },
                repoBlocks: {
                  type: "integer"
                },
                indexedRecords: {
                  type: "integer"
                },
                privateStateValues: {
                  type: "integer"
                },
                expectedBlobs: {
                  type: "integer"
                },
                importedBlobs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerConfirmEmail: {
      lexicon: 1,
      id: "com.atproto.server.confirmEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email", "token"],
              properties: {
                email: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "AccountNotFound"
            },
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "InvalidEmail"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAccount: {
      lexicon: 1,
      id: "com.atproto.server.createAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Create an account. Implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                email: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle",
                  description: "Requested handle for the account."
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "Pre-existing atproto DID, being imported to a new account."
                },
                inviteCode: {
                  type: "string"
                },
                verificationCode: {
                  type: "string"
                },
                verificationPhone: {
                  type: "string"
                },
                password: {
                  type: "string",
                  description: "Initial account password. May need to meet instance-specific password strength requirements."
                },
                recoveryKey: {
                  type: "string",
                  description: "DID PLC rotation key (aka, recovery key) to be included in PLC creation operation."
                },
                plcOp: {
                  type: "unknown",
                  description: "A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              description: "Account login session returned on successful account creation.",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the new account."
                },
                didDoc: {
                  type: "unknown",
                  description: "Complete DID document."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidHandle"
            },
            {
              name: "InvalidPassword"
            },
            {
              name: "InvalidInviteCode"
            },
            {
              name: "HandleNotAvailable"
            },
            {
              name: "UnsupportedDomain"
            },
            {
              name: "UnresolvableDid"
            },
            {
              name: "IncompatibleDidDoc"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.createAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Create an App Password.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  description: "A short name for the App Password, to help distinguish them."
                },
                privileged: {
                  type: "boolean",
                  description: "If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.server.createAppPassword#appPassword"
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "password", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            password: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            privileged: {
              type: "boolean"
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCode: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCode",
      defs: {
        main: {
          type: "procedure",
          description: "Create an invite code.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["useCount"],
              properties: {
                useCount: {
                  type: "integer"
                },
                forAccount: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["code"],
              properties: {
                code: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Create invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codeCount", "useCount"],
              properties: {
                codeCount: {
                  type: "integer",
                  default: 1
                },
                useCount: {
                  type: "integer"
                },
                forAccounts: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                  }
                }
              }
            }
          }
        },
        accountCodes: {
          type: "object",
          required: ["account", "codes"],
          properties: {
            account: {
              type: "string"
            },
            codes: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateSession: {
      lexicon: 1,
      id: "com.atproto.server.createSession",
      defs: {
        main: {
          type: "procedure",
          description: "Create an authentication session.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["identifier", "password"],
              properties: {
                identifier: {
                  type: "string",
                  description: "Handle or other identifier supported by the server for the authenticating user."
                },
                password: {
                  type: "string"
                },
                authFactorToken: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            },
            {
              name: "AuthFactorTokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeactivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.deactivateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                deleteAfter: {
                  type: "string",
                  format: "datetime",
                  description: "A recommendation to server as to how long they should hold onto the deactivated account before deleting."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerDefs: {
      lexicon: 1,
      id: "com.atproto.server.defs",
      defs: {
        inviteCode: {
          type: "object",
          required: [
            "code",
            "available",
            "disabled",
            "forAccount",
            "createdBy",
            "createdAt",
            "uses"
          ],
          properties: {
            code: {
              type: "string"
            },
            available: {
              type: "integer"
            },
            disabled: {
              type: "boolean"
            },
            forAccount: {
              type: "string"
            },
            createdBy: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            uses: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCodeUse"
              }
            }
          }
        },
        inviteCodeUse: {
          type: "object",
          required: ["usedBy", "usedAt"],
          properties: {
            usedBy: {
              type: "string",
              format: "did"
            },
            usedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ComAtprotoServerDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.server.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password", "token"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeleteSession: {
      lexicon: 1,
      id: "com.atproto.server.deleteSession",
      defs: {
        main: {
          type: "procedure",
          description: "Delete the current session. Requires auth."
        }
      }
    },
    ComAtprotoServerDescribeServer: {
      lexicon: 1,
      id: "com.atproto.server.describeServer",
      defs: {
        main: {
          type: "query",
          description: "Describes the server's account creation requirements and capabilities. Implemented by PDS.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "availableUserDomains"],
              properties: {
                inviteCodeRequired: {
                  type: "boolean",
                  description: "If true, an invite code must be supplied to create an account on this instance."
                },
                phoneVerificationRequired: {
                  type: "boolean",
                  description: "If true, a phone verification token must be supplied to create an account on this instance."
                },
                availableUserDomains: {
                  type: "array",
                  description: "List of domain suffixes that can be used in account handles.",
                  items: {
                    type: "string"
                  }
                },
                links: {
                  type: "ref",
                  description: "URLs of service policy documents.",
                  ref: "lex:com.atproto.server.describeServer#links"
                },
                contact: {
                  type: "ref",
                  description: "Contact information",
                  ref: "lex:com.atproto.server.describeServer#contact"
                },
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string",
              format: "uri"
            },
            termsOfService: {
              type: "string",
              format: "uri"
            }
          }
        },
        contact: {
          type: "object",
          properties: {
            email: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoServerGetAccountInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.getAccountInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get all invite codes for the current account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              includeUsed: {
                type: "boolean",
                default: !0
              },
              createAvailable: {
                type: "boolean",
                default: !0,
                description: "Controls whether any new 'earned' but not 'created' invites should be created."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "DuplicateCreate"
            }
          ]
        }
      }
    },
    ComAtprotoServerGetServiceAuth: {
      lexicon: 1,
      id: "com.atproto.server.getServiceAuth",
      defs: {
        main: {
          type: "query",
          description: "Get a signed token on behalf of the requesting DID for the requested service.",
          parameters: {
            type: "params",
            required: ["aud"],
            properties: {
              aud: {
                type: "string",
                format: "did",
                description: "The DID of the service that the token will be used to authenticate with"
              },
              exp: {
                type: "integer",
                description: "The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope."
              },
              lxm: {
                type: "string",
                format: "nsid",
                description: "Lexicon (XRPC) method to bind the requested token to"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token"],
              properties: {
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "BadExpiration",
              description: "Indicates that the requested expiration date is not a valid. May be in the past or may be reliant on the requested scopes."
            }
          ]
        }
      }
    },
    ComAtprotoServerGetSession: {
      lexicon: 1,
      id: "com.atproto.server.getSession",
      defs: {
        main: {
          type: "query",
          description: "Get information about the current auth session. Requires auth.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle", "did"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                didDoc: {
                  type: "unknown"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerListAppPasswords: {
      lexicon: 1,
      id: "com.atproto.server.listAppPasswords",
      defs: {
        main: {
          type: "query",
          description: "List all App Passwords.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["passwords"],
              properties: {
                passwords: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            privileged: {
              type: "boolean"
            }
          }
        }
      }
    },
    ComAtprotoServerRefreshSession: {
      lexicon: 1,
      id: "com.atproto.server.refreshSession",
      defs: {
        main: {
          type: "procedure",
          description: "Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "Hosting status of the account. If not specified, then assume 'active'.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        }
      }
    },
    ComAtprotoServerRequestAccountDelete: {
      lexicon: 1,
      id: "com.atproto.server.requestAccountDelete",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account deletion via email."
        }
      }
    },
    ComAtprotoServerRequestEmailConfirmation: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailConfirmation",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to confirm ownership of email."
        }
      }
    },
    ComAtprotoServerRequestEmailUpdate: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Request a token in order to update email.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["tokenRequired"],
              properties: {
                tokenRequired: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerRequestPasswordReset: {
      lexicon: 1,
      id: "com.atproto.server.requestPasswordReset",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account password reset via email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerReserveSigningKey: {
      lexicon: 1,
      id: "com.atproto.server.reserveSigningKey",
      defs: {
        main: {
          type: "procedure",
          description: "Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID to reserve a key for."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["signingKey"],
              properties: {
                signingKey: {
                  type: "string",
                  description: "The public key for the reserved signing key, in did:key serialization."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerResetPassword: {
      lexicon: 1,
      id: "com.atproto.server.resetPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Reset a user account password using a token.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token", "password"],
              properties: {
                token: {
                  type: "string"
                },
                password: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerRevokeAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.revokeAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Revoke an App Password by name.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerUpdateEmail: {
      lexicon: 1,
      id: "com.atproto.server.updateEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                token: {
                  type: "string",
                  description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "TokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlob: {
      lexicon: 1,
      id: "com.atproto.sync.getBlob",
      defs: {
        main: {
          type: "query",
          description: "Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cid"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the account."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the blob to fetch"
              }
            }
          },
          output: {
            encoding: "*/*"
          },
          errors: [
            {
              name: "BlobNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlocks: {
      lexicon: 1,
      id: "com.atproto.sync.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cids"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              cids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "BlockNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetCheckout: {
      lexicon: 1,
      id: "com.atproto.sync.getCheckout",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoSyncGetHead: {
      lexicon: 1,
      id: "com.atproto.sync.getHead",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "HeadNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetLatestCommit: {
      lexicon: 1,
      id: "com.atproto.sync.getLatestCommit",
      defs: {
        main: {
          type: "query",
          description: "Get the current commit CID & revision of the specified repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cid", "rev"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRecord: {
      lexicon: 1,
      id: "com.atproto.sync.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did", "collection", "rkey"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                description: "Record Key"
              },
              commit: {
                type: "string",
                format: "cid",
                description: "DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit"
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "RecordNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRepo: {
      lexicon: 1,
      id: "com.atproto.sync.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "The revision ('rev') of the repo to create a diff from."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRepoStatus: {
      lexicon: 1,
      id: "com.atproto.sync.getRepoStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "active"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                },
                rev: {
                  type: "string",
                  description: "Optional field, the current rev of the repo, if active=true"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncListBlobs: {
      lexicon: 1,
      id: "com.atproto.sync.listBlobs",
      defs: {
        main: {
          type: "query",
          description: "List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "Optional revision of the repo to list blobs since."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cids"],
              properties: {
                cursor: {
                  type: "string"
                },
                cids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncListRepos: {
      lexicon: 1,
      id: "com.atproto.sync.listRepos",
      defs: {
        main: {
          type: "query",
          description: "Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.listRepos#repo"
                  }
                }
              }
            }
          }
        },
        repo: {
          type: "object",
          required: ["did", "head", "rev"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            head: {
              type: "string",
              format: "cid",
              description: "Current repo commit CID"
            },
            rev: {
              type: "string"
            },
            active: {
              type: "boolean"
            },
            status: {
              type: "string",
              description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
              knownValues: ["takendown", "suspended", "deactivated"]
            }
          }
        }
      }
    },
    ComAtprotoSyncNotifyOfUpdate: {
      lexicon: 1,
      id: "com.atproto.sync.notifyOfUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (usually a PDS) that is notifying of update."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncRequestCrawl: {
      lexicon: 1,
      id: "com.atproto.sync.requestCrawl",
      defs: {
        main: {
          type: "procedure",
          description: "Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (eg, PDS) that is requesting to be crawled."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncSubscribeRepos: {
      lexicon: 1,
      id: "com.atproto.sync.subscribeRepos",
      defs: {
        main: {
          type: "subscription",
          description: "Repository event stream, aka Firehose endpoint. Outputs repo commits with diff data, and identity update events, for all repositories on the current server. See the atproto specifications for details around stream sequencing, repo versioning, CAR diff format, and more. Public and does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.sync.subscribeRepos#commit",
                "lex:com.atproto.sync.subscribeRepos#identity",
                "lex:com.atproto.sync.subscribeRepos#account",
                "lex:com.atproto.sync.subscribeRepos#handle",
                "lex:com.atproto.sync.subscribeRepos#migrate",
                "lex:com.atproto.sync.subscribeRepos#tombstone",
                "lex:com.atproto.sync.subscribeRepos#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            },
            {
              name: "ConsumerTooSlow",
              description: "If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection."
            }
          ]
        },
        commit: {
          type: "object",
          description: "Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.",
          required: [
            "seq",
            "rebase",
            "tooBig",
            "repo",
            "commit",
            "rev",
            "since",
            "blocks",
            "ops",
            "blobs",
            "time"
          ],
          nullable: ["prev", "since"],
          properties: {
            seq: {
              type: "integer",
              description: "The stream sequence number of this message."
            },
            rebase: {
              type: "boolean",
              description: "DEPRECATED -- unused"
            },
            tooBig: {
              type: "boolean",
              description: "Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data."
            },
            repo: {
              type: "string",
              format: "did",
              description: "The repo this event comes from."
            },
            commit: {
              type: "cid-link",
              description: "Repo commit object CID."
            },
            prev: {
              type: "cid-link",
              description: "DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability."
            },
            rev: {
              type: "string",
              description: "The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event."
            },
            since: {
              type: "string",
              description: "The rev of the last emitted commit from this repo (if any)."
            },
            blocks: {
              type: "bytes",
              description: "CAR file containing relevant blocks, as a diff since the previous repo state.",
              maxLength: 1e6
            },
            ops: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.sync.subscribeRepos#repoOp",
                description: "List of repo mutation operations in this commit (eg, records created, updated, or deleted)."
              },
              maxLength: 200
            },
            blobs: {
              type: "array",
              items: {
                type: "cid-link",
                description: "List of new blobs (by CID) referenced by records in this commit."
              }
            },
            time: {
              type: "string",
              format: "datetime",
              description: "Timestamp of when this message was originally broadcast."
            }
          }
        },
        identity: {
          type: "object",
          description: "Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            },
            handle: {
              type: "string",
              format: "handle",
              description: "The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details."
            }
          }
        },
        account: {
          type: "object",
          description: "Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active.",
          required: ["seq", "did", "time", "active"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            },
            active: {
              type: "boolean",
              description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
            },
            status: {
              type: "string",
              description: "If active=false, this optional field indicates a reason for why the account is not active.",
              knownValues: ["takendown", "suspended", "deleted", "deactivated"]
            }
          }
        },
        handle: {
          type: "object",
          description: "DEPRECATED -- Use #identity event instead",
          required: ["seq", "did", "handle", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        migrate: {
          type: "object",
          description: "DEPRECATED -- Use #account event instead",
          required: ["seq", "did", "migrateTo", "time"],
          nullable: ["migrateTo"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            migrateTo: {
              type: "string"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        tombstone: {
          type: "object",
          description: "DEPRECATED -- Use #account event instead",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        },
        repoOp: {
          type: "object",
          description: "A repo operation, ie a mutation of a single record.",
          required: ["action", "path", "cid"],
          nullable: ["cid"],
          properties: {
            action: {
              type: "string",
              knownValues: ["create", "update", "delete"]
            },
            path: {
              type: "string"
            },
            cid: {
              type: "cid-link",
              description: "For creates and updates, the new record CID. For deletions, null."
            }
          }
        }
      }
    },
    ComAtprotoTempCheckSignupQueue: {
      lexicon: 1,
      id: "com.atproto.temp.checkSignupQueue",
      defs: {
        main: {
          type: "query",
          description: "Check accounts location in signup queue.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["activated"],
              properties: {
                activated: {
                  type: "boolean"
                },
                placeInQueue: {
                  type: "integer"
                },
                estimatedTimeMs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempFetchLabels: {
      lexicon: 1,
      id: "com.atproto.temp.fetchLabels",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.",
          parameters: {
            type: "params",
            properties: {
              since: {
                type: "integer"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempRequestPhoneVerification: {
      lexicon: 1,
      id: "com.atproto.temp.requestPhoneVerification",
      defs: {
        main: {
          type: "procedure",
          description: "Request a verification code to be sent to the supplied phone number",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["phoneNumber"],
              properties: {
                phoneNumber: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorDefs: {
      lexicon: 1,
      id: "app.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        profileView: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileViewDetailed: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            banner: {
              type: "string",
              format: "uri"
            },
            followersCount: {
              type: "integer"
            },
            followsCount: {
              type: "integer"
            },
            postsCount: {
              type: "integer"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            joinedViaStarterPack: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileAssociated: {
          type: "object",
          properties: {
            lists: {
              type: "integer"
            },
            feedgens: {
              type: "integer"
            },
            starterPacks: {
              type: "integer"
            },
            labeler: {
              type: "boolean"
            },
            chat: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociatedChat"
            }
          }
        },
        profileAssociatedChat: {
          type: "object",
          required: ["allowIncoming"],
          properties: {
            allowIncoming: {
              type: "string",
              knownValues: ["all", "none", "following"]
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.",
          properties: {
            muted: {
              type: "boolean"
            },
            mutedByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            blockedBy: {
              type: "boolean"
            },
            blocking: {
              type: "string",
              format: "at-uri"
            },
            blockingByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            following: {
              type: "string",
              format: "at-uri"
            },
            followedBy: {
              type: "string",
              format: "at-uri"
            },
            knownFollowers: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#knownFollowers"
            }
          }
        },
        knownFollowers: {
          type: "object",
          description: "The subject's followers whom you also follow",
          required: ["count", "followers"],
          properties: {
            count: {
              type: "integer"
            },
            followers: {
              type: "array",
              minLength: 0,
              maxLength: 5,
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              }
            }
          }
        },
        preferences: {
          type: "array",
          items: {
            type: "union",
            refs: [
              "lex:app.bsky.actor.defs#adultContentPref",
              "lex:app.bsky.actor.defs#contentLabelPref",
              "lex:app.bsky.actor.defs#savedFeedsPref",
              "lex:app.bsky.actor.defs#savedFeedsPrefV2",
              "lex:app.bsky.actor.defs#personalDetailsPref",
              "lex:app.bsky.actor.defs#feedViewPref",
              "lex:app.bsky.actor.defs#threadViewPref",
              "lex:app.bsky.actor.defs#interestsPref",
              "lex:app.bsky.actor.defs#mutedWordsPref",
              "lex:app.bsky.actor.defs#hiddenPostsPref",
              "lex:app.bsky.actor.defs#bskyAppStatePref",
              "lex:app.bsky.actor.defs#labelersPref"
            ]
          }
        },
        adultContentPref: {
          type: "object",
          required: ["enabled"],
          properties: {
            enabled: {
              type: "boolean",
              default: !1
            }
          }
        },
        contentLabelPref: {
          type: "object",
          required: ["label", "visibility"],
          properties: {
            labelerDid: {
              type: "string",
              description: "Which labeler does this preference apply to? If undefined, applies globally.",
              format: "did"
            },
            label: {
              type: "string"
            },
            visibility: {
              type: "string",
              knownValues: ["ignore", "show", "warn", "hide"]
            }
          }
        },
        savedFeed: {
          type: "object",
          required: ["id", "type", "value", "pinned"],
          properties: {
            id: {
              type: "string"
            },
            type: {
              type: "string",
              knownValues: ["feed", "list", "timeline"]
            },
            value: {
              type: "string"
            },
            pinned: {
              type: "boolean"
            }
          }
        },
        savedFeedsPrefV2: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#savedFeed"
              }
            }
          }
        },
        savedFeedsPref: {
          type: "object",
          required: ["pinned", "saved"],
          properties: {
            pinned: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            saved: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            timelineIndex: {
              type: "integer"
            }
          }
        },
        personalDetailsPref: {
          type: "object",
          properties: {
            birthDate: {
              type: "string",
              format: "datetime",
              description: "The birth date of account owner."
            }
          }
        },
        feedViewPref: {
          type: "object",
          required: ["feed"],
          properties: {
            feed: {
              type: "string",
              description: "The URI of the feed, or an identifier which describes the feed."
            },
            hideReplies: {
              type: "boolean",
              description: "Hide replies in the feed."
            },
            hideRepliesByUnfollowed: {
              type: "boolean",
              description: "Hide replies in the feed if they are not by followed users.",
              default: !0
            },
            hideRepliesByLikeCount: {
              type: "integer",
              description: "Hide replies in the feed if they do not have this number of likes."
            },
            hideReposts: {
              type: "boolean",
              description: "Hide reposts in the feed."
            },
            hideQuotePosts: {
              type: "boolean",
              description: "Hide quote posts in the feed."
            }
          }
        },
        threadViewPref: {
          type: "object",
          properties: {
            sort: {
              type: "string",
              description: "Sorting mode for threads.",
              knownValues: ["oldest", "newest", "most-likes", "random"]
            },
            prioritizeFollowedUsers: {
              type: "boolean",
              description: "Show followed users at the top of all replies."
            }
          }
        },
        interestsPref: {
          type: "object",
          required: ["tags"],
          properties: {
            tags: {
              type: "array",
              maxLength: 100,
              items: {
                type: "string",
                maxLength: 640,
                maxGraphemes: 64
              },
              description: "A list of tags which describe the account owner's interests gathered during onboarding."
            }
          }
        },
        mutedWordTarget: {
          type: "string",
          knownValues: ["content", "tag"],
          maxLength: 640,
          maxGraphemes: 64
        },
        mutedWord: {
          type: "object",
          description: "A word that the account owner has muted.",
          required: ["value", "targets"],
          properties: {
            id: {
              type: "string"
            },
            value: {
              type: "string",
              description: "The muted word itself.",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            targets: {
              type: "array",
              description: "The intended targets of the muted word.",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWordTarget"
              }
            },
            actorTarget: {
              type: "string",
              description: "Groups of users to apply the muted word to. If undefined, applies to all users.",
              knownValues: ["all", "exclude-following"],
              default: "all"
            },
            expiresAt: {
              type: "string",
              format: "datetime",
              description: "The date and time at which the muted word will expire and no longer be applied."
            }
          }
        },
        mutedWordsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWord"
              },
              description: "A list of words the account owner has muted."
            }
          }
        },
        hiddenPostsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              },
              description: "A list of URIs of posts the account owner has hidden."
            }
          }
        },
        labelersPref: {
          type: "object",
          required: ["labelers"],
          properties: {
            labelers: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#labelerPrefItem"
              }
            }
          }
        },
        labelerPrefItem: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        bskyAppStatePref: {
          description: "A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this.",
          type: "object",
          properties: {
            activeProgressGuide: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#bskyAppProgressGuide"
            },
            queuedNudges: {
              description: "An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.",
              type: "array",
              maxLength: 1e3,
              items: {
                type: "string",
                maxLength: 100
              }
            }
          }
        },
        bskyAppProgressGuide: {
          description: "If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress.",
          type: "object",
          required: ["guide"],
          properties: {
            guide: {
              type: "string",
              maxLength: 100
            }
          }
        }
      }
    },
    AppBskyActorGetPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.getPreferences",
      defs: {
        main: {
          type: "query",
          description: "Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetProfile: {
      lexicon: 1,
      id: "app.bsky.actor.getProfile",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Handle or DID of account to fetch profile of."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            }
          }
        }
      }
    },
    AppBskyActorGetProfiles: {
      lexicon: 1,
      id: "app.bsky.actor.getProfiles",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile views of multiple actors.",
          parameters: {
            type: "params",
            required: ["actors"],
            properties: {
              actors: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-identifier"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["profiles"],
              properties: {
                profiles: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetSuggestions: {
      lexicon: 1,
      id: "app.bsky.actor.getSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorProfile: {
      lexicon: 1,
      id: "app.bsky.actor.profile",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky account profile.",
          key: "literal:self",
          record: {
            type: "object",
            properties: {
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                description: "Free-form profile description text.",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "blob",
                description: "Small image to be displayed next to posts from account. AKA, 'profile picture'",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              banner: {
                type: "blob",
                description: "Larger horizontal image to display behind profile view.",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                description: "Self-label values, specific to the Bluesky application, on the overall account.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              joinedViaStarterPack: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyActorPutPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set the private preferences attached to the account.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActors: {
      lexicon: 1,
      id: "app.bsky.actor.searchActors",
      defs: {
        main: {
          type: "query",
          description: "Find actors (profiles) matching search criteria. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActorsTypeahead: {
      lexicon: 1,
      id: "app.bsky.actor.searchActorsTypeahead",
      defs: {
        main: {
          type: "query",
          description: "Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query prefix; not a full query string."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 10
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyEmbedExternal: {
      lexicon: 1,
      id: "app.bsky.embed.external",
      defs: {
        main: {
          type: "object",
          description: "A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post).",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#external"
            }
          }
        },
        external: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            }
          }
        },
        view: {
          type: "object",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#viewExternal"
            }
          }
        },
        viewExternal: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyEmbedImages: {
      lexicon: 1,
      id: "app.bsky.embed.images",
      description: "A set of images embedded in a Bluesky record (eg, a post).",
      defs: {
        main: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#image"
              },
              maxLength: 4
            }
          }
        },
        image: {
          type: "object",
          required: ["image", "alt"],
          properties: {
            image: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        },
        aspectRatio: {
          type: "object",
          description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer",
              minimum: 1
            },
            height: {
              type: "integer",
              minimum: 1
            }
          }
        },
        view: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#viewImage"
              },
              maxLength: 4
            }
          }
        },
        viewImage: {
          type: "object",
          required: ["thumb", "fullsize", "alt"],
          properties: {
            thumb: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View."
            },
            fullsize: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View."
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        }
      }
    },
    AppBskyEmbedRecord: {
      lexicon: 1,
      id: "app.bsky.embed.record",
      description: "A representation of a record embedded in a Bluesky record (eg, a post). For example, a quote-post, or sharing a feed generator record.",
      defs: {
        main: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        view: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.record#viewRecord",
                "lex:app.bsky.embed.record#viewNotFound",
                "lex:app.bsky.embed.record#viewBlocked",
                "lex:app.bsky.feed.defs#generatorView",
                "lex:app.bsky.graph.defs#listView",
                "lex:app.bsky.labeler.defs#labelerView",
                "lex:app.bsky.graph.defs#starterPackViewBasic"
              ]
            }
          }
        },
        viewRecord: {
          type: "object",
          required: ["uri", "cid", "author", "value", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            value: {
              type: "unknown",
              description: "The record data itself."
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            embeds: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.external#view",
                  "lex:app.bsky.embed.record#view",
                  "lex:app.bsky.embed.recordWithMedia#view"
                ]
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        viewNotFound: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        viewBlocked: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        }
      }
    },
    AppBskyEmbedRecordWithMedia: {
      lexicon: 1,
      id: "app.bsky.embed.recordWithMedia",
      description: "A representation of a record embedded in a Bluesky record (eg, a post), alongside other compatible embeds. For example, a quote post and image, or a quote post and external URL card.",
      defs: {
        main: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record"
            },
            media: {
              type: "union",
              refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
            }
          }
        },
        view: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record#view"
            },
            media: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view"
              ]
            }
          }
        }
      }
    },
    AppBskyFeedDefs: {
      lexicon: 1,
      id: "app.bsky.feed.defs",
      defs: {
        postView: {
          type: "object",
          required: ["uri", "cid", "author", "record", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            record: {
              type: "unknown"
            },
            embed: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view",
                "lex:app.bsky.embed.record#view",
                "lex:app.bsky.embed.recordWithMedia#view"
              ]
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            threadgate: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#threadgateView"
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.",
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            },
            like: {
              type: "string",
              format: "at-uri"
            },
            threadMuted: {
              type: "boolean"
            },
            replyDisabled: {
              type: "boolean"
            }
          }
        },
        feedViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            reply: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#replyRef"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#reasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context provided by feed generator that may be passed back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            grandparentAuthor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic",
              description: "When parent is a reply to another post, this is the author of that post."
            }
          }
        },
        reasonRepost: {
          type: "object",
          required: ["by", "indexedAt"],
          properties: {
            by: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        threadViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#threadViewPost",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            replies: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#threadViewPost",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              }
            }
          }
        },
        notFoundPost: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        blockedPost: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        },
        blockedAuthor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            }
          }
        },
        generatorView: {
          type: "object",
          required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            did: {
              type: "string",
              format: "did"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            displayName: {
              type: "string"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            acceptsInteractions: {
              type: "boolean"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#generatorViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        generatorViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonFeedPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "string",
              format: "at-uri"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context that will be passed through to client and may be passed to feed generator back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        skeletonReasonRepost: {
          type: "object",
          required: ["repost"],
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        threadgateView: {
          type: "object",
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            lists: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              }
            }
          }
        },
        interaction: {
          type: "object",
          properties: {
            item: {
              type: "string",
              format: "at-uri"
            },
            event: {
              type: "string",
              knownValues: [
                "app.bsky.feed.defs#requestLess",
                "app.bsky.feed.defs#requestMore",
                "app.bsky.feed.defs#clickthroughItem",
                "app.bsky.feed.defs#clickthroughAuthor",
                "app.bsky.feed.defs#clickthroughReposter",
                "app.bsky.feed.defs#clickthroughEmbed",
                "app.bsky.feed.defs#interactionSeen",
                "app.bsky.feed.defs#interactionLike",
                "app.bsky.feed.defs#interactionRepost",
                "app.bsky.feed.defs#interactionReply",
                "app.bsky.feed.defs#interactionQuote",
                "app.bsky.feed.defs#interactionShare"
              ]
            },
            feedContext: {
              type: "string",
              description: "Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.",
              maxLength: 2e3
            }
          }
        },
        requestLess: {
          type: "token",
          description: "Request that less content like the given feed item be shown in the feed"
        },
        requestMore: {
          type: "token",
          description: "Request that more content like the given feed item be shown in the feed"
        },
        clickthroughItem: {
          type: "token",
          description: "User clicked through to the feed item"
        },
        clickthroughAuthor: {
          type: "token",
          description: "User clicked through to the author of the feed item"
        },
        clickthroughReposter: {
          type: "token",
          description: "User clicked through to the reposter of the feed item"
        },
        clickthroughEmbed: {
          type: "token",
          description: "User clicked through to the embedded content of the feed item"
        },
        interactionSeen: {
          type: "token",
          description: "Feed item was seen by user"
        },
        interactionLike: {
          type: "token",
          description: "User liked the feed item"
        },
        interactionRepost: {
          type: "token",
          description: "User reposted the feed item"
        },
        interactionReply: {
          type: "token",
          description: "User replied to the feed item"
        },
        interactionQuote: {
          type: "token",
          description: "User quoted the feed item"
        },
        interactionShare: {
          type: "token",
          description: "User shared the feed item"
        }
      }
    },
    AppBskyFeedDescribeFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.describeFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "feeds"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                  }
                },
                links: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                }
              }
            }
          }
        },
        feed: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string"
            },
            termsOfService: {
              type: "string"
            }
          }
        }
      }
    },
    AppBskyFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.generator",
      defs: {
        main: {
          type: "record",
          description: "Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository.",
          key: "any",
          record: {
            type: "object",
            required: ["did", "displayName", "createdAt"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              displayName: {
                type: "string",
                maxGraphemes: 24,
                maxLength: 240
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              acceptsInteractions: {
                type: "boolean",
                description: "Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions"
              },
              labels: {
                type: "union",
                description: "Self-label values",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getActorFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of feeds (feed generator records) created by the actor (in the actor's repo).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getActorLikes",
      defs: {
        main: {
          type: "query",
          description: "Get a list of posts liked by an actor. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetAuthorFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getAuthorFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              filter: {
                type: "string",
                description: "Combinations of post/repost types to include in response.",
                knownValues: [
                  "posts_with_replies",
                  "posts_no_replies",
                  "posts_with_media",
                  "posts_and_author_threads"
                ],
                default: "posts_with_replies"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a hydrated feed from an actor's selected feed generator. Implemented by App View.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator. Implemented by AppView.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the feed generator record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["view", "isOnline", "isValid"],
              properties: {
                view: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorView"
                },
                isOnline: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service has been online recently, or else seems to be inactive."
                },
                isValid: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service is compatible with the record declaration."
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of feed generators.",
          parameters: {
            type: "params",
            required: ["feeds"],
            properties: {
              feeds: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedSkeleton: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "Reference to feed generator record describing the specific feed being requested."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getLikes",
      defs: {
        main: {
          type: "query",
          description: "Get like records which reference a subject (by AT-URI and CID).",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the subject (eg, a post record)."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "CID of the subject record (aka, specific version of record), to filter likes."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "likes"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                likes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.getLikes#like"
                  }
                }
              }
            }
          }
        },
        like: {
          type: "object",
          required: ["indexedAt", "createdAt", "actor"],
          properties: {
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            actor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        }
      }
    },
    AppBskyFeedGetListFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getListFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownList"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPostThread: {
      lexicon: 1,
      id: "app.bsky.feed.getPostThread",
      defs: {
        main: {
          type: "query",
          description: "Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to post record."
              },
              depth: {
                type: "integer",
                description: "How many levels of reply depth should be included in response.",
                default: 6,
                minimum: 0,
                maximum: 1e3
              },
              parentHeight: {
                type: "integer",
                description: "How many levels of parent (and grandparent, etc) post to include.",
                default: 80,
                minimum: 0,
                maximum: 1e3
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["thread"],
              properties: {
                thread: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            }
          },
          errors: [
            {
              name: "NotFound"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPosts: {
      lexicon: 1,
      id: "app.bsky.feed.getPosts",
      defs: {
        main: {
          type: "query",
          description: "Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                description: "List of post AT-URIs to return hydrated views for.",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetRepostedBy: {
      lexicon: 1,
      id: "app.bsky.feed.getRepostedBy",
      defs: {
        main: {
          type: "query",
          description: "Get a list of reposts for a given post.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of post record"
              },
              cid: {
                type: "string",
                format: "cid",
                description: "If supplied, filters to reposts of specific version (by CID) of the post record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "repostedBy"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                repostedBy: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetSuggestedFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getSuggestedFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested feeds (feed generators) for the requesting account.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetTimeline: {
      lexicon: 1,
      id: "app.bsky.feed.getTimeline",
      defs: {
        main: {
          type: "query",
          description: "Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.",
          parameters: {
            type: "params",
            properties: {
              algorithm: {
                type: "string",
                description: "Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedLike: {
      lexicon: 1,
      id: "app.bsky.feed.like",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'like' of a piece of subject content.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedPost: {
      lexicon: 1,
      id: "app.bsky.feed.post",
      defs: {
        main: {
          type: "record",
          description: "Record containing a Bluesky post.",
          key: "tid",
          record: {
            type: "object",
            required: ["text", "createdAt"],
            properties: {
              text: {
                type: "string",
                maxLength: 3e3,
                maxGraphemes: 300,
                description: "The primary post content. May be an empty string, if there are embeds."
              },
              entities: {
                type: "array",
                description: "DEPRECATED: replaced by app.bsky.richtext.facet.",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#entity"
                }
              },
              facets: {
                type: "array",
                description: "Annotations of text (mentions, URLs, hashtags, etc)",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              reply: {
                type: "ref",
                ref: "lex:app.bsky.feed.post#replyRef"
              },
              embed: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images",
                  "lex:app.bsky.embed.external",
                  "lex:app.bsky.embed.record",
                  "lex:app.bsky.embed.recordWithMedia"
                ]
              },
              langs: {
                type: "array",
                description: "Indicates human language of post primary text content.",
                maxLength: 3,
                items: {
                  type: "string",
                  format: "language"
                }
              },
              labels: {
                type: "union",
                description: "Self-label values for this post. Effectively content warnings.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              tags: {
                type: "array",
                description: "Additional hashtags, in addition to any included in post text and facets.",
                maxLength: 8,
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              },
              createdAt: {
                type: "string",
                format: "datetime",
                description: "Client-declared timestamp when this post was originally created."
              }
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            },
            parent: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        entity: {
          type: "object",
          description: "Deprecated: use facets instead.",
          required: ["index", "type", "value"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.feed.post#textSlice"
            },
            type: {
              type: "string",
              description: "Expected values are 'mention' and 'link'."
            },
            value: {
              type: "string"
            }
          }
        },
        textSlice: {
          type: "object",
          description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
          required: ["start", "end"],
          properties: {
            start: {
              type: "integer",
              minimum: 0
            },
            end: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyFeedRepost: {
      lexicon: 1,
      id: "app.bsky.feed.repost",
      defs: {
        main: {
          description: "Record representing a 'repost' of an existing Bluesky post.",
          type: "record",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedSearchPosts: {
      lexicon: 1,
      id: "app.bsky.feed.searchPosts",
      defs: {
        main: {
          type: "query",
          description: "Find posts matching search criteria, returning views of those posts.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyFeedSendInteractions: {
      lexicon: 1,
      id: "app.bsky.feed.sendInteractions",
      defs: {
        main: {
          type: "procedure",
          description: "Send information about interactions with feed items back to the feed generator that served them.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["interactions"],
              properties: {
                interactions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#interaction"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    AppBskyFeedThreadgate: {
      lexicon: 1,
      id: "app.bsky.feed.threadgate",
      defs: {
        main: {
          type: "record",
          key: "tid",
          description: "Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository..",
          record: {
            type: "object",
            required: ["post", "createdAt"],
            properties: {
              post: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the post record."
              },
              allow: {
                type: "array",
                maxLength: 5,
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.threadgate#mentionRule",
                    "lex:app.bsky.feed.threadgate#followingRule",
                    "lex:app.bsky.feed.threadgate#listRule"
                  ]
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        mentionRule: {
          type: "object",
          description: "Allow replies from actors mentioned in your post.",
          properties: {}
        },
        followingRule: {
          type: "object",
          description: "Allow replies from actors you follow.",
          properties: {}
        },
        listRule: {
          type: "object",
          description: "Allow replies from actors on a list.",
          required: ["list"],
          properties: {
            list: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphBlock: {
      lexicon: 1,
      id: "app.bsky.graph.block",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "DID of the account to be blocked."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphDefs: {
      lexicon: 1,
      id: "app.bsky.graph.defs",
      defs: {
        listViewBasic: {
          type: "object",
          required: ["uri", "cid", "name", "purpose"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listView: {
          type: "object",
          required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listItemView: {
          type: "object",
          required: ["uri", "subject"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            subject: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        },
        starterPackView: {
          type: "object",
          required: ["uri", "cid", "record", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            list: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            listItemsSample: {
              type: "array",
              maxLength: 12,
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listItemView"
              }
            },
            feeds: {
              type: "array",
              maxLength: 3,
              items: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#generatorView"
              }
            },
            joinedWeekCount: {
              type: "integer",
              minimum: 0
            },
            joinedAllTimeCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        starterPackViewBasic: {
          type: "object",
          required: ["uri", "cid", "record", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            joinedWeekCount: {
              type: "integer",
              minimum: 0
            },
            joinedAllTimeCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listPurpose: {
          type: "string",
          knownValues: [
            "app.bsky.graph.defs#modlist",
            "app.bsky.graph.defs#curatelist",
            "app.bsky.graph.defs#referencelist"
          ]
        },
        modlist: {
          type: "token",
          description: "A list of actors to apply an aggregate moderation action (mute/block) on."
        },
        curatelist: {
          type: "token",
          description: "A list of actors used for curation purposes such as list feeds or interaction gating."
        },
        referencelist: {
          type: "token",
          description: "A list of actors used for only for reference purposes such as within a starter pack."
        },
        listViewerState: {
          type: "object",
          properties: {
            muted: {
              type: "boolean"
            },
            blocked: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        notFoundActor: {
          type: "object",
          description: "indicates that a handle or DID could not be resolved",
          required: ["actor", "notFound"],
          properties: {
            actor: {
              type: "string",
              format: "at-identifier"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        relationship: {
          type: "object",
          description: "lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object)",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            following: {
              type: "string",
              format: "at-uri",
              description: "if the actor follows this DID, this is the AT-URI of the follow record"
            },
            followedBy: {
              type: "string",
              format: "at-uri",
              description: "if the actor is followed by this DID, contains the AT-URI of the follow record"
            }
          }
        }
      }
    },
    AppBskyGraphFollow: {
      lexicon: 1,
      id: "app.bsky.graph.follow",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetActorStarterPacks: {
      lexicon: 1,
      id: "app.bsky.graph.getActorStarterPacks",
      defs: {
        main: {
          type: "query",
          description: "Get a list of starter packs created by the actor.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPacks"],
              properties: {
                cursor: {
                  type: "string"
                },
                starterPacks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Enumerates which accounts the requesting account is currently blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blocks"],
              properties: {
                cursor: {
                  type: "string"
                },
                blocks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollows: {
      lexicon: 1,
      id: "app.bsky.graph.getFollows",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which a specified account (actor) follows.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "follows"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                follows: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetKnownFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getKnownFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor) and are followed by the viewer.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetList: {
      lexicon: 1,
      id: "app.bsky.graph.getList",
      defs: {
        main: {
          type: "query",
          description: "Gets a 'view' (with additional context) of a specified list.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the list record to hydrate."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list", "items"],
              properties: {
                cursor: {
                  type: "string"
                },
                list: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listView"
                },
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listItemView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getListBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get mod lists that the requesting account (actor) is blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getListMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetLists: {
      lexicon: 1,
      id: "app.bsky.graph.getLists",
      defs: {
        main: {
          type: "query",
          description: "Enumerates the lists created by a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "The account (actor) to enumerate lists from."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["mutes"],
              properties: {
                cursor: {
                  type: "string"
                },
                mutes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetRelationships: {
      lexicon: 1,
      id: "app.bsky.graph.getRelationships",
      defs: {
        main: {
          type: "query",
          description: "Enumerates public relationships between one account, and a list of other accounts. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Primary account requesting relationships for."
              },
              others: {
                type: "array",
                description: "List of 'other' accounts to be related back to the primary.",
                maxLength: 30,
                items: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["relationships"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                relationships: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.graph.defs#relationship",
                      "lex:app.bsky.graph.defs#notFoundActor"
                    ]
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "ActorNotFound",
              description: "the primary actor at-identifier could not be resolved"
            }
          ]
        }
      }
    },
    AppBskyGraphGetStarterPack: {
      lexicon: 1,
      id: "app.bsky.graph.getStarterPack",
      defs: {
        main: {
          type: "query",
          description: "Gets a view of a starter pack.",
          parameters: {
            type: "params",
            required: ["starterPack"],
            properties: {
              starterPack: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the starter pack record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPack"],
              properties: {
                starterPack: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#starterPackView"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetStarterPacks: {
      lexicon: 1,
      id: "app.bsky.graph.getStarterPacks",
      defs: {
        main: {
          type: "query",
          description: "Get views for a list of starter packs.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPacks"],
              properties: {
                starterPacks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetSuggestedFollowsByActor: {
      lexicon: 1,
      id: "app.bsky.graph.getSuggestedFollowsByActor",
      defs: {
        main: {
          type: "query",
          description: "Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphList: {
      lexicon: 1,
      id: "app.bsky.graph.list",
      defs: {
        main: {
          type: "record",
          description: "Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "purpose", "createdAt"],
            properties: {
              purpose: {
                type: "ref",
                description: "Defines the purpose of the list (aka, moderation-oriented or curration-oriented)",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1,
                description: "Display name for list; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListblock: {
      lexicon: 1,
      id: "app.bsky.graph.listblock",
      defs: {
        main: {
          type: "record",
          description: "Record representing a block relationship against an entire an entire list of accounts (actors).",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the mod list record."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListitem: {
      lexicon: 1,
      id: "app.bsky.graph.listitem",
      defs: {
        main: {
          type: "record",
          description: "Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "list", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "The account which is included on the list."
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record (app.bsky.graph.list)."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.muteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.muteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteThread: {
      lexicon: 1,
      id: "app.bsky.graph.muteThread",
      defs: {
        main: {
          type: "procedure",
          description: "Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphStarterpack: {
      lexicon: 1,
      id: "app.bsky.graph.starterpack",
      defs: {
        main: {
          type: "record",
          description: "Record defining a starter pack of actors and feeds for new users.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "list", "createdAt"],
            properties: {
              name: {
                type: "string",
                maxGraphemes: 50,
                maxLength: 500,
                minLength: 1,
                description: "Display name for starter pack; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              feeds: {
                type: "array",
                maxLength: 3,
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.starterpack#feedItem"
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        feedItem: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified list of accounts. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteThread: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteThread",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified thread. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerDefs: {
      lexicon: 1,
      id: "app.bsky.labeler.defs",
      defs: {
        labelerView: {
          type: "object",
          required: ["uri", "cid", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewDetailed: {
          type: "object",
          required: ["uri", "cid", "creator", "policies", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            policies: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerPolicies"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        labelerPolicies: {
          type: "object",
          required: ["labelValues"],
          properties: {
            labelValues: {
              type: "array",
              description: "The label values which this labeler publishes. May include global or custom labels.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValue"
              }
            },
            labelValueDefinitions: {
              type: "array",
              description: "Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinition"
              }
            }
          }
        }
      }
    },
    AppBskyLabelerGetServices: {
      lexicon: 1,
      id: "app.bsky.labeler.getServices",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of labeler services.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              },
              detailed: {
                type: "boolean",
                default: !1
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["views"],
              properties: {
                views: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.labeler.defs#labelerView",
                      "lex:app.bsky.labeler.defs#labelerViewDetailed"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerService: {
      lexicon: 1,
      id: "app.bsky.labeler.service",
      defs: {
        main: {
          type: "record",
          description: "A declaration of the existence of labeler service.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["policies", "createdAt"],
            properties: {
              policies: {
                type: "ref",
                ref: "lex:app.bsky.labeler.defs#labelerPolicies"
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationGetUnreadCount: {
      lexicon: 1,
      id: "app.bsky.notification.getUnreadCount",
      defs: {
        main: {
          type: "query",
          description: "Count the number of unread notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              priority: {
                type: "boolean"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["count"],
              properties: {
                count: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationListNotifications: {
      lexicon: 1,
      id: "app.bsky.notification.listNotifications",
      defs: {
        main: {
          type: "query",
          description: "Enumerate notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              priority: {
                type: "boolean"
              },
              cursor: {
                type: "string"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["notifications"],
              properties: {
                cursor: {
                  type: "string"
                },
                notifications: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.notification.listNotifications#notification"
                  }
                },
                priority: {
                  type: "boolean"
                },
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        notification: {
          type: "object",
          required: [
            "uri",
            "cid",
            "author",
            "reason",
            "record",
            "isRead",
            "indexedAt"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            reason: {
              type: "string",
              description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', and 'starterpack-joined'.",
              knownValues: [
                "like",
                "repost",
                "follow",
                "mention",
                "reply",
                "quote",
                "starterpack-joined"
              ]
            },
            reasonSubject: {
              type: "string",
              format: "at-uri"
            },
            record: {
              type: "unknown"
            },
            isRead: {
              type: "boolean"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationPutPreferences: {
      lexicon: 1,
      id: "app.bsky.notification.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set notification-related preferences for an account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["priority"],
              properties: {
                priority: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationRegisterPush: {
      lexicon: 1,
      id: "app.bsky.notification.registerPush",
      defs: {
        main: {
          type: "procedure",
          description: "Register to receive push notifications, via a specified service, for the requesting account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["serviceDid", "token", "platform", "appId"],
              properties: {
                serviceDid: {
                  type: "string",
                  format: "did"
                },
                token: {
                  type: "string"
                },
                platform: {
                  type: "string",
                  knownValues: ["ios", "android", "web"]
                },
                appId: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationUpdateSeen: {
      lexicon: 1,
      id: "app.bsky.notification.updateSeen",
      defs: {
        main: {
          type: "procedure",
          description: "Notify server that the requesting account has seen notifications. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["seenAt"],
              properties: {
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    AppBskyRichtextFacet: {
      lexicon: 1,
      id: "app.bsky.richtext.facet",
      defs: {
        main: {
          type: "object",
          description: "Annotation of a sub-string within rich text.",
          required: ["index", "features"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.richtext.facet#byteSlice"
            },
            features: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.richtext.facet#mention",
                  "lex:app.bsky.richtext.facet#link",
                  "lex:app.bsky.richtext.facet#tag"
                ]
              }
            }
          }
        },
        mention: {
          type: "object",
          description: "Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        link: {
          type: "object",
          description: "Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            }
          }
        },
        tag: {
          type: "object",
          description: "Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags').",
          required: ["tag"],
          properties: {
            tag: {
              type: "string",
              maxLength: 640,
              maxGraphemes: 64
            }
          }
        },
        byteSlice: {
          type: "object",
          description: "Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.",
          required: ["byteStart", "byteEnd"],
          properties: {
            byteStart: {
              type: "integer",
              minimum: 0
            },
            byteEnd: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyUnspeccedDefs: {
      lexicon: 1,
      id: "app.bsky.unspecced.defs",
      defs: {
        skeletonSearchPost: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonSearchActor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetPopularFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.unspecced.getPopularFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "An unspecced view of globally popular feed generators.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              query: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetSuggestionsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.getSuggestionsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions",
          parameters: {
            type: "params",
            properties: {
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              relativeToDid: {
                type: "string",
                format: "did",
                description: "DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetTaggedSuggestions: {
      lexicon: 1,
      id: "app.bsky.unspecced.getTaggedSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggestions (feeds and users) tagged with categories",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.getTaggedSuggestions#suggestion"
                  }
                }
              }
            }
          }
        },
        suggestion: {
          type: "object",
          required: ["tag", "subjectType", "subject"],
          properties: {
            tag: {
              type: "string"
            },
            subjectType: {
              type: "string",
              knownValues: ["actor", "feed"]
            },
            subject: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyUnspeccedSearchActorsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchActorsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Actors (profile) search, returns only skeleton.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              typeahead: {
                type: "boolean",
                description: "If true, acts as fast/simple 'typeahead' query."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyUnspeccedSearchPostsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchPostsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Posts search, returns only skeleton",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    ChatBskyActorDeclaration: {
      lexicon: 1,
      id: "chat.bsky.actor.declaration",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky chat account.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["allowIncoming"],
            properties: {
              allowIncoming: {
                type: "string",
                knownValues: ["all", "none", "following"]
              }
            }
          }
        }
      }
    },
    ChatBskyActorDefs: {
      lexicon: 1,
      id: "chat.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            chatDisabled: {
              type: "boolean",
              description: "Set to true when the actor cannot actively participate in converations"
            }
          }
        }
      }
    },
    ChatBskyActorDeleteAccount: {
      lexicon: 1,
      id: "chat.bsky.actor.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    ChatBskyActorExportAccountData: {
      lexicon: 1,
      id: "chat.bsky.actor.exportAccountData",
      defs: {
        main: {
          type: "query",
          output: {
            encoding: "application/jsonl"
          }
        }
      }
    },
    ChatBskyConvoDefs: {
      lexicon: 1,
      id: "chat.bsky.convo.defs",
      defs: {
        messageRef: {
          type: "object",
          required: ["did", "messageId", "convoId"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            convoId: {
              type: "string"
            },
            messageId: {
              type: "string"
            }
          }
        },
        messageInput: {
          type: "object",
          required: ["text"],
          properties: {
            text: {
              type: "string",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            facets: {
              type: "array",
              description: "Annotations of text (mentions, URLs, hashtags, etc)",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            embed: {
              type: "union",
              refs: ["lex:app.bsky.embed.record"]
            }
          }
        },
        messageView: {
          type: "object",
          required: ["id", "rev", "text", "sender", "sentAt"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            text: {
              type: "string",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            facets: {
              type: "array",
              description: "Annotations of text (mentions, URLs, hashtags, etc)",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            embed: {
              type: "union",
              refs: ["lex:app.bsky.embed.record#view"]
            },
            sender: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageViewSender"
            },
            sentAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        deletedMessageView: {
          type: "object",
          required: ["id", "rev", "sender", "sentAt"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            sender: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageViewSender"
            },
            sentAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        messageViewSender: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        convoView: {
          type: "object",
          required: ["id", "rev", "members", "muted", "unreadCount"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            members: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:chat.bsky.actor.defs#profileViewBasic"
              }
            },
            lastMessage: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            },
            muted: {
              type: "boolean"
            },
            unreadCount: {
              type: "integer"
            }
          }
        },
        logBeginConvo: {
          type: "object",
          required: ["rev", "convoId"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            }
          }
        },
        logLeaveConvo: {
          type: "object",
          required: ["rev", "convoId"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            }
          }
        },
        logCreateMessage: {
          type: "object",
          required: ["rev", "convoId", "message"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            },
            message: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            }
          }
        },
        logDeleteMessage: {
          type: "object",
          required: ["rev", "convoId", "message"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            },
            message: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            }
          }
        }
      }
    },
    ChatBskyConvoDeleteMessageForSelf: {
      lexicon: 1,
      id: "chat.bsky.convo.deleteMessageForSelf",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "messageId"],
              properties: {
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#deletedMessageView"
            }
          }
        }
      }
    },
    ChatBskyConvoGetConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.getConvo",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["convoId"],
            properties: {
              convoId: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetConvoForMembers: {
      lexicon: 1,
      id: "chat.bsky.convo.getConvoForMembers",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["members"],
            properties: {
              members: {
                type: "array",
                minLength: 1,
                maxLength: 10,
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetLog: {
      lexicon: 1,
      id: "chat.bsky.convo.getLog",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: [],
            properties: {
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["logs"],
              properties: {
                cursor: {
                  type: "string"
                },
                logs: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#logBeginConvo",
                      "lex:chat.bsky.convo.defs#logLeaveConvo",
                      "lex:chat.bsky.convo.defs#logCreateMessage",
                      "lex:chat.bsky.convo.defs#logDeleteMessage"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetMessages: {
      lexicon: 1,
      id: "chat.bsky.convo.getMessages",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["convoId"],
            properties: {
              convoId: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["messages"],
              properties: {
                cursor: {
                  type: "string"
                },
                messages: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#messageView",
                      "lex:chat.bsky.convo.defs#deletedMessageView"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoLeaveConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.leaveConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "rev"],
              properties: {
                convoId: {
                  type: "string"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoListConvos: {
      lexicon: 1,
      id: "chat.bsky.convo.listConvos",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convos"],
              properties: {
                cursor: {
                  type: "string"
                },
                convos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoMuteConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.muteConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoSendMessage: {
      lexicon: 1,
      id: "chat.bsky.convo.sendMessage",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "message"],
              properties: {
                convoId: {
                  type: "string"
                },
                message: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageInput"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageView"
            }
          }
        }
      }
    },
    ChatBskyConvoSendMessageBatch: {
      lexicon: 1,
      id: "chat.bsky.convo.sendMessageBatch",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.sendMessageBatch#batchItem"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#messageView"
                  }
                }
              }
            }
          }
        },
        batchItem: {
          type: "object",
          required: ["convoId", "message"],
          properties: {
            convoId: {
              type: "string"
            },
            message: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageInput"
            }
          }
        }
      }
    },
    ChatBskyConvoUnmuteConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.unmuteConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoUpdateRead: {
      lexicon: 1,
      id: "chat.bsky.convo.updateRead",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyModerationGetActorMetadata: {
      lexicon: 1,
      id: "chat.bsky.moderation.getActorMetadata",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["day", "month", "all"],
              properties: {
                day: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                },
                month: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                },
                all: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                }
              }
            }
          }
        },
        metadata: {
          type: "object",
          required: [
            "messagesSent",
            "messagesReceived",
            "convos",
            "convosStarted"
          ],
          properties: {
            messagesSent: {
              type: "integer"
            },
            messagesReceived: {
              type: "integer"
            },
            convos: {
              type: "integer"
            },
            convosStarted: {
              type: "integer"
            }
          }
        }
      }
    },
    ChatBskyModerationGetMessageContext: {
      lexicon: 1,
      id: "chat.bsky.moderation.getMessageContext",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["messageId"],
            properties: {
              convoId: {
                type: "string",
                description: "Conversation that the message is from. NOTE: this field will eventually be required."
              },
              messageId: {
                type: "string"
              },
              before: {
                type: "integer",
                default: 5
              },
              after: {
                type: "integer",
                default: 5
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["messages"],
              properties: {
                messages: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#messageView",
                      "lex:chat.bsky.convo.defs#deletedMessageView"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyModerationUpdateActorAccess: {
      lexicon: 1,
      id: "chat.bsky.moderation.updateActorAccess",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor", "allowAccess"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                allowAccess: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationCreateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.createTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to create a new, re-usable communication (email for now) template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "contentMarkdown", "name"],
              properties: {
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                createdBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is creating the template."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDefs: {
      lexicon: 1,
      id: "tools.ozone.communication.defs",
      defs: {
        templateView: {
          type: "object",
          required: [
            "id",
            "name",
            "contentMarkdown",
            "disabled",
            "lastUpdatedBy",
            "createdAt",
            "updatedAt"
          ],
          properties: {
            id: {
              type: "string"
            },
            name: {
              type: "string",
              description: "Name of the template."
            },
            subject: {
              type: "string",
              description: "Content of the template, can contain markdown and variable placeholders."
            },
            contentMarkdown: {
              type: "string",
              description: "Subject of the message, used in emails."
            },
            disabled: {
              type: "boolean"
            },
            lastUpdatedBy: {
              type: "string",
              format: "did",
              description: "DID of the user who last updated the template."
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDeleteTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.deleteTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a communication template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationListTemplates: {
      lexicon: 1,
      id: "tools.ozone.communication.listTemplates",
      defs: {
        main: {
          type: "query",
          description: "Get list of all communication templates.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["communicationTemplates"],
              properties: {
                communicationTemplates: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.communication.defs#templateView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationUpdateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.updateTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string",
                  description: "ID of the template to be updated."
                },
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                updatedBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is updating the template."
                },
                disabled: {
                  type: "boolean"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneModerationDefs: {
      lexicon: 1,
      id: "tools.ozone.moderation.defs",
      defs: {
        modEventView: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobCids",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventUnmute",
                "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert",
                "lex:tools.ozone.moderation.defs#modEventTag"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef",
                "lex:chat.bsky.convo.defs#messageRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            creatorHandle: {
              type: "string"
            },
            subjectHandle: {
              type: "string"
            }
          }
        },
        modEventViewDetail: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobs",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventUnmute",
                "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert",
                "lex:tools.ozone.moderation.defs#modEventTag"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#repoView",
                "lex:tools.ozone.moderation.defs#repoViewNotFound",
                "lex:tools.ozone.moderation.defs#recordView",
                "lex:tools.ozone.moderation.defs#recordViewNotFound"
              ]
            },
            subjectBlobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        subjectStatusView: {
          type: "object",
          required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
          properties: {
            id: {
              type: "integer"
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            subjectRepoHandle: {
              type: "string"
            },
            updatedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the last update was made to the moderation status of the subject"
            },
            createdAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
            },
            reviewState: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectReviewState"
            },
            comment: {
              type: "string",
              description: "Sticky comment on the subject."
            },
            muteUntil: {
              type: "string",
              format: "datetime"
            },
            muteReportingUntil: {
              type: "string",
              format: "datetime"
            },
            lastReviewedBy: {
              type: "string",
              format: "did"
            },
            lastReviewedAt: {
              type: "string",
              format: "datetime"
            },
            lastReportedAt: {
              type: "string",
              format: "datetime"
            },
            lastAppealedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the author of the subject appealed a moderation action"
            },
            takendown: {
              type: "boolean"
            },
            appealed: {
              type: "boolean",
              description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
            },
            suspendUntil: {
              type: "string",
              format: "datetime"
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        subjectReviewState: {
          type: "string",
          knownValues: [
            "lex:tools.ozone.moderation.defs#reviewOpen",
            "lex:tools.ozone.moderation.defs#reviewEscalated",
            "lex:tools.ozone.moderation.defs#reviewClosed",
            "lex:tools.ozone.moderation.defs#reviewNone"
          ]
        },
        reviewOpen: {
          type: "token",
          description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
        },
        reviewEscalated: {
          type: "token",
          description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
        },
        reviewClosed: {
          type: "token",
          description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
        },
        reviewNone: {
          type: "token",
          description: "Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it"
        },
        modEventTakedown: {
          type: "object",
          description: "Take down a subject permanently or temporarily",
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the takedown should be in effect before automatically expiring."
            }
          }
        },
        modEventReverseTakedown: {
          type: "object",
          description: "Revert take down action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventResolveAppeal: {
          type: "object",
          description: "Resolve appeal on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe resolution."
            }
          }
        },
        modEventComment: {
          type: "object",
          description: "Add a comment to a subject",
          required: ["comment"],
          properties: {
            comment: {
              type: "string"
            },
            sticky: {
              type: "boolean",
              description: "Make the comment persistent on the subject"
            }
          }
        },
        modEventReport: {
          type: "object",
          description: "Report a subject",
          required: ["reportType"],
          properties: {
            comment: {
              type: "string"
            },
            isReporterMuted: {
              type: "boolean",
              description: "Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject."
            },
            reportType: {
              type: "ref",
              ref: "lex:com.atproto.moderation.defs#reasonType"
            }
          }
        },
        modEventLabel: {
          type: "object",
          description: "Apply/Negate labels on a subject",
          required: ["createLabelVals", "negateLabelVals"],
          properties: {
            comment: {
              type: "string"
            },
            createLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            },
            negateLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        modEventAcknowledge: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventEscalate: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventMute: {
          type: "object",
          description: "Mute incoming reports on a subject",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the subject should remain muted."
            }
          }
        },
        modEventUnmute: {
          type: "object",
          description: "Unmute action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventMuteReporter: {
          type: "object",
          description: "Mute incoming reports from an account",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the account should remain muted."
            }
          }
        },
        modEventUnmuteReporter: {
          type: "object",
          description: "Unmute incoming reports from an account",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventEmail: {
          type: "object",
          description: "Keep a log of outgoing email to a user",
          required: ["subjectLine"],
          properties: {
            subjectLine: {
              type: "string",
              description: "The subject line of the email sent to the user."
            },
            content: {
              type: "string",
              description: "The content of the email sent to the user."
            },
            comment: {
              type: "string",
              description: "Additional comment about the outgoing comm."
            }
          }
        },
        modEventDivert: {
          type: "object",
          description: "Divert a record's blobs to a 3rd party service for further scanning/tagging",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventTag: {
          type: "object",
          description: "Add/Remove a tag on a subject",
          required: ["add", "remove"],
          properties: {
            add: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be added to the subject. If already exists, won't be duplicated."
            },
            remove: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated."
            },
            comment: {
              type: "string",
              description: "Additional comment about added/removed tags."
            }
          }
        },
        repoView: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewDetail: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewNotFound: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        recordView: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobCids",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewDetail: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobs",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewNotFound: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        moderation: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        moderationDetail: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        blobView: {
          type: "object",
          required: ["cid", "mimeType", "size", "createdAt"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            mimeType: {
              type: "string"
            },
            size: {
              type: "integer"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            details: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#imageDetails",
                "lex:tools.ozone.moderation.defs#videoDetails"
              ]
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            }
          }
        },
        imageDetails: {
          type: "object",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            }
          }
        },
        videoDetails: {
          type: "object",
          required: ["width", "height", "length"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            },
            length: {
              type: "integer"
            }
          }
        }
      }
    },
    ToolsOzoneModerationEmitEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.emitEvent",
      defs: {
        main: {
          type: "procedure",
          description: "Take a moderation action on an actor.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["event", "subject", "createdBy"],
              properties: {
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventTag"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventView"
            }
          },
          errors: [
            {
              name: "SubjectHasAction"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.getEvent",
      defs: {
        main: {
          type: "query",
          description: "Get details about a moderation event.",
          parameters: {
            type: "params",
            required: ["id"],
            properties: {
              id: {
                type: "integer"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventViewDetail"
            }
          }
        }
      }
    },
    ToolsOzoneModerationGetRecord: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get details about a record.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
            }
          },
          errors: [
            {
              name: "RecordNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetRepo: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Get details about a repository.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationQueryEvents: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryEvents",
      defs: {
        main: {
          type: "query",
          description: "List moderation events related to a subject.",
          parameters: {
            type: "params",
            properties: {
              types: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned."
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"],
                description: "Sort direction for the events. Defaults to descending order of created at timestamp."
              },
              createdAfter: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created after a given timestamp"
              },
              createdBefore: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created before a given timestamp"
              },
              subject: {
                type: "string",
                format: "uri"
              },
              includeAllUserRecords: {
                type: "boolean",
                default: !1,
                description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              hasComment: {
                type: "boolean",
                description: "If true, only events with comments are returned"
              },
              comment: {
                type: "string",
                description: "If specified, only events with comments containing the keyword are returned"
              },
              addedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were added are returned"
              },
              removedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were removed are returned"
              },
              addedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were added are returned"
              },
              removedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were removed are returned"
              },
              reportTypes: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["events"],
              properties: {
                cursor: {
                  type: "string"
                },
                events: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#modEventView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationQueryStatuses: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryStatuses",
      defs: {
        main: {
          type: "query",
          description: "View moderation statuses of subjects (record or repo).",
          parameters: {
            type: "params",
            properties: {
              subject: {
                type: "string",
                format: "uri"
              },
              comment: {
                type: "string",
                description: "Search subjects by keyword from comments"
              },
              reportedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported after a given timestamp"
              },
              reportedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported before a given timestamp"
              },
              reviewedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed after a given timestamp"
              },
              reviewedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed before a given timestamp"
              },
              includeMuted: {
                type: "boolean",
                description: "By default, we don't include muted subjects in the results. Set this to true to include them."
              },
              onlyMuted: {
                type: "boolean",
                description: "When set to true, only muted subjects and reporters will be returned."
              },
              reviewState: {
                type: "string",
                description: "Specify when fetching subjects in a certain state"
              },
              ignoreSubjects: {
                type: "array",
                items: {
                  type: "string",
                  format: "uri"
                }
              },
              lastReviewedBy: {
                type: "string",
                format: "did",
                description: "Get all subject statuses that were reviewed by a specific moderator"
              },
              sortField: {
                type: "string",
                default: "lastReportedAt",
                enum: ["lastReviewedAt", "lastReportedAt"]
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"]
              },
              takendown: {
                type: "boolean",
                description: "Get subjects that were taken down"
              },
              appealed: {
                type: "boolean",
                description: "Get subjects in unresolved appealed status"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              tags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              excludeTags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subjectStatuses"],
              properties: {
                cursor: {
                  type: "string"
                },
                subjectStatuses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationSearchRepos: {
      lexicon: 1,
      id: "tools.ozone.moderation.searchRepos",
      defs: {
        main: {
          type: "query",
          description: "Find repositories based on a search term.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead"
              },
              q: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#repoView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneServerGetConfig: {
      lexicon: 1,
      id: "tools.ozone.server.getConfig",
      defs: {
        main: {
          type: "query",
          description: "Get details about ozone's server configuration.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                appview: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                pds: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                blobDivert: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                chat: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#viewerConfig"
                }
              }
            }
          }
        },
        serviceConfig: {
          type: "object",
          properties: {
            url: {
              type: "string",
              format: "uri"
            }
          }
        },
        viewerConfig: {
          type: "object",
          properties: {
            role: {
              type: "string",
              knownValues: [
                "tools.ozone.team.defs#roleAdmin",
                "tools.ozone.team.defs#roleModerator",
                "tools.ozone.team.defs#roleTriage"
              ]
            }
          }
        }
      }
    },
    ToolsOzoneTeamAddMember: {
      lexicon: 1,
      id: "tools.ozone.team.addMember",
      defs: {
        main: {
          type: "procedure",
          description: "Add a member to the ozone team. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "role"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.team.defs#member"
            }
          },
          errors: [
            {
              name: "MemberAlreadyExists",
              description: "Member already exists in the team."
            }
          ]
        }
      }
    },
    ToolsOzoneTeamDefs: {
      lexicon: 1,
      id: "tools.ozone.team.defs",
      defs: {
        member: {
          type: "object",
          required: ["did", "role"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            disabled: {
              type: "boolean"
            },
            profile: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            },
            lastUpdatedBy: {
              type: "string"
            },
            role: {
              type: "string",
              knownValues: [
                "lex:tools.ozone.team.defs#roleAdmin",
                "lex:tools.ozone.team.defs#roleModerator",
                "lex:tools.ozone.team.defs#roleTriage"
              ]
            }
          }
        },
        roleAdmin: {
          type: "token",
          description: "Admin role. Highest level of access, can perform all actions."
        },
        roleModerator: {
          type: "token",
          description: "Moderator role. Can perform most actions."
        },
        roleTriage: {
          type: "token",
          description: "Triage role. Mostly intended for monitoring and escalating issues."
        }
      }
    },
    ToolsOzoneTeamDeleteMember: {
      lexicon: 1,
      id: "tools.ozone.team.deleteMember",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a member from ozone team. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          errors: [
            {
              name: "MemberNotFound",
              description: "The member being deleted does not exist"
            },
            {
              name: "CannotDeleteSelf",
              description: "You can not delete yourself from the team"
            }
          ]
        }
      }
    },
    ToolsOzoneTeamListMembers: {
      lexicon: 1,
      id: "tools.ozone.team.listMembers",
      defs: {
        main: {
          type: "query",
          description: "List all members with access to the ozone service.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["members"],
              properties: {
                cursor: {
                  type: "string"
                },
                members: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.team.defs#member"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneTeamUpdateMember: {
      lexicon: 1,
      id: "tools.ozone.team.updateMember",
      defs: {
        main: {
          type: "procedure",
          description: "Update a member in the ozone service. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                disabled: {
                  type: "boolean"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.team.defs#member"
            }
          },
          errors: [
            {
              name: "MemberNotFound",
              description: "The member being updated does not exist in the team"
            }
          ]
        }
      }
    }
  }, t.schemas = Object.values(t.schemaDict), t.lexicons = new e.Lexicons(t.schemas), t.ids = {
    ComAtprotoAdminDefs: "com.atproto.admin.defs",
    ComAtprotoAdminDeleteAccount: "com.atproto.admin.deleteAccount",
    ComAtprotoAdminDisableAccountInvites: "com.atproto.admin.disableAccountInvites",
    ComAtprotoAdminDisableInviteCodes: "com.atproto.admin.disableInviteCodes",
    ComAtprotoAdminEnableAccountInvites: "com.atproto.admin.enableAccountInvites",
    ComAtprotoAdminGetAccountInfo: "com.atproto.admin.getAccountInfo",
    ComAtprotoAdminGetAccountInfos: "com.atproto.admin.getAccountInfos",
    ComAtprotoAdminGetInviteCodes: "com.atproto.admin.getInviteCodes",
    ComAtprotoAdminGetSubjectStatus: "com.atproto.admin.getSubjectStatus",
    ComAtprotoAdminSearchAccounts: "com.atproto.admin.searchAccounts",
    ComAtprotoAdminSendEmail: "com.atproto.admin.sendEmail",
    ComAtprotoAdminUpdateAccountEmail: "com.atproto.admin.updateAccountEmail",
    ComAtprotoAdminUpdateAccountHandle: "com.atproto.admin.updateAccountHandle",
    ComAtprotoAdminUpdateAccountPassword: "com.atproto.admin.updateAccountPassword",
    ComAtprotoAdminUpdateSubjectStatus: "com.atproto.admin.updateSubjectStatus",
    ComAtprotoIdentityGetRecommendedDidCredentials: "com.atproto.identity.getRecommendedDidCredentials",
    ComAtprotoIdentityRequestPlcOperationSignature: "com.atproto.identity.requestPlcOperationSignature",
    ComAtprotoIdentityResolveHandle: "com.atproto.identity.resolveHandle",
    ComAtprotoIdentitySignPlcOperation: "com.atproto.identity.signPlcOperation",
    ComAtprotoIdentitySubmitPlcOperation: "com.atproto.identity.submitPlcOperation",
    ComAtprotoIdentityUpdateHandle: "com.atproto.identity.updateHandle",
    ComAtprotoLabelDefs: "com.atproto.label.defs",
    ComAtprotoLabelQueryLabels: "com.atproto.label.queryLabels",
    ComAtprotoLabelSubscribeLabels: "com.atproto.label.subscribeLabels",
    ComAtprotoModerationCreateReport: "com.atproto.moderation.createReport",
    ComAtprotoModerationDefs: "com.atproto.moderation.defs",
    ComAtprotoRepoApplyWrites: "com.atproto.repo.applyWrites",
    ComAtprotoRepoCreateRecord: "com.atproto.repo.createRecord",
    ComAtprotoRepoDeleteRecord: "com.atproto.repo.deleteRecord",
    ComAtprotoRepoDescribeRepo: "com.atproto.repo.describeRepo",
    ComAtprotoRepoGetRecord: "com.atproto.repo.getRecord",
    ComAtprotoRepoImportRepo: "com.atproto.repo.importRepo",
    ComAtprotoRepoListMissingBlobs: "com.atproto.repo.listMissingBlobs",
    ComAtprotoRepoListRecords: "com.atproto.repo.listRecords",
    ComAtprotoRepoPutRecord: "com.atproto.repo.putRecord",
    ComAtprotoRepoStrongRef: "com.atproto.repo.strongRef",
    ComAtprotoRepoUploadBlob: "com.atproto.repo.uploadBlob",
    ComAtprotoServerActivateAccount: "com.atproto.server.activateAccount",
    ComAtprotoServerCheckAccountStatus: "com.atproto.server.checkAccountStatus",
    ComAtprotoServerConfirmEmail: "com.atproto.server.confirmEmail",
    ComAtprotoServerCreateAccount: "com.atproto.server.createAccount",
    ComAtprotoServerCreateAppPassword: "com.atproto.server.createAppPassword",
    ComAtprotoServerCreateInviteCode: "com.atproto.server.createInviteCode",
    ComAtprotoServerCreateInviteCodes: "com.atproto.server.createInviteCodes",
    ComAtprotoServerCreateSession: "com.atproto.server.createSession",
    ComAtprotoServerDeactivateAccount: "com.atproto.server.deactivateAccount",
    ComAtprotoServerDefs: "com.atproto.server.defs",
    ComAtprotoServerDeleteAccount: "com.atproto.server.deleteAccount",
    ComAtprotoServerDeleteSession: "com.atproto.server.deleteSession",
    ComAtprotoServerDescribeServer: "com.atproto.server.describeServer",
    ComAtprotoServerGetAccountInviteCodes: "com.atproto.server.getAccountInviteCodes",
    ComAtprotoServerGetServiceAuth: "com.atproto.server.getServiceAuth",
    ComAtprotoServerGetSession: "com.atproto.server.getSession",
    ComAtprotoServerListAppPasswords: "com.atproto.server.listAppPasswords",
    ComAtprotoServerRefreshSession: "com.atproto.server.refreshSession",
    ComAtprotoServerRequestAccountDelete: "com.atproto.server.requestAccountDelete",
    ComAtprotoServerRequestEmailConfirmation: "com.atproto.server.requestEmailConfirmation",
    ComAtprotoServerRequestEmailUpdate: "com.atproto.server.requestEmailUpdate",
    ComAtprotoServerRequestPasswordReset: "com.atproto.server.requestPasswordReset",
    ComAtprotoServerReserveSigningKey: "com.atproto.server.reserveSigningKey",
    ComAtprotoServerResetPassword: "com.atproto.server.resetPassword",
    ComAtprotoServerRevokeAppPassword: "com.atproto.server.revokeAppPassword",
    ComAtprotoServerUpdateEmail: "com.atproto.server.updateEmail",
    ComAtprotoSyncGetBlob: "com.atproto.sync.getBlob",
    ComAtprotoSyncGetBlocks: "com.atproto.sync.getBlocks",
    ComAtprotoSyncGetCheckout: "com.atproto.sync.getCheckout",
    ComAtprotoSyncGetHead: "com.atproto.sync.getHead",
    ComAtprotoSyncGetLatestCommit: "com.atproto.sync.getLatestCommit",
    ComAtprotoSyncGetRecord: "com.atproto.sync.getRecord",
    ComAtprotoSyncGetRepo: "com.atproto.sync.getRepo",
    ComAtprotoSyncGetRepoStatus: "com.atproto.sync.getRepoStatus",
    ComAtprotoSyncListBlobs: "com.atproto.sync.listBlobs",
    ComAtprotoSyncListRepos: "com.atproto.sync.listRepos",
    ComAtprotoSyncNotifyOfUpdate: "com.atproto.sync.notifyOfUpdate",
    ComAtprotoSyncRequestCrawl: "com.atproto.sync.requestCrawl",
    ComAtprotoSyncSubscribeRepos: "com.atproto.sync.subscribeRepos",
    ComAtprotoTempCheckSignupQueue: "com.atproto.temp.checkSignupQueue",
    ComAtprotoTempFetchLabels: "com.atproto.temp.fetchLabels",
    ComAtprotoTempRequestPhoneVerification: "com.atproto.temp.requestPhoneVerification",
    AppBskyActorDefs: "app.bsky.actor.defs",
    AppBskyActorGetPreferences: "app.bsky.actor.getPreferences",
    AppBskyActorGetProfile: "app.bsky.actor.getProfile",
    AppBskyActorGetProfiles: "app.bsky.actor.getProfiles",
    AppBskyActorGetSuggestions: "app.bsky.actor.getSuggestions",
    AppBskyActorProfile: "app.bsky.actor.profile",
    AppBskyActorPutPreferences: "app.bsky.actor.putPreferences",
    AppBskyActorSearchActors: "app.bsky.actor.searchActors",
    AppBskyActorSearchActorsTypeahead: "app.bsky.actor.searchActorsTypeahead",
    AppBskyEmbedExternal: "app.bsky.embed.external",
    AppBskyEmbedImages: "app.bsky.embed.images",
    AppBskyEmbedRecord: "app.bsky.embed.record",
    AppBskyEmbedRecordWithMedia: "app.bsky.embed.recordWithMedia",
    AppBskyFeedDefs: "app.bsky.feed.defs",
    AppBskyFeedDescribeFeedGenerator: "app.bsky.feed.describeFeedGenerator",
    AppBskyFeedGenerator: "app.bsky.feed.generator",
    AppBskyFeedGetActorFeeds: "app.bsky.feed.getActorFeeds",
    AppBskyFeedGetActorLikes: "app.bsky.feed.getActorLikes",
    AppBskyFeedGetAuthorFeed: "app.bsky.feed.getAuthorFeed",
    AppBskyFeedGetFeed: "app.bsky.feed.getFeed",
    AppBskyFeedGetFeedGenerator: "app.bsky.feed.getFeedGenerator",
    AppBskyFeedGetFeedGenerators: "app.bsky.feed.getFeedGenerators",
    AppBskyFeedGetFeedSkeleton: "app.bsky.feed.getFeedSkeleton",
    AppBskyFeedGetLikes: "app.bsky.feed.getLikes",
    AppBskyFeedGetListFeed: "app.bsky.feed.getListFeed",
    AppBskyFeedGetPostThread: "app.bsky.feed.getPostThread",
    AppBskyFeedGetPosts: "app.bsky.feed.getPosts",
    AppBskyFeedGetRepostedBy: "app.bsky.feed.getRepostedBy",
    AppBskyFeedGetSuggestedFeeds: "app.bsky.feed.getSuggestedFeeds",
    AppBskyFeedGetTimeline: "app.bsky.feed.getTimeline",
    AppBskyFeedLike: "app.bsky.feed.like",
    AppBskyFeedPost: "app.bsky.feed.post",
    AppBskyFeedRepost: "app.bsky.feed.repost",
    AppBskyFeedSearchPosts: "app.bsky.feed.searchPosts",
    AppBskyFeedSendInteractions: "app.bsky.feed.sendInteractions",
    AppBskyFeedThreadgate: "app.bsky.feed.threadgate",
    AppBskyGraphBlock: "app.bsky.graph.block",
    AppBskyGraphDefs: "app.bsky.graph.defs",
    AppBskyGraphFollow: "app.bsky.graph.follow",
    AppBskyGraphGetActorStarterPacks: "app.bsky.graph.getActorStarterPacks",
    AppBskyGraphGetBlocks: "app.bsky.graph.getBlocks",
    AppBskyGraphGetFollowers: "app.bsky.graph.getFollowers",
    AppBskyGraphGetFollows: "app.bsky.graph.getFollows",
    AppBskyGraphGetKnownFollowers: "app.bsky.graph.getKnownFollowers",
    AppBskyGraphGetList: "app.bsky.graph.getList",
    AppBskyGraphGetListBlocks: "app.bsky.graph.getListBlocks",
    AppBskyGraphGetListMutes: "app.bsky.graph.getListMutes",
    AppBskyGraphGetLists: "app.bsky.graph.getLists",
    AppBskyGraphGetMutes: "app.bsky.graph.getMutes",
    AppBskyGraphGetRelationships: "app.bsky.graph.getRelationships",
    AppBskyGraphGetStarterPack: "app.bsky.graph.getStarterPack",
    AppBskyGraphGetStarterPacks: "app.bsky.graph.getStarterPacks",
    AppBskyGraphGetSuggestedFollowsByActor: "app.bsky.graph.getSuggestedFollowsByActor",
    AppBskyGraphList: "app.bsky.graph.list",
    AppBskyGraphListblock: "app.bsky.graph.listblock",
    AppBskyGraphListitem: "app.bsky.graph.listitem",
    AppBskyGraphMuteActor: "app.bsky.graph.muteActor",
    AppBskyGraphMuteActorList: "app.bsky.graph.muteActorList",
    AppBskyGraphMuteThread: "app.bsky.graph.muteThread",
    AppBskyGraphStarterpack: "app.bsky.graph.starterpack",
    AppBskyGraphUnmuteActor: "app.bsky.graph.unmuteActor",
    AppBskyGraphUnmuteActorList: "app.bsky.graph.unmuteActorList",
    AppBskyGraphUnmuteThread: "app.bsky.graph.unmuteThread",
    AppBskyLabelerDefs: "app.bsky.labeler.defs",
    AppBskyLabelerGetServices: "app.bsky.labeler.getServices",
    AppBskyLabelerService: "app.bsky.labeler.service",
    AppBskyNotificationGetUnreadCount: "app.bsky.notification.getUnreadCount",
    AppBskyNotificationListNotifications: "app.bsky.notification.listNotifications",
    AppBskyNotificationPutPreferences: "app.bsky.notification.putPreferences",
    AppBskyNotificationRegisterPush: "app.bsky.notification.registerPush",
    AppBskyNotificationUpdateSeen: "app.bsky.notification.updateSeen",
    AppBskyRichtextFacet: "app.bsky.richtext.facet",
    AppBskyUnspeccedDefs: "app.bsky.unspecced.defs",
    AppBskyUnspeccedGetPopularFeedGenerators: "app.bsky.unspecced.getPopularFeedGenerators",
    AppBskyUnspeccedGetSuggestionsSkeleton: "app.bsky.unspecced.getSuggestionsSkeleton",
    AppBskyUnspeccedGetTaggedSuggestions: "app.bsky.unspecced.getTaggedSuggestions",
    AppBskyUnspeccedSearchActorsSkeleton: "app.bsky.unspecced.searchActorsSkeleton",
    AppBskyUnspeccedSearchPostsSkeleton: "app.bsky.unspecced.searchPostsSkeleton",
    ChatBskyActorDeclaration: "chat.bsky.actor.declaration",
    ChatBskyActorDefs: "chat.bsky.actor.defs",
    ChatBskyActorDeleteAccount: "chat.bsky.actor.deleteAccount",
    ChatBskyActorExportAccountData: "chat.bsky.actor.exportAccountData",
    ChatBskyConvoDefs: "chat.bsky.convo.defs",
    ChatBskyConvoDeleteMessageForSelf: "chat.bsky.convo.deleteMessageForSelf",
    ChatBskyConvoGetConvo: "chat.bsky.convo.getConvo",
    ChatBskyConvoGetConvoForMembers: "chat.bsky.convo.getConvoForMembers",
    ChatBskyConvoGetLog: "chat.bsky.convo.getLog",
    ChatBskyConvoGetMessages: "chat.bsky.convo.getMessages",
    ChatBskyConvoLeaveConvo: "chat.bsky.convo.leaveConvo",
    ChatBskyConvoListConvos: "chat.bsky.convo.listConvos",
    ChatBskyConvoMuteConvo: "chat.bsky.convo.muteConvo",
    ChatBskyConvoSendMessage: "chat.bsky.convo.sendMessage",
    ChatBskyConvoSendMessageBatch: "chat.bsky.convo.sendMessageBatch",
    ChatBskyConvoUnmuteConvo: "chat.bsky.convo.unmuteConvo",
    ChatBskyConvoUpdateRead: "chat.bsky.convo.updateRead",
    ChatBskyModerationGetActorMetadata: "chat.bsky.moderation.getActorMetadata",
    ChatBskyModerationGetMessageContext: "chat.bsky.moderation.getMessageContext",
    ChatBskyModerationUpdateActorAccess: "chat.bsky.moderation.updateActorAccess",
    ToolsOzoneCommunicationCreateTemplate: "tools.ozone.communication.createTemplate",
    ToolsOzoneCommunicationDefs: "tools.ozone.communication.defs",
    ToolsOzoneCommunicationDeleteTemplate: "tools.ozone.communication.deleteTemplate",
    ToolsOzoneCommunicationListTemplates: "tools.ozone.communication.listTemplates",
    ToolsOzoneCommunicationUpdateTemplate: "tools.ozone.communication.updateTemplate",
    ToolsOzoneModerationDefs: "tools.ozone.moderation.defs",
    ToolsOzoneModerationEmitEvent: "tools.ozone.moderation.emitEvent",
    ToolsOzoneModerationGetEvent: "tools.ozone.moderation.getEvent",
    ToolsOzoneModerationGetRecord: "tools.ozone.moderation.getRecord",
    ToolsOzoneModerationGetRepo: "tools.ozone.moderation.getRepo",
    ToolsOzoneModerationQueryEvents: "tools.ozone.moderation.queryEvents",
    ToolsOzoneModerationQueryStatuses: "tools.ozone.moderation.queryStatuses",
    ToolsOzoneModerationSearchRepos: "tools.ozone.moderation.searchRepos",
    ToolsOzoneServerGetConfig: "tools.ozone.server.getConfig",
    ToolsOzoneTeamAddMember: "tools.ozone.team.addMember",
    ToolsOzoneTeamDefs: "tools.ozone.team.defs",
    ToolsOzoneTeamDeleteMember: "tools.ozone.team.deleteMember",
    ToolsOzoneTeamListMembers: "tools.ozone.team.listMembers",
    ToolsOzoneTeamUpdateMember: "tools.ozone.team.updateMember"
  };
})(Le);
var Da = {};
Object.defineProperty(Da, "__esModule", { value: !0 });
Da.toKnownErr = void 0;
const zv = q;
function Xv(t) {
  return t instanceof zv.XRPCError, t;
}
Da.toKnownErr = Xv;
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.toKnownErr = void 0;
const Hv = q;
function Zv(t) {
  return t instanceof Hv.XRPCError, t;
}
Pa.toKnownErr = Zv;
var Ba = {};
Object.defineProperty(Ba, "__esModule", { value: !0 });
Ba.toKnownErr = void 0;
const Wv = q;
function Yv(t) {
  return t instanceof Wv.XRPCError, t;
}
Ba.toKnownErr = Yv;
var Ia = {};
Object.defineProperty(Ia, "__esModule", { value: !0 });
Ia.toKnownErr = void 0;
const Jv = q;
function Qv(t) {
  return t instanceof Jv.XRPCError, t;
}
Ia.toKnownErr = Qv;
var Ua = {};
Object.defineProperty(Ua, "__esModule", { value: !0 });
Ua.toKnownErr = void 0;
const eR = q;
function tR(t) {
  return t instanceof eR.XRPCError, t;
}
Ua.toKnownErr = tR;
var Oa = {};
Object.defineProperty(Oa, "__esModule", { value: !0 });
Oa.toKnownErr = void 0;
const rR = q;
function iR(t) {
  return t instanceof rR.XRPCError, t;
}
Oa.toKnownErr = iR;
var Ka = {};
Object.defineProperty(Ka, "__esModule", { value: !0 });
Ka.toKnownErr = void 0;
const nR = q;
function sR(t) {
  return t instanceof nR.XRPCError, t;
}
Ka.toKnownErr = sR;
var Ma = {};
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.toKnownErr = void 0;
const aR = q;
function oR(t) {
  return t instanceof aR.XRPCError, t;
}
Ma.toKnownErr = oR;
var Na = {};
Object.defineProperty(Na, "__esModule", { value: !0 });
Na.toKnownErr = void 0;
const lR = q;
function uR(t) {
  return t instanceof lR.XRPCError, t;
}
Na.toKnownErr = uR;
var Va = {};
Object.defineProperty(Va, "__esModule", { value: !0 });
Va.toKnownErr = void 0;
const cR = q;
function dR(t) {
  return t instanceof cR.XRPCError, t;
}
Va.toKnownErr = dR;
var ja = {};
Object.defineProperty(ja, "__esModule", { value: !0 });
ja.toKnownErr = void 0;
const fR = q;
function pR(t) {
  return t instanceof fR.XRPCError, t;
}
ja.toKnownErr = pR;
var Fa = {};
Object.defineProperty(Fa, "__esModule", { value: !0 });
Fa.toKnownErr = void 0;
const hR = q;
function mR(t) {
  return t instanceof hR.XRPCError, t;
}
Fa.toKnownErr = mR;
var $a = {};
Object.defineProperty($a, "__esModule", { value: !0 });
$a.toKnownErr = void 0;
const yR = q;
function bR(t) {
  return t instanceof yR.XRPCError, t;
}
$a.toKnownErr = bR;
var Ga = {};
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.toKnownErr = void 0;
const gR = q;
function xR(t) {
  return t instanceof gR.XRPCError, t;
}
Ga.toKnownErr = xR;
var qa = {};
Object.defineProperty(qa, "__esModule", { value: !0 });
qa.toKnownErr = void 0;
const ER = q;
function vR(t) {
  return t instanceof ER.XRPCError, t;
}
qa.toKnownErr = vR;
var za = {};
Object.defineProperty(za, "__esModule", { value: !0 });
za.toKnownErr = void 0;
const RR = q;
function AR(t) {
  return t instanceof RR.XRPCError, t;
}
za.toKnownErr = AR;
var Xa = {};
Object.defineProperty(Xa, "__esModule", { value: !0 });
Xa.toKnownErr = void 0;
const _R = q;
function wR(t) {
  return t instanceof _R.XRPCError, t;
}
Xa.toKnownErr = wR;
var Ha = {};
Object.defineProperty(Ha, "__esModule", { value: !0 });
Ha.toKnownErr = void 0;
const TR = q;
function CR(t) {
  return t instanceof TR.XRPCError, t;
}
Ha.toKnownErr = CR;
var Za = {};
Object.defineProperty(Za, "__esModule", { value: !0 });
Za.toKnownErr = void 0;
const SR = q;
function LR(t) {
  return t instanceof SR.XRPCError, t;
}
Za.toKnownErr = LR;
var Wa = {};
Object.defineProperty(Wa, "__esModule", { value: !0 });
Wa.toKnownErr = void 0;
const kR = q;
function DR(t) {
  return t instanceof kR.XRPCError, t;
}
Wa.toKnownErr = DR;
var Ya = {};
Object.defineProperty(Ya, "__esModule", { value: !0 });
Ya.toKnownErr = void 0;
const PR = q;
function BR(t) {
  return t instanceof PR.XRPCError, t;
}
Ya.toKnownErr = BR;
var Ja = {};
Object.defineProperty(Ja, "__esModule", { value: !0 });
Ja.toKnownErr = void 0;
const IR = q;
function UR(t) {
  return t instanceof IR.XRPCError, t;
}
Ja.toKnownErr = UR;
var St = {}, we = {};
Object.defineProperty(we, "__esModule", { value: !0 });
we.hasProp = we.isObj = void 0;
function OR(t) {
  return typeof t == "object" && t !== null;
}
we.isObj = OR;
function KR(t, e) {
  return e in t;
}
we.hasProp = KR;
Object.defineProperty(St, "__esModule", { value: !0 });
St.validateDelete = St.isDelete = St.validateUpdate = St.isUpdate = St.validateCreate = St.isCreate = St.toKnownErr = St.InvalidSwapError = void 0;
const Zp = q, ws = we, Zc = Le;
let Wp = class extends Zp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
St.InvalidSwapError = Wp;
function MR(t) {
  return t instanceof Zp.XRPCError && t.error === "InvalidSwap" ? new Wp(t) : t;
}
St.toKnownErr = MR;
function NR(t) {
  return (0, ws.isObj)(t) && (0, ws.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#create";
}
St.isCreate = NR;
function VR(t) {
  return Zc.lexicons.validate("com.atproto.repo.applyWrites#create", t);
}
St.validateCreate = VR;
function jR(t) {
  return (0, ws.isObj)(t) && (0, ws.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#update";
}
St.isUpdate = jR;
function FR(t) {
  return Zc.lexicons.validate("com.atproto.repo.applyWrites#update", t);
}
St.validateUpdate = FR;
function $R(t) {
  return (0, ws.isObj)(t) && (0, ws.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#delete";
}
St.isDelete = $R;
function GR(t) {
  return Zc.lexicons.validate("com.atproto.repo.applyWrites#delete", t);
}
St.validateDelete = GR;
var Nn = {};
Object.defineProperty(Nn, "__esModule", { value: !0 });
Nn.toKnownErr = Nn.InvalidSwapError = void 0;
const Yp = q;
let Jp = class extends Yp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Nn.InvalidSwapError = Jp;
function qR(t) {
  return t instanceof Yp.XRPCError && t.error === "InvalidSwap" ? new Jp(t) : t;
}
Nn.toKnownErr = qR;
var Vn = {};
Object.defineProperty(Vn, "__esModule", { value: !0 });
Vn.toKnownErr = Vn.InvalidSwapError = void 0;
const Qp = q;
let eh = class extends Qp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Vn.InvalidSwapError = eh;
function zR(t) {
  return t instanceof Qp.XRPCError && t.error === "InvalidSwap" ? new eh(t) : t;
}
Vn.toKnownErr = zR;
var Qa = {};
Object.defineProperty(Qa, "__esModule", { value: !0 });
Qa.toKnownErr = void 0;
const XR = q;
function HR(t) {
  return t instanceof XR.XRPCError, t;
}
Qa.toKnownErr = HR;
var eo = {};
Object.defineProperty(eo, "__esModule", { value: !0 });
eo.toKnownErr = void 0;
const ZR = q;
function WR(t) {
  return t instanceof ZR.XRPCError, t;
}
eo.toKnownErr = WR;
var to = {};
Object.defineProperty(to, "__esModule", { value: !0 });
to.toKnownErr = void 0;
const YR = q;
function JR(t) {
  return t instanceof YR.XRPCError, t;
}
to.toKnownErr = JR;
var Ni = {};
Object.defineProperty(Ni, "__esModule", { value: !0 });
Ni.validateRecordBlob = Ni.isRecordBlob = Ni.toKnownErr = void 0;
const QR = q, Vd = we, eA = Le;
function tA(t) {
  return t instanceof QR.XRPCError, t;
}
Ni.toKnownErr = tA;
function rA(t) {
  return (0, Vd.isObj)(t) && (0, Vd.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listMissingBlobs#recordBlob";
}
Ni.isRecordBlob = rA;
function iA(t) {
  return eA.lexicons.validate("com.atproto.repo.listMissingBlobs#recordBlob", t);
}
Ni.validateRecordBlob = iA;
var Vi = {};
Object.defineProperty(Vi, "__esModule", { value: !0 });
Vi.validateRecord = Vi.isRecord = Vi.toKnownErr = void 0;
const nA = q, jd = we, sA = Le;
function aA(t) {
  return t instanceof nA.XRPCError, t;
}
Vi.toKnownErr = aA;
function oA(t) {
  return (0, jd.isObj)(t) && (0, jd.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listRecords#record";
}
Vi.isRecord = oA;
function lA(t) {
  return sA.lexicons.validate("com.atproto.repo.listRecords#record", t);
}
Vi.validateRecord = lA;
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.toKnownErr = jn.InvalidSwapError = void 0;
const th = q;
class rh extends th.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
jn.InvalidSwapError = rh;
function uA(t) {
  return t instanceof th.XRPCError && t.error === "InvalidSwap" ? new rh(t) : t;
}
jn.toKnownErr = uA;
var ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
ro.toKnownErr = void 0;
const cA = q;
function dA(t) {
  return t instanceof cA.XRPCError, t;
}
ro.toKnownErr = dA;
var io = {};
Object.defineProperty(io, "__esModule", { value: !0 });
io.toKnownErr = void 0;
const fA = q;
function pA(t) {
  return t instanceof fA.XRPCError, t;
}
io.toKnownErr = pA;
var no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
no.toKnownErr = void 0;
const hA = q;
function mA(t) {
  return t instanceof hA.XRPCError, t;
}
no.toKnownErr = mA;
var Rr = {};
Object.defineProperty(Rr, "__esModule", { value: !0 });
Rr.toKnownErr = Rr.InvalidEmailError = Rr.InvalidTokenError = Rr.ExpiredTokenError = Rr.AccountNotFoundError = void 0;
const so = q;
class ih extends so.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Rr.AccountNotFoundError = ih;
let nh = class extends so.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Rr.ExpiredTokenError = nh;
let sh = class extends so.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Rr.InvalidTokenError = sh;
class ah extends so.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Rr.InvalidEmailError = ah;
function yA(t) {
  if (t instanceof so.XRPCError) {
    if (t.error === "AccountNotFound")
      return new ih(t);
    if (t.error === "ExpiredToken")
      return new nh(t);
    if (t.error === "InvalidToken")
      return new sh(t);
    if (t.error === "InvalidEmail")
      return new ah(t);
  }
  return t;
}
Rr.toKnownErr = yA;
var Lt = {};
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.toKnownErr = Lt.IncompatibleDidDocError = Lt.UnresolvableDidError = Lt.UnsupportedDomainError = Lt.HandleNotAvailableError = Lt.InvalidInviteCodeError = Lt.InvalidPasswordError = Lt.InvalidHandleError = void 0;
const _n = q;
class oh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lt.InvalidHandleError = oh;
class lh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lt.InvalidPasswordError = lh;
class uh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lt.InvalidInviteCodeError = uh;
class ch extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lt.HandleNotAvailableError = ch;
class dh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lt.UnsupportedDomainError = dh;
class fh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lt.UnresolvableDidError = fh;
class ph extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lt.IncompatibleDidDocError = ph;
function bA(t) {
  if (t instanceof _n.XRPCError) {
    if (t.error === "InvalidHandle")
      return new oh(t);
    if (t.error === "InvalidPassword")
      return new lh(t);
    if (t.error === "InvalidInviteCode")
      return new uh(t);
    if (t.error === "HandleNotAvailable")
      return new ch(t);
    if (t.error === "UnsupportedDomain")
      return new dh(t);
    if (t.error === "UnresolvableDid")
      return new fh(t);
    if (t.error === "IncompatibleDidDoc")
      return new ph(t);
  }
  return t;
}
Lt.toKnownErr = bA;
var Vr = {};
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.validateAppPassword = Vr.isAppPassword = Vr.toKnownErr = Vr.AccountTakedownError = void 0;
const hh = q, Fd = we, gA = Le;
let mh = class extends hh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Vr.AccountTakedownError = mh;
function xA(t) {
  return t instanceof hh.XRPCError && t.error === "AccountTakedown" ? new mh(t) : t;
}
Vr.toKnownErr = xA;
function EA(t) {
  return (0, Fd.isObj)(t) && (0, Fd.hasProp)(t, "$type") && t.$type === "com.atproto.server.createAppPassword#appPassword";
}
Vr.isAppPassword = EA;
function vA(t) {
  return gA.lexicons.validate("com.atproto.server.createAppPassword#appPassword", t);
}
Vr.validateAppPassword = vA;
var ao = {};
Object.defineProperty(ao, "__esModule", { value: !0 });
ao.toKnownErr = void 0;
const RA = q;
function AA(t) {
  return t instanceof RA.XRPCError, t;
}
ao.toKnownErr = AA;
var ji = {};
Object.defineProperty(ji, "__esModule", { value: !0 });
ji.validateAccountCodes = ji.isAccountCodes = ji.toKnownErr = void 0;
const _A = q, $d = we, wA = Le;
function TA(t) {
  return t instanceof _A.XRPCError, t;
}
ji.toKnownErr = TA;
function CA(t) {
  return (0, $d.isObj)(t) && (0, $d.hasProp)(t, "$type") && t.$type === "com.atproto.server.createInviteCodes#accountCodes";
}
ji.isAccountCodes = CA;
function SA(t) {
  return wA.lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", t);
}
ji.validateAccountCodes = SA;
var Fi = {};
Object.defineProperty(Fi, "__esModule", { value: !0 });
Fi.toKnownErr = Fi.AuthFactorTokenRequiredError = Fi.AccountTakedownError = void 0;
const Wc = q;
let yh = class extends Wc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Fi.AccountTakedownError = yh;
class bh extends Wc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fi.AuthFactorTokenRequiredError = bh;
function LA(t) {
  if (t instanceof Wc.XRPCError) {
    if (t.error === "AccountTakedown")
      return new yh(t);
    if (t.error === "AuthFactorTokenRequired")
      return new bh(t);
  }
  return t;
}
Fi.toKnownErr = LA;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
oo.toKnownErr = void 0;
const kA = q;
function DA(t) {
  return t instanceof kA.XRPCError, t;
}
oo.toKnownErr = DA;
var $i = {};
Object.defineProperty($i, "__esModule", { value: !0 });
$i.toKnownErr = $i.InvalidTokenError = $i.ExpiredTokenError = void 0;
const Yc = q;
let gh = class extends Yc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
$i.ExpiredTokenError = gh;
let xh = class extends Yc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
$i.InvalidTokenError = xh;
function PA(t) {
  if (t instanceof Yc.XRPCError) {
    if (t.error === "ExpiredToken")
      return new gh(t);
    if (t.error === "InvalidToken")
      return new xh(t);
  }
  return t;
}
$i.toKnownErr = PA;
var lo = {};
Object.defineProperty(lo, "__esModule", { value: !0 });
lo.toKnownErr = void 0;
const BA = q;
function IA(t) {
  return t instanceof BA.XRPCError, t;
}
lo.toKnownErr = IA;
var Ar = {};
Object.defineProperty(Ar, "__esModule", { value: !0 });
Ar.validateContact = Ar.isContact = Ar.validateLinks = Ar.isLinks = Ar.toKnownErr = void 0;
const UA = q, vu = we, Eh = Le;
function OA(t) {
  return t instanceof UA.XRPCError, t;
}
Ar.toKnownErr = OA;
function KA(t) {
  return (0, vu.isObj)(t) && (0, vu.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#links";
}
Ar.isLinks = KA;
function MA(t) {
  return Eh.lexicons.validate("com.atproto.server.describeServer#links", t);
}
Ar.validateLinks = MA;
function NA(t) {
  return (0, vu.isObj)(t) && (0, vu.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#contact";
}
Ar.isContact = NA;
function VA(t) {
  return Eh.lexicons.validate("com.atproto.server.describeServer#contact", t);
}
Ar.validateContact = VA;
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: !0 });
Fn.toKnownErr = Fn.DuplicateCreateError = void 0;
const vh = q;
class Rh extends vh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fn.DuplicateCreateError = Rh;
function jA(t) {
  return t instanceof vh.XRPCError && t.error === "DuplicateCreate" ? new Rh(t) : t;
}
Fn.toKnownErr = jA;
var $n = {};
Object.defineProperty($n, "__esModule", { value: !0 });
$n.toKnownErr = $n.BadExpirationError = void 0;
const Ah = q;
class _h extends Ah.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
$n.BadExpirationError = _h;
function FA(t) {
  return t instanceof Ah.XRPCError && t.error === "BadExpiration" ? new _h(t) : t;
}
$n.toKnownErr = FA;
var uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.toKnownErr = void 0;
const $A = q;
function GA(t) {
  return t instanceof $A.XRPCError, t;
}
uo.toKnownErr = GA;
var jr = {};
Object.defineProperty(jr, "__esModule", { value: !0 });
jr.validateAppPassword = jr.isAppPassword = jr.toKnownErr = jr.AccountTakedownError = void 0;
const wh = q, Gd = we, qA = Le;
let Th = class extends wh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
jr.AccountTakedownError = Th;
function zA(t) {
  return t instanceof wh.XRPCError && t.error === "AccountTakedown" ? new Th(t) : t;
}
jr.toKnownErr = zA;
function XA(t) {
  return (0, Gd.isObj)(t) && (0, Gd.hasProp)(t, "$type") && t.$type === "com.atproto.server.listAppPasswords#appPassword";
}
jr.isAppPassword = XA;
function HA(t) {
  return qA.lexicons.validate("com.atproto.server.listAppPasswords#appPassword", t);
}
jr.validateAppPassword = HA;
var Gn = {};
Object.defineProperty(Gn, "__esModule", { value: !0 });
Gn.toKnownErr = Gn.AccountTakedownError = void 0;
const Ch = q;
class Sh extends Ch.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Gn.AccountTakedownError = Sh;
function ZA(t) {
  return t instanceof Ch.XRPCError && t.error === "AccountTakedown" ? new Sh(t) : t;
}
Gn.toKnownErr = ZA;
var co = {};
Object.defineProperty(co, "__esModule", { value: !0 });
co.toKnownErr = void 0;
const WA = q;
function YA(t) {
  return t instanceof WA.XRPCError, t;
}
co.toKnownErr = YA;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.toKnownErr = void 0;
const JA = q;
function QA(t) {
  return t instanceof JA.XRPCError, t;
}
fo.toKnownErr = QA;
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
po.toKnownErr = void 0;
const e_ = q;
function t_(t) {
  return t instanceof e_.XRPCError, t;
}
po.toKnownErr = t_;
var ho = {};
Object.defineProperty(ho, "__esModule", { value: !0 });
ho.toKnownErr = void 0;
const r_ = q;
function i_(t) {
  return t instanceof r_.XRPCError, t;
}
ho.toKnownErr = i_;
var mo = {};
Object.defineProperty(mo, "__esModule", { value: !0 });
mo.toKnownErr = void 0;
const n_ = q;
function s_(t) {
  return t instanceof n_.XRPCError, t;
}
mo.toKnownErr = s_;
var Gi = {};
Object.defineProperty(Gi, "__esModule", { value: !0 });
Gi.toKnownErr = Gi.InvalidTokenError = Gi.ExpiredTokenError = void 0;
const Jc = q;
let Lh = class extends Jc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Gi.ExpiredTokenError = Lh;
let kh = class extends Jc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Gi.InvalidTokenError = kh;
function a_(t) {
  if (t instanceof Jc.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Lh(t);
    if (t.error === "InvalidToken")
      return new kh(t);
  }
  return t;
}
Gi.toKnownErr = a_;
var yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 });
yo.toKnownErr = void 0;
const o_ = q;
function l_(t) {
  return t instanceof o_.XRPCError, t;
}
yo.toKnownErr = l_;
var Fr = {};
Object.defineProperty(Fr, "__esModule", { value: !0 });
Fr.toKnownErr = Fr.TokenRequiredError = Fr.InvalidTokenError = Fr.ExpiredTokenError = void 0;
const Ku = q;
class Dh extends Ku.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fr.ExpiredTokenError = Dh;
class Ph extends Ku.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fr.InvalidTokenError = Ph;
class Bh extends Ku.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fr.TokenRequiredError = Bh;
function u_(t) {
  if (t instanceof Ku.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Dh(t);
    if (t.error === "InvalidToken")
      return new Ph(t);
    if (t.error === "TokenRequired")
      return new Bh(t);
  }
  return t;
}
Fr.toKnownErr = u_;
var ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.toKnownErr = ar.RepoDeactivatedError = ar.RepoSuspendedError = ar.RepoTakendownError = ar.RepoNotFoundError = ar.BlobNotFoundError = void 0;
const Gs = q;
class Ih extends Gs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ar.BlobNotFoundError = Ih;
let Uh = class extends Gs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ar.RepoNotFoundError = Uh;
let Oh = class extends Gs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ar.RepoTakendownError = Oh;
let Kh = class extends Gs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ar.RepoSuspendedError = Kh;
let Mh = class extends Gs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ar.RepoDeactivatedError = Mh;
function c_(t) {
  if (t instanceof Gs.XRPCError) {
    if (t.error === "BlobNotFound")
      return new Ih(t);
    if (t.error === "RepoNotFound")
      return new Uh(t);
    if (t.error === "RepoTakendown")
      return new Oh(t);
    if (t.error === "RepoSuspended")
      return new Kh(t);
    if (t.error === "RepoDeactivated")
      return new Mh(t);
  }
  return t;
}
ar.toKnownErr = c_;
var or = {};
Object.defineProperty(or, "__esModule", { value: !0 });
or.toKnownErr = or.RepoDeactivatedError = or.RepoSuspendedError = or.RepoTakendownError = or.RepoNotFoundError = or.BlockNotFoundError = void 0;
const qs = q;
class Nh extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
or.BlockNotFoundError = Nh;
let Vh = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
or.RepoNotFoundError = Vh;
let jh = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
or.RepoTakendownError = jh;
let Fh = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
or.RepoSuspendedError = Fh;
let $h = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
or.RepoDeactivatedError = $h;
function d_(t) {
  if (t instanceof qs.XRPCError) {
    if (t.error === "BlockNotFound")
      return new Nh(t);
    if (t.error === "RepoNotFound")
      return new Vh(t);
    if (t.error === "RepoTakendown")
      return new jh(t);
    if (t.error === "RepoSuspended")
      return new Fh(t);
    if (t.error === "RepoDeactivated")
      return new $h(t);
  }
  return t;
}
or.toKnownErr = d_;
var bo = {};
Object.defineProperty(bo, "__esModule", { value: !0 });
bo.toKnownErr = void 0;
const f_ = q;
function p_(t) {
  return t instanceof f_.XRPCError, t;
}
bo.toKnownErr = p_;
var qn = {};
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.toKnownErr = qn.HeadNotFoundError = void 0;
const Gh = q;
class qh extends Gh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
qn.HeadNotFoundError = qh;
function h_(t) {
  return t instanceof Gh.XRPCError && t.error === "HeadNotFound" ? new qh(t) : t;
}
qn.toKnownErr = h_;
var _r = {};
Object.defineProperty(_r, "__esModule", { value: !0 });
_r.toKnownErr = _r.RepoDeactivatedError = _r.RepoSuspendedError = _r.RepoTakendownError = _r.RepoNotFoundError = void 0;
const go = q;
let zh = class extends go.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
_r.RepoNotFoundError = zh;
let Xh = class extends go.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
_r.RepoTakendownError = Xh;
let Hh = class extends go.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
_r.RepoSuspendedError = Hh;
let Zh = class extends go.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
_r.RepoDeactivatedError = Zh;
function m_(t) {
  if (t instanceof go.XRPCError) {
    if (t.error === "RepoNotFound")
      return new zh(t);
    if (t.error === "RepoTakendown")
      return new Xh(t);
    if (t.error === "RepoSuspended")
      return new Hh(t);
    if (t.error === "RepoDeactivated")
      return new Zh(t);
  }
  return t;
}
_r.toKnownErr = m_;
var lr = {};
Object.defineProperty(lr, "__esModule", { value: !0 });
lr.toKnownErr = lr.RepoDeactivatedError = lr.RepoSuspendedError = lr.RepoTakendownError = lr.RepoNotFoundError = lr.RecordNotFoundError = void 0;
const zs = q;
let Wh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RecordNotFoundError = Wh;
let Yh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RepoNotFoundError = Yh;
let Jh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RepoTakendownError = Jh;
let Qh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RepoSuspendedError = Qh;
let e0 = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RepoDeactivatedError = e0;
function y_(t) {
  if (t instanceof zs.XRPCError) {
    if (t.error === "RecordNotFound")
      return new Wh(t);
    if (t.error === "RepoNotFound")
      return new Yh(t);
    if (t.error === "RepoTakendown")
      return new Jh(t);
    if (t.error === "RepoSuspended")
      return new Qh(t);
    if (t.error === "RepoDeactivated")
      return new e0(t);
  }
  return t;
}
lr.toKnownErr = y_;
var wr = {};
Object.defineProperty(wr, "__esModule", { value: !0 });
wr.toKnownErr = wr.RepoDeactivatedError = wr.RepoSuspendedError = wr.RepoTakendownError = wr.RepoNotFoundError = void 0;
const xo = q;
let t0 = class extends xo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
wr.RepoNotFoundError = t0;
let r0 = class extends xo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
wr.RepoTakendownError = r0;
let i0 = class extends xo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
wr.RepoSuspendedError = i0;
let n0 = class extends xo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
wr.RepoDeactivatedError = n0;
function b_(t) {
  if (t instanceof xo.XRPCError) {
    if (t.error === "RepoNotFound")
      return new t0(t);
    if (t.error === "RepoTakendown")
      return new r0(t);
    if (t.error === "RepoSuspended")
      return new i0(t);
    if (t.error === "RepoDeactivated")
      return new n0(t);
  }
  return t;
}
wr.toKnownErr = b_;
var zn = {};
Object.defineProperty(zn, "__esModule", { value: !0 });
zn.toKnownErr = zn.RepoNotFoundError = void 0;
const s0 = q;
let a0 = class extends s0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
zn.RepoNotFoundError = a0;
function g_(t) {
  return t instanceof s0.XRPCError && t.error === "RepoNotFound" ? new a0(t) : t;
}
zn.toKnownErr = g_;
var Tr = {};
Object.defineProperty(Tr, "__esModule", { value: !0 });
Tr.toKnownErr = Tr.RepoDeactivatedError = Tr.RepoSuspendedError = Tr.RepoTakendownError = Tr.RepoNotFoundError = void 0;
const Eo = q;
let o0 = class extends Eo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Tr.RepoNotFoundError = o0;
class l0 extends Eo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Tr.RepoTakendownError = l0;
class u0 extends Eo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Tr.RepoSuspendedError = u0;
class c0 extends Eo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Tr.RepoDeactivatedError = c0;
function x_(t) {
  if (t instanceof Eo.XRPCError) {
    if (t.error === "RepoNotFound")
      return new o0(t);
    if (t.error === "RepoTakendown")
      return new l0(t);
    if (t.error === "RepoSuspended")
      return new u0(t);
    if (t.error === "RepoDeactivated")
      return new c0(t);
  }
  return t;
}
Tr.toKnownErr = x_;
var qi = {};
Object.defineProperty(qi, "__esModule", { value: !0 });
qi.validateRepo = qi.isRepo = qi.toKnownErr = void 0;
const E_ = q, qd = we, v_ = Le;
function R_(t) {
  return t instanceof E_.XRPCError, t;
}
qi.toKnownErr = R_;
function A_(t) {
  return (0, qd.isObj)(t) && (0, qd.hasProp)(t, "$type") && t.$type === "com.atproto.sync.listRepos#repo";
}
qi.isRepo = A_;
function __(t) {
  return v_.lexicons.validate("com.atproto.sync.listRepos#repo", t);
}
qi.validateRepo = __;
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.toKnownErr = void 0;
const w_ = q;
function T_(t) {
  return t instanceof w_.XRPCError, t;
}
vo.toKnownErr = T_;
var Ro = {};
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.toKnownErr = void 0;
const C_ = q;
function S_(t) {
  return t instanceof C_.XRPCError, t;
}
Ro.toKnownErr = S_;
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 });
Ao.toKnownErr = void 0;
const L_ = q;
function k_(t) {
  return t instanceof L_.XRPCError, t;
}
Ao.toKnownErr = k_;
var _o = {};
Object.defineProperty(_o, "__esModule", { value: !0 });
_o.toKnownErr = void 0;
const D_ = q;
function P_(t) {
  return t instanceof D_.XRPCError, t;
}
_o.toKnownErr = P_;
var wo = {};
Object.defineProperty(wo, "__esModule", { value: !0 });
wo.toKnownErr = void 0;
const B_ = q;
function I_(t) {
  return t instanceof B_.XRPCError, t;
}
wo.toKnownErr = I_;
var To = {};
Object.defineProperty(To, "__esModule", { value: !0 });
To.toKnownErr = void 0;
const U_ = q;
function O_(t) {
  return t instanceof U_.XRPCError, t;
}
To.toKnownErr = O_;
var Co = {};
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.toKnownErr = void 0;
const K_ = q;
function M_(t) {
  return t instanceof K_.XRPCError, t;
}
Co.toKnownErr = M_;
var So = {};
Object.defineProperty(So, "__esModule", { value: !0 });
So.toKnownErr = void 0;
const N_ = q;
function V_(t) {
  return t instanceof N_.XRPCError, t;
}
So.toKnownErr = V_;
var Lo = {};
Object.defineProperty(Lo, "__esModule", { value: !0 });
Lo.toKnownErr = void 0;
const j_ = q;
function F_(t) {
  return t instanceof j_.XRPCError, t;
}
Lo.toKnownErr = F_;
var ko = {};
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.toKnownErr = void 0;
const $_ = q;
function G_(t) {
  return t instanceof $_.XRPCError, t;
}
ko.toKnownErr = G_;
var Do = {};
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.toKnownErr = void 0;
const q_ = q;
function z_(t) {
  return t instanceof q_.XRPCError, t;
}
Do.toKnownErr = z_;
var Po = {};
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.toKnownErr = void 0;
const X_ = q;
function H_(t) {
  return t instanceof X_.XRPCError, t;
}
Po.toKnownErr = H_;
var Cr = {};
Object.defineProperty(Cr, "__esModule", { value: !0 });
Cr.validateLinks = Cr.isLinks = Cr.validateFeed = Cr.isFeed = Cr.toKnownErr = void 0;
const Z_ = q, Ru = we, d0 = Le;
function W_(t) {
  return t instanceof Z_.XRPCError, t;
}
Cr.toKnownErr = W_;
function Y_(t) {
  return (0, Ru.isObj)(t) && (0, Ru.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#feed";
}
Cr.isFeed = Y_;
function J_(t) {
  return d0.lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", t);
}
Cr.validateFeed = J_;
function Q_(t) {
  return (0, Ru.isObj)(t) && (0, Ru.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#links";
}
Cr.isLinks = Q_;
function ew(t) {
  return d0.lexicons.validate("app.bsky.feed.describeFeedGenerator#links", t);
}
Cr.validateLinks = ew;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.toKnownErr = void 0;
const tw = q;
function rw(t) {
  return t instanceof tw.XRPCError, t;
}
Bo.toKnownErr = rw;
var zi = {};
Object.defineProperty(zi, "__esModule", { value: !0 });
zi.toKnownErr = zi.BlockedByActorError = zi.BlockedActorError = void 0;
const Qc = q;
let f0 = class extends Qc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
zi.BlockedActorError = f0;
let p0 = class extends Qc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
zi.BlockedByActorError = p0;
function iw(t) {
  if (t instanceof Qc.XRPCError) {
    if (t.error === "BlockedActor")
      return new f0(t);
    if (t.error === "BlockedByActor")
      return new p0(t);
  }
  return t;
}
zi.toKnownErr = iw;
var Xi = {};
Object.defineProperty(Xi, "__esModule", { value: !0 });
Xi.toKnownErr = Xi.BlockedByActorError = Xi.BlockedActorError = void 0;
const ed = q;
class h0 extends ed.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Xi.BlockedActorError = h0;
class m0 extends ed.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Xi.BlockedByActorError = m0;
function nw(t) {
  if (t instanceof ed.XRPCError) {
    if (t.error === "BlockedActor")
      return new h0(t);
    if (t.error === "BlockedByActor")
      return new m0(t);
  }
  return t;
}
Xi.toKnownErr = nw;
var Xn = {};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.toKnownErr = Xn.UnknownFeedError = void 0;
const y0 = q;
let b0 = class extends y0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Xn.UnknownFeedError = b0;
function sw(t) {
  return t instanceof y0.XRPCError && t.error === "UnknownFeed" ? new b0(t) : t;
}
Xn.toKnownErr = sw;
var Io = {};
Object.defineProperty(Io, "__esModule", { value: !0 });
Io.toKnownErr = void 0;
const aw = q;
function ow(t) {
  return t instanceof aw.XRPCError, t;
}
Io.toKnownErr = ow;
var Uo = {};
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.toKnownErr = void 0;
const lw = q;
function uw(t) {
  return t instanceof lw.XRPCError, t;
}
Uo.toKnownErr = uw;
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.toKnownErr = Hn.UnknownFeedError = void 0;
const g0 = q;
class x0 extends g0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Hn.UnknownFeedError = x0;
function cw(t) {
  return t instanceof g0.XRPCError && t.error === "UnknownFeed" ? new x0(t) : t;
}
Hn.toKnownErr = cw;
var Hi = {};
Object.defineProperty(Hi, "__esModule", { value: !0 });
Hi.validateLike = Hi.isLike = Hi.toKnownErr = void 0;
const dw = q, zd = we, fw = Le;
function pw(t) {
  return t instanceof dw.XRPCError, t;
}
Hi.toKnownErr = pw;
function hw(t) {
  return (0, zd.isObj)(t) && (0, zd.hasProp)(t, "$type") && t.$type === "app.bsky.feed.getLikes#like";
}
Hi.isLike = hw;
function mw(t) {
  return fw.lexicons.validate("app.bsky.feed.getLikes#like", t);
}
Hi.validateLike = mw;
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.toKnownErr = Zn.UnknownListError = void 0;
const E0 = q;
class v0 extends E0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Zn.UnknownListError = v0;
function yw(t) {
  return t instanceof E0.XRPCError && t.error === "UnknownList" ? new v0(t) : t;
}
Zn.toKnownErr = yw;
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.toKnownErr = Wn.NotFoundError = void 0;
const R0 = q;
class A0 extends R0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Wn.NotFoundError = A0;
function bw(t) {
  return t instanceof R0.XRPCError && t.error === "NotFound" ? new A0(t) : t;
}
Wn.toKnownErr = bw;
var Oo = {};
Object.defineProperty(Oo, "__esModule", { value: !0 });
Oo.toKnownErr = void 0;
const gw = q;
function xw(t) {
  return t instanceof gw.XRPCError, t;
}
Oo.toKnownErr = xw;
var Ko = {};
Object.defineProperty(Ko, "__esModule", { value: !0 });
Ko.toKnownErr = void 0;
const Ew = q;
function vw(t) {
  return t instanceof Ew.XRPCError, t;
}
Ko.toKnownErr = vw;
var Mo = {};
Object.defineProperty(Mo, "__esModule", { value: !0 });
Mo.toKnownErr = void 0;
const Rw = q;
function Aw(t) {
  return t instanceof Rw.XRPCError, t;
}
Mo.toKnownErr = Aw;
var No = {};
Object.defineProperty(No, "__esModule", { value: !0 });
No.toKnownErr = void 0;
const _w = q;
function ww(t) {
  return t instanceof _w.XRPCError, t;
}
No.toKnownErr = ww;
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.toKnownErr = Yn.BadQueryStringError = void 0;
const _0 = q;
let w0 = class extends _0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Yn.BadQueryStringError = w0;
function Tw(t) {
  return t instanceof _0.XRPCError && t.error === "BadQueryString" ? new w0(t) : t;
}
Yn.toKnownErr = Tw;
var Vo = {};
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.toKnownErr = void 0;
const Cw = q;
function Sw(t) {
  return t instanceof Cw.XRPCError, t;
}
Vo.toKnownErr = Sw;
var jo = {};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.toKnownErr = void 0;
const Lw = q;
function kw(t) {
  return t instanceof Lw.XRPCError, t;
}
jo.toKnownErr = kw;
var Fo = {};
Object.defineProperty(Fo, "__esModule", { value: !0 });
Fo.toKnownErr = void 0;
const Dw = q;
function Pw(t) {
  return t instanceof Dw.XRPCError, t;
}
Fo.toKnownErr = Pw;
var $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
$o.toKnownErr = void 0;
const Bw = q;
function Iw(t) {
  return t instanceof Bw.XRPCError, t;
}
$o.toKnownErr = Iw;
var Go = {};
Object.defineProperty(Go, "__esModule", { value: !0 });
Go.toKnownErr = void 0;
const Uw = q;
function Ow(t) {
  return t instanceof Uw.XRPCError, t;
}
Go.toKnownErr = Ow;
var qo = {};
Object.defineProperty(qo, "__esModule", { value: !0 });
qo.toKnownErr = void 0;
const Kw = q;
function Mw(t) {
  return t instanceof Kw.XRPCError, t;
}
qo.toKnownErr = Mw;
var zo = {};
Object.defineProperty(zo, "__esModule", { value: !0 });
zo.toKnownErr = void 0;
const Nw = q;
function Vw(t) {
  return t instanceof Nw.XRPCError, t;
}
zo.toKnownErr = Vw;
var Xo = {};
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.toKnownErr = void 0;
const jw = q;
function Fw(t) {
  return t instanceof jw.XRPCError, t;
}
Xo.toKnownErr = Fw;
var Ho = {};
Object.defineProperty(Ho, "__esModule", { value: !0 });
Ho.toKnownErr = void 0;
const $w = q;
function Gw(t) {
  return t instanceof $w.XRPCError, t;
}
Ho.toKnownErr = Gw;
var Zo = {};
Object.defineProperty(Zo, "__esModule", { value: !0 });
Zo.toKnownErr = void 0;
const qw = q;
function zw(t) {
  return t instanceof qw.XRPCError, t;
}
Zo.toKnownErr = zw;
var Wo = {};
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.toKnownErr = void 0;
const Xw = q;
function Hw(t) {
  return t instanceof Xw.XRPCError, t;
}
Wo.toKnownErr = Hw;
var Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.toKnownErr = Jn.ActorNotFoundError = void 0;
const T0 = q;
class C0 extends T0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Jn.ActorNotFoundError = C0;
function Zw(t) {
  return t instanceof T0.XRPCError && t.error === "ActorNotFound" ? new C0(t) : t;
}
Jn.toKnownErr = Zw;
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.toKnownErr = void 0;
const Ww = q;
function Yw(t) {
  return t instanceof Ww.XRPCError, t;
}
Yo.toKnownErr = Yw;
var Jo = {};
Object.defineProperty(Jo, "__esModule", { value: !0 });
Jo.toKnownErr = void 0;
const Jw = q;
function Qw(t) {
  return t instanceof Jw.XRPCError, t;
}
Jo.toKnownErr = Qw;
var Qo = {};
Object.defineProperty(Qo, "__esModule", { value: !0 });
Qo.toKnownErr = void 0;
const eT = q;
function tT(t) {
  return t instanceof eT.XRPCError, t;
}
Qo.toKnownErr = tT;
var el = {};
Object.defineProperty(el, "__esModule", { value: !0 });
el.toKnownErr = void 0;
const rT = q;
function iT(t) {
  return t instanceof rT.XRPCError, t;
}
el.toKnownErr = iT;
var tl = {};
Object.defineProperty(tl, "__esModule", { value: !0 });
tl.toKnownErr = void 0;
const nT = q;
function sT(t) {
  return t instanceof nT.XRPCError, t;
}
tl.toKnownErr = sT;
var rl = {};
Object.defineProperty(rl, "__esModule", { value: !0 });
rl.toKnownErr = void 0;
const aT = q;
function oT(t) {
  return t instanceof aT.XRPCError, t;
}
rl.toKnownErr = oT;
var il = {};
Object.defineProperty(il, "__esModule", { value: !0 });
il.toKnownErr = void 0;
const lT = q;
function uT(t) {
  return t instanceof lT.XRPCError, t;
}
il.toKnownErr = uT;
var nl = {};
Object.defineProperty(nl, "__esModule", { value: !0 });
nl.toKnownErr = void 0;
const cT = q;
function dT(t) {
  return t instanceof cT.XRPCError, t;
}
nl.toKnownErr = dT;
var sl = {};
Object.defineProperty(sl, "__esModule", { value: !0 });
sl.toKnownErr = void 0;
const fT = q;
function pT(t) {
  return t instanceof fT.XRPCError, t;
}
sl.toKnownErr = pT;
var al = {};
Object.defineProperty(al, "__esModule", { value: !0 });
al.toKnownErr = void 0;
const hT = q;
function mT(t) {
  return t instanceof hT.XRPCError, t;
}
al.toKnownErr = mT;
var ol = {};
Object.defineProperty(ol, "__esModule", { value: !0 });
ol.toKnownErr = void 0;
const yT = q;
function bT(t) {
  return t instanceof yT.XRPCError, t;
}
ol.toKnownErr = bT;
var Zi = {};
Object.defineProperty(Zi, "__esModule", { value: !0 });
Zi.validateNotification = Zi.isNotification = Zi.toKnownErr = void 0;
const gT = q, Xd = we, xT = Le;
function ET(t) {
  return t instanceof gT.XRPCError, t;
}
Zi.toKnownErr = ET;
function vT(t) {
  return (0, Xd.isObj)(t) && (0, Xd.hasProp)(t, "$type") && t.$type === "app.bsky.notification.listNotifications#notification";
}
Zi.isNotification = vT;
function RT(t) {
  return xT.lexicons.validate("app.bsky.notification.listNotifications#notification", t);
}
Zi.validateNotification = RT;
var ll = {};
Object.defineProperty(ll, "__esModule", { value: !0 });
ll.toKnownErr = void 0;
const AT = q;
function _T(t) {
  return t instanceof AT.XRPCError, t;
}
ll.toKnownErr = _T;
var ul = {};
Object.defineProperty(ul, "__esModule", { value: !0 });
ul.toKnownErr = void 0;
const wT = q;
function TT(t) {
  return t instanceof wT.XRPCError, t;
}
ul.toKnownErr = TT;
var cl = {};
Object.defineProperty(cl, "__esModule", { value: !0 });
cl.toKnownErr = void 0;
const CT = q;
function ST(t) {
  return t instanceof CT.XRPCError, t;
}
cl.toKnownErr = ST;
var dl = {};
Object.defineProperty(dl, "__esModule", { value: !0 });
dl.toKnownErr = void 0;
const LT = q;
function kT(t) {
  return t instanceof LT.XRPCError, t;
}
dl.toKnownErr = kT;
var fl = {};
Object.defineProperty(fl, "__esModule", { value: !0 });
fl.toKnownErr = void 0;
const DT = q;
function PT(t) {
  return t instanceof DT.XRPCError, t;
}
fl.toKnownErr = PT;
var Wi = {};
Object.defineProperty(Wi, "__esModule", { value: !0 });
Wi.validateSuggestion = Wi.isSuggestion = Wi.toKnownErr = void 0;
const BT = q, Hd = we, IT = Le;
function UT(t) {
  return t instanceof BT.XRPCError, t;
}
Wi.toKnownErr = UT;
function OT(t) {
  return (0, Hd.isObj)(t) && (0, Hd.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.getTaggedSuggestions#suggestion";
}
Wi.isSuggestion = OT;
function KT(t) {
  return IT.lexicons.validate("app.bsky.unspecced.getTaggedSuggestions#suggestion", t);
}
Wi.validateSuggestion = KT;
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.toKnownErr = Qn.BadQueryStringError = void 0;
const S0 = q;
let L0 = class extends S0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Qn.BadQueryStringError = L0;
function MT(t) {
  return t instanceof S0.XRPCError && t.error === "BadQueryString" ? new L0(t) : t;
}
Qn.toKnownErr = MT;
var es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
es.toKnownErr = es.BadQueryStringError = void 0;
const k0 = q;
class D0 extends k0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
es.BadQueryStringError = D0;
function NT(t) {
  return t instanceof k0.XRPCError && t.error === "BadQueryString" ? new D0(t) : t;
}
es.toKnownErr = NT;
var pl = {};
Object.defineProperty(pl, "__esModule", { value: !0 });
pl.toKnownErr = void 0;
const VT = q;
function jT(t) {
  return t instanceof VT.XRPCError, t;
}
pl.toKnownErr = jT;
var hl = {};
Object.defineProperty(hl, "__esModule", { value: !0 });
hl.toKnownErr = void 0;
const FT = q;
function $T(t) {
  return t instanceof FT.XRPCError, t;
}
hl.toKnownErr = $T;
var ml = {};
Object.defineProperty(ml, "__esModule", { value: !0 });
ml.toKnownErr = void 0;
const GT = q;
function qT(t) {
  return t instanceof GT.XRPCError, t;
}
ml.toKnownErr = qT;
var yl = {};
Object.defineProperty(yl, "__esModule", { value: !0 });
yl.toKnownErr = void 0;
const zT = q;
function XT(t) {
  return t instanceof zT.XRPCError, t;
}
yl.toKnownErr = XT;
var bl = {};
Object.defineProperty(bl, "__esModule", { value: !0 });
bl.toKnownErr = void 0;
const HT = q;
function ZT(t) {
  return t instanceof HT.XRPCError, t;
}
bl.toKnownErr = ZT;
var gl = {};
Object.defineProperty(gl, "__esModule", { value: !0 });
gl.toKnownErr = void 0;
const WT = q;
function YT(t) {
  return t instanceof WT.XRPCError, t;
}
gl.toKnownErr = YT;
var xl = {};
Object.defineProperty(xl, "__esModule", { value: !0 });
xl.toKnownErr = void 0;
const JT = q;
function QT(t) {
  return t instanceof JT.XRPCError, t;
}
xl.toKnownErr = QT;
var El = {};
Object.defineProperty(El, "__esModule", { value: !0 });
El.toKnownErr = void 0;
const eC = q;
function tC(t) {
  return t instanceof eC.XRPCError, t;
}
El.toKnownErr = tC;
var vl = {};
Object.defineProperty(vl, "__esModule", { value: !0 });
vl.toKnownErr = void 0;
const rC = q;
function iC(t) {
  return t instanceof rC.XRPCError, t;
}
vl.toKnownErr = iC;
var Rl = {};
Object.defineProperty(Rl, "__esModule", { value: !0 });
Rl.toKnownErr = void 0;
const nC = q;
function sC(t) {
  return t instanceof nC.XRPCError, t;
}
Rl.toKnownErr = sC;
var Al = {};
Object.defineProperty(Al, "__esModule", { value: !0 });
Al.toKnownErr = void 0;
const aC = q;
function oC(t) {
  return t instanceof aC.XRPCError, t;
}
Al.toKnownErr = oC;
var Yi = {};
Object.defineProperty(Yi, "__esModule", { value: !0 });
Yi.validateBatchItem = Yi.isBatchItem = Yi.toKnownErr = void 0;
const lC = q, Zd = we, uC = Le;
function cC(t) {
  return t instanceof lC.XRPCError, t;
}
Yi.toKnownErr = cC;
function dC(t) {
  return (0, Zd.isObj)(t) && (0, Zd.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.sendMessageBatch#batchItem";
}
Yi.isBatchItem = dC;
function fC(t) {
  return uC.lexicons.validate("chat.bsky.convo.sendMessageBatch#batchItem", t);
}
Yi.validateBatchItem = fC;
var _l = {};
Object.defineProperty(_l, "__esModule", { value: !0 });
_l.toKnownErr = void 0;
const pC = q;
function hC(t) {
  return t instanceof pC.XRPCError, t;
}
_l.toKnownErr = hC;
var wl = {};
Object.defineProperty(wl, "__esModule", { value: !0 });
wl.toKnownErr = void 0;
const mC = q;
function yC(t) {
  return t instanceof mC.XRPCError, t;
}
wl.toKnownErr = yC;
var Ji = {};
Object.defineProperty(Ji, "__esModule", { value: !0 });
Ji.validateMetadata = Ji.isMetadata = Ji.toKnownErr = void 0;
const bC = q, Wd = we, gC = Le;
function xC(t) {
  return t instanceof bC.XRPCError, t;
}
Ji.toKnownErr = xC;
function EC(t) {
  return (0, Wd.isObj)(t) && (0, Wd.hasProp)(t, "$type") && t.$type === "chat.bsky.moderation.getActorMetadata#metadata";
}
Ji.isMetadata = EC;
function vC(t) {
  return gC.lexicons.validate("chat.bsky.moderation.getActorMetadata#metadata", t);
}
Ji.validateMetadata = vC;
var Tl = {};
Object.defineProperty(Tl, "__esModule", { value: !0 });
Tl.toKnownErr = void 0;
const RC = q;
function AC(t) {
  return t instanceof RC.XRPCError, t;
}
Tl.toKnownErr = AC;
var Cl = {};
Object.defineProperty(Cl, "__esModule", { value: !0 });
Cl.toKnownErr = void 0;
const _C = q;
function wC(t) {
  return t instanceof _C.XRPCError, t;
}
Cl.toKnownErr = wC;
var Sl = {};
Object.defineProperty(Sl, "__esModule", { value: !0 });
Sl.toKnownErr = void 0;
const TC = q;
function CC(t) {
  return t instanceof TC.XRPCError, t;
}
Sl.toKnownErr = CC;
var Ll = {};
Object.defineProperty(Ll, "__esModule", { value: !0 });
Ll.toKnownErr = void 0;
const SC = q;
function LC(t) {
  return t instanceof SC.XRPCError, t;
}
Ll.toKnownErr = LC;
var kl = {};
Object.defineProperty(kl, "__esModule", { value: !0 });
kl.toKnownErr = void 0;
const kC = q;
function DC(t) {
  return t instanceof kC.XRPCError, t;
}
kl.toKnownErr = DC;
var Dl = {};
Object.defineProperty(Dl, "__esModule", { value: !0 });
Dl.toKnownErr = void 0;
const PC = q;
function BC(t) {
  return t instanceof PC.XRPCError, t;
}
Dl.toKnownErr = BC;
var ts = {};
Object.defineProperty(ts, "__esModule", { value: !0 });
ts.toKnownErr = ts.SubjectHasActionError = void 0;
const P0 = q;
class B0 extends P0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ts.SubjectHasActionError = B0;
function IC(t) {
  return t instanceof P0.XRPCError && t.error === "SubjectHasAction" ? new B0(t) : t;
}
ts.toKnownErr = IC;
var Pl = {};
Object.defineProperty(Pl, "__esModule", { value: !0 });
Pl.toKnownErr = void 0;
const UC = q;
function OC(t) {
  return t instanceof UC.XRPCError, t;
}
Pl.toKnownErr = OC;
var rs = {};
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.toKnownErr = rs.RecordNotFoundError = void 0;
const I0 = q;
class U0 extends I0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
rs.RecordNotFoundError = U0;
function KC(t) {
  return t instanceof I0.XRPCError && t.error === "RecordNotFound" ? new U0(t) : t;
}
rs.toKnownErr = KC;
var is = {};
Object.defineProperty(is, "__esModule", { value: !0 });
is.toKnownErr = is.RepoNotFoundError = void 0;
const O0 = q;
class K0 extends O0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
is.RepoNotFoundError = K0;
function MC(t) {
  return t instanceof O0.XRPCError && t.error === "RepoNotFound" ? new K0(t) : t;
}
is.toKnownErr = MC;
var Bl = {};
Object.defineProperty(Bl, "__esModule", { value: !0 });
Bl.toKnownErr = void 0;
const NC = q;
function VC(t) {
  return t instanceof NC.XRPCError, t;
}
Bl.toKnownErr = VC;
var Il = {};
Object.defineProperty(Il, "__esModule", { value: !0 });
Il.toKnownErr = void 0;
const jC = q;
function FC(t) {
  return t instanceof jC.XRPCError, t;
}
Il.toKnownErr = FC;
var Ul = {};
Object.defineProperty(Ul, "__esModule", { value: !0 });
Ul.toKnownErr = void 0;
const $C = q;
function GC(t) {
  return t instanceof $C.XRPCError, t;
}
Ul.toKnownErr = GC;
var Sr = {};
Object.defineProperty(Sr, "__esModule", { value: !0 });
Sr.validateViewerConfig = Sr.isViewerConfig = Sr.validateServiceConfig = Sr.isServiceConfig = Sr.toKnownErr = void 0;
const qC = q, Au = we, M0 = Le;
function zC(t) {
  return t instanceof qC.XRPCError, t;
}
Sr.toKnownErr = zC;
function XC(t) {
  return (0, Au.isObj)(t) && (0, Au.hasProp)(t, "$type") && t.$type === "tools.ozone.server.getConfig#serviceConfig";
}
Sr.isServiceConfig = XC;
function HC(t) {
  return M0.lexicons.validate("tools.ozone.server.getConfig#serviceConfig", t);
}
Sr.validateServiceConfig = HC;
function ZC(t) {
  return (0, Au.isObj)(t) && (0, Au.hasProp)(t, "$type") && t.$type === "tools.ozone.server.getConfig#viewerConfig";
}
Sr.isViewerConfig = ZC;
function WC(t) {
  return M0.lexicons.validate("tools.ozone.server.getConfig#viewerConfig", t);
}
Sr.validateViewerConfig = WC;
var ns = {};
Object.defineProperty(ns, "__esModule", { value: !0 });
ns.toKnownErr = ns.MemberAlreadyExistsError = void 0;
const N0 = q;
class V0 extends N0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ns.MemberAlreadyExistsError = V0;
function YC(t) {
  return t instanceof N0.XRPCError && t.error === "MemberAlreadyExists" ? new V0(t) : t;
}
ns.toKnownErr = YC;
var Qi = {};
Object.defineProperty(Qi, "__esModule", { value: !0 });
Qi.toKnownErr = Qi.CannotDeleteSelfError = Qi.MemberNotFoundError = void 0;
const td = q;
let j0 = class extends td.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Qi.MemberNotFoundError = j0;
class F0 extends td.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Qi.CannotDeleteSelfError = F0;
function JC(t) {
  if (t instanceof td.XRPCError) {
    if (t.error === "MemberNotFound")
      return new j0(t);
    if (t.error === "CannotDeleteSelf")
      return new F0(t);
  }
  return t;
}
Qi.toKnownErr = JC;
var Ol = {};
Object.defineProperty(Ol, "__esModule", { value: !0 });
Ol.toKnownErr = void 0;
const QC = q;
function eS(t) {
  return t instanceof QC.XRPCError, t;
}
Ol.toKnownErr = eS;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.toKnownErr = ss.MemberNotFoundError = void 0;
const $0 = q;
class G0 extends $0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ss.MemberNotFoundError = G0;
function tS(t) {
  return t instanceof $0.XRPCError && t.error === "MemberNotFound" ? new G0(t) : t;
}
ss.toKnownErr = tS;
var Ut = {};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.validateRepoBlobRef = Ut.isRepoBlobRef = Ut.validateRepoRef = Ut.isRepoRef = Ut.validateAccountView = Ut.isAccountView = Ut.validateStatusAttr = Ut.isStatusAttr = void 0;
const mn = we, Mu = Le;
function rS(t) {
  return (0, mn.isObj)(t) && (0, mn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#statusAttr";
}
Ut.isStatusAttr = rS;
function iS(t) {
  return Mu.lexicons.validate("com.atproto.admin.defs#statusAttr", t);
}
Ut.validateStatusAttr = iS;
function nS(t) {
  return (0, mn.isObj)(t) && (0, mn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#accountView";
}
Ut.isAccountView = nS;
function sS(t) {
  return Mu.lexicons.validate("com.atproto.admin.defs#accountView", t);
}
Ut.validateAccountView = sS;
function aS(t) {
  return (0, mn.isObj)(t) && (0, mn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoRef";
}
Ut.isRepoRef = aS;
function oS(t) {
  return Mu.lexicons.validate("com.atproto.admin.defs#repoRef", t);
}
Ut.validateRepoRef = oS;
function lS(t) {
  return (0, mn.isObj)(t) && (0, mn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoBlobRef";
}
Ut.isRepoBlobRef = lS;
function uS(t) {
  return Mu.lexicons.validate("com.atproto.admin.defs#repoBlobRef", t);
}
Ut.validateRepoBlobRef = uS;
var ht = {};
Object.defineProperty(ht, "__esModule", { value: !0 });
ht.validateLabelValueDefinitionStrings = ht.isLabelValueDefinitionStrings = ht.validateLabelValueDefinition = ht.isLabelValueDefinition = ht.validateSelfLabel = ht.isSelfLabel = ht.validateSelfLabels = ht.isSelfLabels = ht.validateLabel = ht.isLabel = void 0;
const mi = we, Kl = Le;
function cS(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#label";
}
ht.isLabel = cS;
function dS(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#label", t);
}
ht.validateLabel = dS;
function fS(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabels";
}
ht.isSelfLabels = fS;
function pS(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#selfLabels", t);
}
ht.validateSelfLabels = pS;
function hS(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabel";
}
ht.isSelfLabel = hS;
function mS(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#selfLabel", t);
}
ht.validateSelfLabel = mS;
function yS(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinition";
}
ht.isLabelValueDefinition = yS;
function bS(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#labelValueDefinition", t);
}
ht.validateLabelValueDefinition = bS;
function gS(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinitionStrings";
}
ht.isLabelValueDefinitionStrings = gS;
function xS(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#labelValueDefinitionStrings", t);
}
ht.validateLabelValueDefinitionStrings = xS;
var ni = {};
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.validateInfo = ni.isInfo = ni.validateLabels = ni.isLabels = void 0;
const _u = we, q0 = Le;
function ES(t) {
  return (0, _u.isObj)(t) && (0, _u.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#labels";
}
ni.isLabels = ES;
function vS(t) {
  return q0.lexicons.validate("com.atproto.label.subscribeLabels#labels", t);
}
ni.validateLabels = vS;
function RS(t) {
  return (0, _u.isObj)(t) && (0, _u.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#info";
}
ni.isInfo = RS;
function AS(t) {
  return q0.lexicons.validate("com.atproto.label.subscribeLabels#info", t);
}
ni.validateInfo = AS;
var Yt = {};
Object.defineProperty(Yt, "__esModule", { value: !0 });
Yt.REASONAPPEAL = Yt.REASONOTHER = Yt.REASONRUDE = Yt.REASONSEXUAL = Yt.REASONMISLEADING = Yt.REASONVIOLATION = Yt.REASONSPAM = void 0;
Yt.REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
Yt.REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
Yt.REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
Yt.REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
Yt.REASONRUDE = "com.atproto.moderation.defs#reasonRude";
Yt.REASONOTHER = "com.atproto.moderation.defs#reasonOther";
Yt.REASONAPPEAL = "com.atproto.moderation.defs#reasonAppeal";
var Ts = {};
Object.defineProperty(Ts, "__esModule", { value: !0 });
Ts.validateMain = Ts.isMain = void 0;
const Yd = we, _S = Le;
function wS(t) {
  return (0, Yd.isObj)(t) && (0, Yd.hasProp)(t, "$type") && (t.$type === "com.atproto.repo.strongRef#main" || t.$type === "com.atproto.repo.strongRef");
}
Ts.isMain = wS;
function TS(t) {
  return _S.lexicons.validate("com.atproto.repo.strongRef#main", t);
}
Ts.validateMain = TS;
var si = {};
Object.defineProperty(si, "__esModule", { value: !0 });
si.validateInviteCodeUse = si.isInviteCodeUse = si.validateInviteCode = si.isInviteCode = void 0;
const wu = we, z0 = Le;
function CS(t) {
  return (0, wu.isObj)(t) && (0, wu.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCode";
}
si.isInviteCode = CS;
function SS(t) {
  return z0.lexicons.validate("com.atproto.server.defs#inviteCode", t);
}
si.validateInviteCode = SS;
function LS(t) {
  return (0, wu.isObj)(t) && (0, wu.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCodeUse";
}
si.isInviteCodeUse = LS;
function kS(t) {
  return z0.lexicons.validate("com.atproto.server.defs#inviteCodeUse", t);
}
si.validateInviteCodeUse = kS;
var qe = {};
Object.defineProperty(qe, "__esModule", { value: !0 });
qe.validateRepoOp = qe.isRepoOp = qe.validateInfo = qe.isInfo = qe.validateTombstone = qe.isTombstone = qe.validateMigrate = qe.isMigrate = qe.validateHandle = qe.isHandle = qe.validateAccount = qe.isAccount = qe.validateIdentity = qe.isIdentity = qe.validateCommit = qe.isCommit = void 0;
const Qt = we, wn = Le;
function DS(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#commit";
}
qe.isCommit = DS;
function PS(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#commit", t);
}
qe.validateCommit = PS;
function BS(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#identity";
}
qe.isIdentity = BS;
function IS(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#identity", t);
}
qe.validateIdentity = IS;
function US(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#account";
}
qe.isAccount = US;
function OS(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#account", t);
}
qe.validateAccount = OS;
function KS(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#handle";
}
qe.isHandle = KS;
function MS(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#handle", t);
}
qe.validateHandle = MS;
function NS(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#migrate";
}
qe.isMigrate = NS;
function VS(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#migrate", t);
}
qe.validateMigrate = VS;
function jS(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#tombstone";
}
qe.isTombstone = jS;
function FS(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", t);
}
qe.validateTombstone = FS;
function $S(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#info";
}
qe.isInfo = $S;
function GS(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#info", t);
}
qe.validateInfo = GS;
function qS(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#repoOp";
}
qe.isRepoOp = qS;
function zS(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", t);
}
qe.validateRepoOp = zS;
var oe = {};
Object.defineProperty(oe, "__esModule", { value: !0 });
oe.validateBskyAppProgressGuide = oe.isBskyAppProgressGuide = oe.validateBskyAppStatePref = oe.isBskyAppStatePref = oe.validateLabelerPrefItem = oe.isLabelerPrefItem = oe.validateLabelersPref = oe.isLabelersPref = oe.validateHiddenPostsPref = oe.isHiddenPostsPref = oe.validateMutedWordsPref = oe.isMutedWordsPref = oe.validateMutedWord = oe.isMutedWord = oe.validateInterestsPref = oe.isInterestsPref = oe.validateThreadViewPref = oe.isThreadViewPref = oe.validateFeedViewPref = oe.isFeedViewPref = oe.validatePersonalDetailsPref = oe.isPersonalDetailsPref = oe.validateSavedFeedsPref = oe.isSavedFeedsPref = oe.validateSavedFeedsPrefV2 = oe.isSavedFeedsPrefV2 = oe.validateSavedFeed = oe.isSavedFeed = oe.validateContentLabelPref = oe.isContentLabelPref = oe.validateAdultContentPref = oe.isAdultContentPref = oe.validateKnownFollowers = oe.isKnownFollowers = oe.validateViewerState = oe.isViewerState = oe.validateProfileAssociatedChat = oe.isProfileAssociatedChat = oe.validateProfileAssociated = oe.isProfileAssociated = oe.validateProfileViewDetailed = oe.isProfileViewDetailed = oe.validateProfileView = oe.isProfileView = oe.validateProfileViewBasic = oe.isProfileViewBasic = void 0;
const De = we, pt = Le;
function XS(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewBasic";
}
oe.isProfileViewBasic = XS;
function HS(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#profileViewBasic", t);
}
oe.validateProfileViewBasic = HS;
function ZS(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileView";
}
oe.isProfileView = ZS;
function WS(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#profileView", t);
}
oe.validateProfileView = WS;
function YS(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewDetailed";
}
oe.isProfileViewDetailed = YS;
function JS(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#profileViewDetailed", t);
}
oe.validateProfileViewDetailed = JS;
function QS(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociated";
}
oe.isProfileAssociated = QS;
function e1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#profileAssociated", t);
}
oe.validateProfileAssociated = e1;
function t1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociatedChat";
}
oe.isProfileAssociatedChat = t1;
function r1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#profileAssociatedChat", t);
}
oe.validateProfileAssociatedChat = r1;
function i1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#viewerState";
}
oe.isViewerState = i1;
function n1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#viewerState", t);
}
oe.validateViewerState = n1;
function s1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#knownFollowers";
}
oe.isKnownFollowers = s1;
function a1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#knownFollowers", t);
}
oe.validateKnownFollowers = a1;
function o1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#adultContentPref";
}
oe.isAdultContentPref = o1;
function l1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#adultContentPref", t);
}
oe.validateAdultContentPref = l1;
function u1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#contentLabelPref";
}
oe.isContentLabelPref = u1;
function c1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#contentLabelPref", t);
}
oe.validateContentLabelPref = c1;
function d1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeed";
}
oe.isSavedFeed = d1;
function f1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#savedFeed", t);
}
oe.validateSavedFeed = f1;
function p1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPrefV2";
}
oe.isSavedFeedsPrefV2 = p1;
function h1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#savedFeedsPrefV2", t);
}
oe.validateSavedFeedsPrefV2 = h1;
function m1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPref";
}
oe.isSavedFeedsPref = m1;
function y1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#savedFeedsPref", t);
}
oe.validateSavedFeedsPref = y1;
function b1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#personalDetailsPref";
}
oe.isPersonalDetailsPref = b1;
function g1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#personalDetailsPref", t);
}
oe.validatePersonalDetailsPref = g1;
function x1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#feedViewPref";
}
oe.isFeedViewPref = x1;
function E1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#feedViewPref", t);
}
oe.validateFeedViewPref = E1;
function v1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#threadViewPref";
}
oe.isThreadViewPref = v1;
function R1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#threadViewPref", t);
}
oe.validateThreadViewPref = R1;
function A1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#interestsPref";
}
oe.isInterestsPref = A1;
function _1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#interestsPref", t);
}
oe.validateInterestsPref = _1;
function w1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWord";
}
oe.isMutedWord = w1;
function T1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#mutedWord", t);
}
oe.validateMutedWord = T1;
function C1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWordsPref";
}
oe.isMutedWordsPref = C1;
function S1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#mutedWordsPref", t);
}
oe.validateMutedWordsPref = S1;
function L1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#hiddenPostsPref";
}
oe.isHiddenPostsPref = L1;
function k1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#hiddenPostsPref", t);
}
oe.validateHiddenPostsPref = k1;
function D1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelersPref";
}
oe.isLabelersPref = D1;
function P1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#labelersPref", t);
}
oe.validateLabelersPref = P1;
function B1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelerPrefItem";
}
oe.isLabelerPrefItem = B1;
function I1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#labelerPrefItem", t);
}
oe.validateLabelerPrefItem = I1;
function U1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#bskyAppStatePref";
}
oe.isBskyAppStatePref = U1;
function O1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#bskyAppStatePref", t);
}
oe.validateBskyAppStatePref = O1;
function K1(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#bskyAppProgressGuide";
}
oe.isBskyAppProgressGuide = K1;
function M1(t) {
  return pt.lexicons.validate("app.bsky.actor.defs#bskyAppProgressGuide", t);
}
oe.validateBskyAppProgressGuide = M1;
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
Cs.validateRecord = Cs.isRecord = void 0;
const Jd = we, N1 = Le;
function V1(t) {
  return (0, Jd.isObj)(t) && (0, Jd.hasProp)(t, "$type") && (t.$type === "app.bsky.actor.profile#main" || t.$type === "app.bsky.actor.profile");
}
Cs.isRecord = V1;
function j1(t) {
  return N1.lexicons.validate("app.bsky.actor.profile#main", t);
}
Cs.validateRecord = j1;
var Ot = {};
Object.defineProperty(Ot, "__esModule", { value: !0 });
Ot.validateViewExternal = Ot.isViewExternal = Ot.validateView = Ot.isView = Ot.validateExternal = Ot.isExternal = Ot.validateMain = Ot.isMain = void 0;
const yn = we, Nu = Le;
function F1(t) {
  return (0, yn.isObj)(t) && (0, yn.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.external#main" || t.$type === "app.bsky.embed.external");
}
Ot.isMain = F1;
function $1(t) {
  return Nu.lexicons.validate("app.bsky.embed.external#main", t);
}
Ot.validateMain = $1;
function G1(t) {
  return (0, yn.isObj)(t) && (0, yn.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#external";
}
Ot.isExternal = G1;
function q1(t) {
  return Nu.lexicons.validate("app.bsky.embed.external#external", t);
}
Ot.validateExternal = q1;
function z1(t) {
  return (0, yn.isObj)(t) && (0, yn.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#view";
}
Ot.isView = z1;
function X1(t) {
  return Nu.lexicons.validate("app.bsky.embed.external#view", t);
}
Ot.validateView = X1;
function H1(t) {
  return (0, yn.isObj)(t) && (0, yn.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#viewExternal";
}
Ot.isViewExternal = H1;
function Z1(t) {
  return Nu.lexicons.validate("app.bsky.embed.external#viewExternal", t);
}
Ot.validateViewExternal = Z1;
var mt = {};
Object.defineProperty(mt, "__esModule", { value: !0 });
mt.validateViewImage = mt.isViewImage = mt.validateView = mt.isView = mt.validateAspectRatio = mt.isAspectRatio = mt.validateImage = mt.isImage = mt.validateMain = mt.isMain = void 0;
const yi = we, Ml = Le;
function W1(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.images#main" || t.$type === "app.bsky.embed.images");
}
mt.isMain = W1;
function Y1(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#main", t);
}
mt.validateMain = Y1;
function J1(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#image";
}
mt.isImage = J1;
function Q1(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#image", t);
}
mt.validateImage = Q1;
function eL(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#aspectRatio";
}
mt.isAspectRatio = eL;
function tL(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#aspectRatio", t);
}
mt.validateAspectRatio = tL;
function rL(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#view";
}
mt.isView = rL;
function iL(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#view", t);
}
mt.validateView = iL;
function nL(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#viewImage";
}
mt.isViewImage = nL;
function sL(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#viewImage", t);
}
mt.validateViewImage = sL;
var yt = {};
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.validateViewBlocked = yt.isViewBlocked = yt.validateViewNotFound = yt.isViewNotFound = yt.validateViewRecord = yt.isViewRecord = yt.validateView = yt.isView = yt.validateMain = yt.isMain = void 0;
const bi = we, Nl = Le;
function aL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.record#main" || t.$type === "app.bsky.embed.record");
}
yt.isMain = aL;
function oL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#main", t);
}
yt.validateMain = oL;
function lL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#view";
}
yt.isView = lL;
function uL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#view", t);
}
yt.validateView = uL;
function cL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewRecord";
}
yt.isViewRecord = cL;
function dL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#viewRecord", t);
}
yt.validateViewRecord = dL;
function fL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewNotFound";
}
yt.isViewNotFound = fL;
function pL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#viewNotFound", t);
}
yt.validateViewNotFound = pL;
function hL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewBlocked";
}
yt.isViewBlocked = hL;
function mL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#viewBlocked", t);
}
yt.validateViewBlocked = mL;
var ai = {};
Object.defineProperty(ai, "__esModule", { value: !0 });
ai.validateView = ai.isView = ai.validateMain = ai.isMain = void 0;
const Tu = we, X0 = Le;
function yL(t) {
  return (0, Tu.isObj)(t) && (0, Tu.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.recordWithMedia#main" || t.$type === "app.bsky.embed.recordWithMedia");
}
ai.isMain = yL;
function bL(t) {
  return X0.lexicons.validate("app.bsky.embed.recordWithMedia#main", t);
}
ai.validateMain = bL;
function gL(t) {
  return (0, Tu.isObj)(t) && (0, Tu.hasProp)(t, "$type") && t.$type === "app.bsky.embed.recordWithMedia#view";
}
ai.isView = gL;
function xL(t) {
  return X0.lexicons.validate("app.bsky.embed.recordWithMedia#view", t);
}
ai.validateView = xL;
var de = {};
Object.defineProperty(de, "__esModule", { value: !0 });
de.INTERACTIONSHARE = de.INTERACTIONQUOTE = de.INTERACTIONREPLY = de.INTERACTIONREPOST = de.INTERACTIONLIKE = de.INTERACTIONSEEN = de.CLICKTHROUGHEMBED = de.CLICKTHROUGHREPOSTER = de.CLICKTHROUGHAUTHOR = de.CLICKTHROUGHITEM = de.REQUESTMORE = de.REQUESTLESS = de.validateInteraction = de.isInteraction = de.validateThreadgateView = de.isThreadgateView = de.validateSkeletonReasonRepost = de.isSkeletonReasonRepost = de.validateSkeletonFeedPost = de.isSkeletonFeedPost = de.validateGeneratorViewerState = de.isGeneratorViewerState = de.validateGeneratorView = de.isGeneratorView = de.validateBlockedAuthor = de.isBlockedAuthor = de.validateBlockedPost = de.isBlockedPost = de.validateNotFoundPost = de.isNotFoundPost = de.validateThreadViewPost = de.isThreadViewPost = de.validateReasonRepost = de.isReasonRepost = de.validateReplyRef = de.isReplyRef = de.validateFeedViewPost = de.isFeedViewPost = de.validateViewerState = de.isViewerState = de.validatePostView = de.isPostView = void 0;
const Ze = we, cr = Le;
function EL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#postView";
}
de.isPostView = EL;
function vL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#postView", t);
}
de.validatePostView = vL;
function RL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#viewerState";
}
de.isViewerState = RL;
function AL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#viewerState", t);
}
de.validateViewerState = AL;
function _L(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#feedViewPost";
}
de.isFeedViewPost = _L;
function wL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#feedViewPost", t);
}
de.validateFeedViewPost = wL;
function TL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#replyRef";
}
de.isReplyRef = TL;
function CL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#replyRef", t);
}
de.validateReplyRef = CL;
function SL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#reasonRepost";
}
de.isReasonRepost = SL;
function LL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#reasonRepost", t);
}
de.validateReasonRepost = LL;
function kL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadViewPost";
}
de.isThreadViewPost = kL;
function DL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#threadViewPost", t);
}
de.validateThreadViewPost = DL;
function PL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#notFoundPost";
}
de.isNotFoundPost = PL;
function BL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#notFoundPost", t);
}
de.validateNotFoundPost = BL;
function IL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedPost";
}
de.isBlockedPost = IL;
function UL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#blockedPost", t);
}
de.validateBlockedPost = UL;
function OL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedAuthor";
}
de.isBlockedAuthor = OL;
function KL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#blockedAuthor", t);
}
de.validateBlockedAuthor = KL;
function ML(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorView";
}
de.isGeneratorView = ML;
function NL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#generatorView", t);
}
de.validateGeneratorView = NL;
function VL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorViewerState";
}
de.isGeneratorViewerState = VL;
function jL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#generatorViewerState", t);
}
de.validateGeneratorViewerState = jL;
function FL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonFeedPost";
}
de.isSkeletonFeedPost = FL;
function $L(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", t);
}
de.validateSkeletonFeedPost = $L;
function GL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonReasonRepost";
}
de.isSkeletonReasonRepost = GL;
function qL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", t);
}
de.validateSkeletonReasonRepost = qL;
function zL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadgateView";
}
de.isThreadgateView = zL;
function XL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#threadgateView", t);
}
de.validateThreadgateView = XL;
function HL(t) {
  return (0, Ze.isObj)(t) && (0, Ze.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#interaction";
}
de.isInteraction = HL;
function ZL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#interaction", t);
}
de.validateInteraction = ZL;
de.REQUESTLESS = "app.bsky.feed.defs#requestLess";
de.REQUESTMORE = "app.bsky.feed.defs#requestMore";
de.CLICKTHROUGHITEM = "app.bsky.feed.defs#clickthroughItem";
de.CLICKTHROUGHAUTHOR = "app.bsky.feed.defs#clickthroughAuthor";
de.CLICKTHROUGHREPOSTER = "app.bsky.feed.defs#clickthroughReposter";
de.CLICKTHROUGHEMBED = "app.bsky.feed.defs#clickthroughEmbed";
de.INTERACTIONSEEN = "app.bsky.feed.defs#interactionSeen";
de.INTERACTIONLIKE = "app.bsky.feed.defs#interactionLike";
de.INTERACTIONREPOST = "app.bsky.feed.defs#interactionRepost";
de.INTERACTIONREPLY = "app.bsky.feed.defs#interactionReply";
de.INTERACTIONQUOTE = "app.bsky.feed.defs#interactionQuote";
de.INTERACTIONSHARE = "app.bsky.feed.defs#interactionShare";
var Ss = {};
Object.defineProperty(Ss, "__esModule", { value: !0 });
Ss.validateRecord = Ss.isRecord = void 0;
const Qd = we, WL = Le;
function YL(t) {
  return (0, Qd.isObj)(t) && (0, Qd.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.generator#main" || t.$type === "app.bsky.feed.generator");
}
Ss.isRecord = YL;
function JL(t) {
  return WL.lexicons.validate("app.bsky.feed.generator#main", t);
}
Ss.validateRecord = JL;
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 });
Ls.validateRecord = Ls.isRecord = void 0;
const ef = we, QL = Le;
function ek(t) {
  return (0, ef.isObj)(t) && (0, ef.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.like#main" || t.$type === "app.bsky.feed.like");
}
Ls.isRecord = ek;
function tk(t) {
  return QL.lexicons.validate("app.bsky.feed.like#main", t);
}
Ls.validateRecord = tk;
var Kt = {};
Object.defineProperty(Kt, "__esModule", { value: !0 });
Kt.validateTextSlice = Kt.isTextSlice = Kt.validateEntity = Kt.isEntity = Kt.validateReplyRef = Kt.isReplyRef = Kt.validateRecord = Kt.isRecord = void 0;
const bn = we, Vu = Le;
function rk(t) {
  return (0, bn.isObj)(t) && (0, bn.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.post#main" || t.$type === "app.bsky.feed.post");
}
Kt.isRecord = rk;
function ik(t) {
  return Vu.lexicons.validate("app.bsky.feed.post#main", t);
}
Kt.validateRecord = ik;
function nk(t) {
  return (0, bn.isObj)(t) && (0, bn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#replyRef";
}
Kt.isReplyRef = nk;
function sk(t) {
  return Vu.lexicons.validate("app.bsky.feed.post#replyRef", t);
}
Kt.validateReplyRef = sk;
function ak(t) {
  return (0, bn.isObj)(t) && (0, bn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#entity";
}
Kt.isEntity = ak;
function ok(t) {
  return Vu.lexicons.validate("app.bsky.feed.post#entity", t);
}
Kt.validateEntity = ok;
function lk(t) {
  return (0, bn.isObj)(t) && (0, bn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#textSlice";
}
Kt.isTextSlice = lk;
function uk(t) {
  return Vu.lexicons.validate("app.bsky.feed.post#textSlice", t);
}
Kt.validateTextSlice = uk;
var ks = {};
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.validateRecord = ks.isRecord = void 0;
const tf = we, ck = Le;
function dk(t) {
  return (0, tf.isObj)(t) && (0, tf.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.repost#main" || t.$type === "app.bsky.feed.repost");
}
ks.isRecord = dk;
function fk(t) {
  return ck.lexicons.validate("app.bsky.feed.repost#main", t);
}
ks.validateRecord = fk;
var Mt = {};
Object.defineProperty(Mt, "__esModule", { value: !0 });
Mt.validateListRule = Mt.isListRule = Mt.validateFollowingRule = Mt.isFollowingRule = Mt.validateMentionRule = Mt.isMentionRule = Mt.validateRecord = Mt.isRecord = void 0;
const gn = we, ju = Le;
function pk(t) {
  return (0, gn.isObj)(t) && (0, gn.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.threadgate#main" || t.$type === "app.bsky.feed.threadgate");
}
Mt.isRecord = pk;
function hk(t) {
  return ju.lexicons.validate("app.bsky.feed.threadgate#main", t);
}
Mt.validateRecord = hk;
function mk(t) {
  return (0, gn.isObj)(t) && (0, gn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#mentionRule";
}
Mt.isMentionRule = mk;
function yk(t) {
  return ju.lexicons.validate("app.bsky.feed.threadgate#mentionRule", t);
}
Mt.validateMentionRule = yk;
function bk(t) {
  return (0, gn.isObj)(t) && (0, gn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#followingRule";
}
Mt.isFollowingRule = bk;
function gk(t) {
  return ju.lexicons.validate("app.bsky.feed.threadgate#followingRule", t);
}
Mt.validateFollowingRule = gk;
function xk(t) {
  return (0, gn.isObj)(t) && (0, gn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#listRule";
}
Mt.isListRule = xk;
function Ek(t) {
  return ju.lexicons.validate("app.bsky.feed.threadgate#listRule", t);
}
Mt.validateListRule = Ek;
var Ds = {};
Object.defineProperty(Ds, "__esModule", { value: !0 });
Ds.validateRecord = Ds.isRecord = void 0;
const rf = we, vk = Le;
function Rk(t) {
  return (0, rf.isObj)(t) && (0, rf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.block#main" || t.$type === "app.bsky.graph.block");
}
Ds.isRecord = Rk;
function Ak(t) {
  return vk.lexicons.validate("app.bsky.graph.block#main", t);
}
Ds.validateRecord = Ak;
var Ne = {};
Object.defineProperty(Ne, "__esModule", { value: !0 });
Ne.validateRelationship = Ne.isRelationship = Ne.validateNotFoundActor = Ne.isNotFoundActor = Ne.validateListViewerState = Ne.isListViewerState = Ne.REFERENCELIST = Ne.CURATELIST = Ne.MODLIST = Ne.validateStarterPackViewBasic = Ne.isStarterPackViewBasic = Ne.validateStarterPackView = Ne.isStarterPackView = Ne.validateListItemView = Ne.isListItemView = Ne.validateListView = Ne.isListView = Ne.validateListViewBasic = Ne.isListViewBasic = void 0;
const er = we, Tn = Le;
function _k(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewBasic";
}
Ne.isListViewBasic = _k;
function wk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#listViewBasic", t);
}
Ne.validateListViewBasic = wk;
function Tk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listView";
}
Ne.isListView = Tk;
function Ck(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#listView", t);
}
Ne.validateListView = Ck;
function Sk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listItemView";
}
Ne.isListItemView = Sk;
function Lk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#listItemView", t);
}
Ne.validateListItemView = Lk;
function kk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#starterPackView";
}
Ne.isStarterPackView = kk;
function Dk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#starterPackView", t);
}
Ne.validateStarterPackView = Dk;
function Pk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#starterPackViewBasic";
}
Ne.isStarterPackViewBasic = Pk;
function Bk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#starterPackViewBasic", t);
}
Ne.validateStarterPackViewBasic = Bk;
Ne.MODLIST = "app.bsky.graph.defs#modlist";
Ne.CURATELIST = "app.bsky.graph.defs#curatelist";
Ne.REFERENCELIST = "app.bsky.graph.defs#referencelist";
function Ik(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewerState";
}
Ne.isListViewerState = Ik;
function Uk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#listViewerState", t);
}
Ne.validateListViewerState = Uk;
function Ok(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#notFoundActor";
}
Ne.isNotFoundActor = Ok;
function Kk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#notFoundActor", t);
}
Ne.validateNotFoundActor = Kk;
function Mk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#relationship";
}
Ne.isRelationship = Mk;
function Nk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#relationship", t);
}
Ne.validateRelationship = Nk;
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
Ps.validateRecord = Ps.isRecord = void 0;
const nf = we, Vk = Le;
function jk(t) {
  return (0, nf.isObj)(t) && (0, nf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.follow#main" || t.$type === "app.bsky.graph.follow");
}
Ps.isRecord = jk;
function Fk(t) {
  return Vk.lexicons.validate("app.bsky.graph.follow#main", t);
}
Ps.validateRecord = Fk;
var Bs = {};
Object.defineProperty(Bs, "__esModule", { value: !0 });
Bs.validateRecord = Bs.isRecord = void 0;
const sf = we, $k = Le;
function Gk(t) {
  return (0, sf.isObj)(t) && (0, sf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.list#main" || t.$type === "app.bsky.graph.list");
}
Bs.isRecord = Gk;
function qk(t) {
  return $k.lexicons.validate("app.bsky.graph.list#main", t);
}
Bs.validateRecord = qk;
var Is = {};
Object.defineProperty(Is, "__esModule", { value: !0 });
Is.validateRecord = Is.isRecord = void 0;
const af = we, zk = Le;
function Xk(t) {
  return (0, af.isObj)(t) && (0, af.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listblock#main" || t.$type === "app.bsky.graph.listblock");
}
Is.isRecord = Xk;
function Hk(t) {
  return zk.lexicons.validate("app.bsky.graph.listblock#main", t);
}
Is.validateRecord = Hk;
var Us = {};
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.validateRecord = Us.isRecord = void 0;
const of = we, Zk = Le;
function Wk(t) {
  return (0, of.isObj)(t) && (0, of.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listitem#main" || t.$type === "app.bsky.graph.listitem");
}
Us.isRecord = Wk;
function Yk(t) {
  return Zk.lexicons.validate("app.bsky.graph.listitem#main", t);
}
Us.validateRecord = Yk;
var oi = {};
Object.defineProperty(oi, "__esModule", { value: !0 });
oi.validateFeedItem = oi.isFeedItem = oi.validateRecord = oi.isRecord = void 0;
const Cu = we, H0 = Le;
function Jk(t) {
  return (0, Cu.isObj)(t) && (0, Cu.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.starterpack#main" || t.$type === "app.bsky.graph.starterpack");
}
oi.isRecord = Jk;
function Qk(t) {
  return H0.lexicons.validate("app.bsky.graph.starterpack#main", t);
}
oi.validateRecord = Qk;
function eD(t) {
  return (0, Cu.isObj)(t) && (0, Cu.hasProp)(t, "$type") && t.$type === "app.bsky.graph.starterpack#feedItem";
}
oi.isFeedItem = eD;
function tD(t) {
  return H0.lexicons.validate("app.bsky.graph.starterpack#feedItem", t);
}
oi.validateFeedItem = tD;
var Nt = {};
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.validateLabelerPolicies = Nt.isLabelerPolicies = Nt.validateLabelerViewerState = Nt.isLabelerViewerState = Nt.validateLabelerViewDetailed = Nt.isLabelerViewDetailed = Nt.validateLabelerView = Nt.isLabelerView = void 0;
const xn = we, Fu = Le;
function rD(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerView";
}
Nt.isLabelerView = rD;
function iD(t) {
  return Fu.lexicons.validate("app.bsky.labeler.defs#labelerView", t);
}
Nt.validateLabelerView = iD;
function nD(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewDetailed";
}
Nt.isLabelerViewDetailed = nD;
function sD(t) {
  return Fu.lexicons.validate("app.bsky.labeler.defs#labelerViewDetailed", t);
}
Nt.validateLabelerViewDetailed = sD;
function aD(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewerState";
}
Nt.isLabelerViewerState = aD;
function oD(t) {
  return Fu.lexicons.validate("app.bsky.labeler.defs#labelerViewerState", t);
}
Nt.validateLabelerViewerState = oD;
function lD(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerPolicies";
}
Nt.isLabelerPolicies = lD;
function uD(t) {
  return Fu.lexicons.validate("app.bsky.labeler.defs#labelerPolicies", t);
}
Nt.validateLabelerPolicies = uD;
var Os = {};
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.validateRecord = Os.isRecord = void 0;
const lf = we, cD = Le;
function dD(t) {
  return (0, lf.isObj)(t) && (0, lf.hasProp)(t, "$type") && (t.$type === "app.bsky.labeler.service#main" || t.$type === "app.bsky.labeler.service");
}
Os.isRecord = dD;
function fD(t) {
  return cD.lexicons.validate("app.bsky.labeler.service#main", t);
}
Os.validateRecord = fD;
var bt = {};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.validateByteSlice = bt.isByteSlice = bt.validateTag = bt.isTag = bt.validateLink = bt.isLink = bt.validateMention = bt.isMention = bt.validateMain = bt.isMain = void 0;
const gi = we, Vl = Le;
function pD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && (t.$type === "app.bsky.richtext.facet#main" || t.$type === "app.bsky.richtext.facet");
}
bt.isMain = pD;
function hD(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#main", t);
}
bt.validateMain = hD;
function mD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#mention";
}
bt.isMention = mD;
function yD(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#mention", t);
}
bt.validateMention = yD;
function bD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#link";
}
bt.isLink = bD;
function gD(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#link", t);
}
bt.validateLink = gD;
function xD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#tag";
}
bt.isTag = xD;
function ED(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#tag", t);
}
bt.validateTag = ED;
function vD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#byteSlice";
}
bt.isByteSlice = vD;
function RD(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#byteSlice", t);
}
bt.validateByteSlice = RD;
var li = {};
Object.defineProperty(li, "__esModule", { value: !0 });
li.validateSkeletonSearchActor = li.isSkeletonSearchActor = li.validateSkeletonSearchPost = li.isSkeletonSearchPost = void 0;
const Su = we, Z0 = Le;
function AD(t) {
  return (0, Su.isObj)(t) && (0, Su.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
}
li.isSkeletonSearchPost = AD;
function _D(t) {
  return Z0.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", t);
}
li.validateSkeletonSearchPost = _D;
function wD(t) {
  return (0, Su.isObj)(t) && (0, Su.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
}
li.isSkeletonSearchActor = wD;
function TD(t) {
  return Z0.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", t);
}
li.validateSkeletonSearchActor = TD;
var Ks = {};
Object.defineProperty(Ks, "__esModule", { value: !0 });
Ks.validateRecord = Ks.isRecord = void 0;
const uf = we, CD = Le;
function SD(t) {
  return (0, uf.isObj)(t) && (0, uf.hasProp)(t, "$type") && (t.$type === "chat.bsky.actor.declaration#main" || t.$type === "chat.bsky.actor.declaration");
}
Ks.isRecord = SD;
function LD(t) {
  return CD.lexicons.validate("chat.bsky.actor.declaration#main", t);
}
Ks.validateRecord = LD;
var Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.validateProfileViewBasic = Ms.isProfileViewBasic = void 0;
const cf = we, kD = Le;
function DD(t) {
  return (0, cf.isObj)(t) && (0, cf.hasProp)(t, "$type") && t.$type === "chat.bsky.actor.defs#profileViewBasic";
}
Ms.isProfileViewBasic = DD;
function PD(t) {
  return kD.lexicons.validate("chat.bsky.actor.defs#profileViewBasic", t);
}
Ms.validateProfileViewBasic = PD;
var Oe = {};
Object.defineProperty(Oe, "__esModule", { value: !0 });
Oe.validateLogDeleteMessage = Oe.isLogDeleteMessage = Oe.validateLogCreateMessage = Oe.isLogCreateMessage = Oe.validateLogLeaveConvo = Oe.isLogLeaveConvo = Oe.validateLogBeginConvo = Oe.isLogBeginConvo = Oe.validateConvoView = Oe.isConvoView = Oe.validateMessageViewSender = Oe.isMessageViewSender = Oe.validateDeletedMessageView = Oe.isDeletedMessageView = Oe.validateMessageView = Oe.isMessageView = Oe.validateMessageInput = Oe.isMessageInput = Oe.validateMessageRef = Oe.isMessageRef = void 0;
const wt = we, Ai = Le;
function BD(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageRef";
}
Oe.isMessageRef = BD;
function ID(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#messageRef", t);
}
Oe.validateMessageRef = ID;
function UD(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageInput";
}
Oe.isMessageInput = UD;
function OD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#messageInput", t);
}
Oe.validateMessageInput = OD;
function KD(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageView";
}
Oe.isMessageView = KD;
function MD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#messageView", t);
}
Oe.validateMessageView = MD;
function ND(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#deletedMessageView";
}
Oe.isDeletedMessageView = ND;
function VD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#deletedMessageView", t);
}
Oe.validateDeletedMessageView = VD;
function jD(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageViewSender";
}
Oe.isMessageViewSender = jD;
function FD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#messageViewSender", t);
}
Oe.validateMessageViewSender = FD;
function $D(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#convoView";
}
Oe.isConvoView = $D;
function GD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#convoView", t);
}
Oe.validateConvoView = GD;
function qD(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logBeginConvo";
}
Oe.isLogBeginConvo = qD;
function zD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#logBeginConvo", t);
}
Oe.validateLogBeginConvo = zD;
function XD(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logLeaveConvo";
}
Oe.isLogLeaveConvo = XD;
function HD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#logLeaveConvo", t);
}
Oe.validateLogLeaveConvo = HD;
function ZD(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logCreateMessage";
}
Oe.isLogCreateMessage = ZD;
function WD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#logCreateMessage", t);
}
Oe.validateLogCreateMessage = WD;
function YD(t) {
  return (0, wt.isObj)(t) && (0, wt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logDeleteMessage";
}
Oe.isLogDeleteMessage = YD;
function JD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#logDeleteMessage", t);
}
Oe.validateLogDeleteMessage = JD;
var Ns = {};
Object.defineProperty(Ns, "__esModule", { value: !0 });
Ns.validateTemplateView = Ns.isTemplateView = void 0;
const df = we, QD = Le;
function eP(t) {
  return (0, df.isObj)(t) && (0, df.hasProp)(t, "$type") && t.$type === "tools.ozone.communication.defs#templateView";
}
Ns.isTemplateView = eP;
function tP(t) {
  return QD.lexicons.validate("tools.ozone.communication.defs#templateView", t);
}
Ns.validateTemplateView = tP;
var J = {};
Object.defineProperty(J, "__esModule", { value: !0 });
J.validateRecordViewDetail = J.isRecordViewDetail = J.validateRecordView = J.isRecordView = J.validateRepoViewNotFound = J.isRepoViewNotFound = J.validateRepoViewDetail = J.isRepoViewDetail = J.validateRepoView = J.isRepoView = J.validateModEventTag = J.isModEventTag = J.validateModEventDivert = J.isModEventDivert = J.validateModEventEmail = J.isModEventEmail = J.validateModEventUnmuteReporter = J.isModEventUnmuteReporter = J.validateModEventMuteReporter = J.isModEventMuteReporter = J.validateModEventUnmute = J.isModEventUnmute = J.validateModEventMute = J.isModEventMute = J.validateModEventEscalate = J.isModEventEscalate = J.validateModEventAcknowledge = J.isModEventAcknowledge = J.validateModEventLabel = J.isModEventLabel = J.validateModEventReport = J.isModEventReport = J.validateModEventComment = J.isModEventComment = J.validateModEventResolveAppeal = J.isModEventResolveAppeal = J.validateModEventReverseTakedown = J.isModEventReverseTakedown = J.validateModEventTakedown = J.isModEventTakedown = J.REVIEWNONE = J.REVIEWCLOSED = J.REVIEWESCALATED = J.REVIEWOPEN = J.validateSubjectStatusView = J.isSubjectStatusView = J.validateModEventViewDetail = J.isModEventViewDetail = J.validateModEventView = J.isModEventView = void 0;
J.validateVideoDetails = J.isVideoDetails = J.validateImageDetails = J.isImageDetails = J.validateBlobView = J.isBlobView = J.validateModerationDetail = J.isModerationDetail = J.validateModeration = J.isModeration = J.validateRecordViewNotFound = J.isRecordViewNotFound = void 0;
const Re = we, We = Le;
function rP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventView";
}
J.isModEventView = rP;
function iP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventView", t);
}
J.validateModEventView = iP;
function nP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventViewDetail";
}
J.isModEventViewDetail = nP;
function sP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventViewDetail", t);
}
J.validateModEventViewDetail = sP;
function aP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#subjectStatusView";
}
J.isSubjectStatusView = aP;
function oP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#subjectStatusView", t);
}
J.validateSubjectStatusView = oP;
J.REVIEWOPEN = "tools.ozone.moderation.defs#reviewOpen";
J.REVIEWESCALATED = "tools.ozone.moderation.defs#reviewEscalated";
J.REVIEWCLOSED = "tools.ozone.moderation.defs#reviewClosed";
J.REVIEWNONE = "tools.ozone.moderation.defs#reviewNone";
function lP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTakedown";
}
J.isModEventTakedown = lP;
function uP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventTakedown", t);
}
J.validateModEventTakedown = uP;
function cP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReverseTakedown";
}
J.isModEventReverseTakedown = cP;
function dP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventReverseTakedown", t);
}
J.validateModEventReverseTakedown = dP;
function fP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventResolveAppeal";
}
J.isModEventResolveAppeal = fP;
function pP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventResolveAppeal", t);
}
J.validateModEventResolveAppeal = pP;
function hP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventComment";
}
J.isModEventComment = hP;
function mP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventComment", t);
}
J.validateModEventComment = mP;
function yP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReport";
}
J.isModEventReport = yP;
function bP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventReport", t);
}
J.validateModEventReport = bP;
function gP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventLabel";
}
J.isModEventLabel = gP;
function xP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventLabel", t);
}
J.validateModEventLabel = xP;
function EP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventAcknowledge";
}
J.isModEventAcknowledge = EP;
function vP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventAcknowledge", t);
}
J.validateModEventAcknowledge = vP;
function RP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEscalate";
}
J.isModEventEscalate = RP;
function AP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventEscalate", t);
}
J.validateModEventEscalate = AP;
function _P(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMute";
}
J.isModEventMute = _P;
function wP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventMute", t);
}
J.validateModEventMute = wP;
function TP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmute";
}
J.isModEventUnmute = TP;
function CP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventUnmute", t);
}
J.validateModEventUnmute = CP;
function SP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMuteReporter";
}
J.isModEventMuteReporter = SP;
function LP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventMuteReporter", t);
}
J.validateModEventMuteReporter = LP;
function kP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmuteReporter";
}
J.isModEventUnmuteReporter = kP;
function DP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventUnmuteReporter", t);
}
J.validateModEventUnmuteReporter = DP;
function PP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEmail";
}
J.isModEventEmail = PP;
function BP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventEmail", t);
}
J.validateModEventEmail = BP;
function IP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventDivert";
}
J.isModEventDivert = IP;
function UP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventDivert", t);
}
J.validateModEventDivert = UP;
function OP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTag";
}
J.isModEventTag = OP;
function KP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#modEventTag", t);
}
J.validateModEventTag = KP;
function MP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoView";
}
J.isRepoView = MP;
function NP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#repoView", t);
}
J.validateRepoView = NP;
function VP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewDetail";
}
J.isRepoViewDetail = VP;
function jP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#repoViewDetail", t);
}
J.validateRepoViewDetail = jP;
function FP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewNotFound";
}
J.isRepoViewNotFound = FP;
function $P(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#repoViewNotFound", t);
}
J.validateRepoViewNotFound = $P;
function GP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordView";
}
J.isRecordView = GP;
function qP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#recordView", t);
}
J.validateRecordView = qP;
function zP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewDetail";
}
J.isRecordViewDetail = zP;
function XP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#recordViewDetail", t);
}
J.validateRecordViewDetail = XP;
function HP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewNotFound";
}
J.isRecordViewNotFound = HP;
function ZP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#recordViewNotFound", t);
}
J.validateRecordViewNotFound = ZP;
function WP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderation";
}
J.isModeration = WP;
function YP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#moderation", t);
}
J.validateModeration = YP;
function JP(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderationDetail";
}
J.isModerationDetail = JP;
function QP(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#moderationDetail", t);
}
J.validateModerationDetail = QP;
function eB(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#blobView";
}
J.isBlobView = eB;
function tB(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#blobView", t);
}
J.validateBlobView = tB;
function rB(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#imageDetails";
}
J.isImageDetails = rB;
function iB(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#imageDetails", t);
}
J.validateImageDetails = iB;
function nB(t) {
  return (0, Re.isObj)(t) && (0, Re.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#videoDetails";
}
J.isVideoDetails = nB;
function sB(t) {
  return We.lexicons.validate("tools.ozone.moderation.defs#videoDetails", t);
}
J.validateVideoDetails = sB;
var Dr = {};
Object.defineProperty(Dr, "__esModule", { value: !0 });
Dr.ROLETRIAGE = Dr.ROLEMODERATOR = Dr.ROLEADMIN = Dr.validateMember = Dr.isMember = void 0;
const ff = we, aB = Le;
function oB(t) {
  return (0, ff.isObj)(t) && (0, ff.hasProp)(t, "$type") && t.$type === "tools.ozone.team.defs#member";
}
Dr.isMember = oB;
function lB(t) {
  return aB.lexicons.validate("tools.ozone.team.defs#member", t);
}
Dr.validateMember = lB;
Dr.ROLEADMIN = "tools.ozone.team.defs#roleAdmin";
Dr.ROLEMODERATOR = "tools.ozone.team.defs#roleModerator";
Dr.ROLETRIAGE = "tools.ozone.team.defs#roleTriage";
var uB = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), cB = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), _ = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && uB(e, t, r);
  return cB(e, t), e;
};
Object.defineProperty(x, "__esModule", { value: !0 });
x.ComAtprotoServerDescribeServer = x.ComAtprotoServerDeleteSession = x.ComAtprotoServerDeleteAccount = x.ComAtprotoServerDefs = x.ComAtprotoServerDeactivateAccount = x.ComAtprotoServerCreateSession = x.ComAtprotoServerCreateInviteCodes = x.ComAtprotoServerCreateInviteCode = x.ComAtprotoServerCreateAppPassword = x.ComAtprotoServerCreateAccount = x.ComAtprotoServerConfirmEmail = x.ComAtprotoServerCheckAccountStatus = x.ComAtprotoServerActivateAccount = x.ComAtprotoRepoUploadBlob = x.ComAtprotoRepoStrongRef = x.ComAtprotoRepoPutRecord = x.ComAtprotoRepoListRecords = x.ComAtprotoRepoListMissingBlobs = x.ComAtprotoRepoImportRepo = x.ComAtprotoRepoGetRecord = x.ComAtprotoRepoDescribeRepo = x.ComAtprotoRepoDeleteRecord = x.ComAtprotoRepoCreateRecord = x.ComAtprotoRepoApplyWrites = x.ComAtprotoModerationDefs = x.ComAtprotoModerationCreateReport = x.ComAtprotoLabelSubscribeLabels = x.ComAtprotoLabelQueryLabels = x.ComAtprotoLabelDefs = x.ComAtprotoIdentityUpdateHandle = x.ComAtprotoIdentitySubmitPlcOperation = x.ComAtprotoIdentitySignPlcOperation = x.ComAtprotoIdentityResolveHandle = x.ComAtprotoIdentityRequestPlcOperationSignature = x.ComAtprotoIdentityGetRecommendedDidCredentials = x.ComAtprotoAdminUpdateSubjectStatus = x.ComAtprotoAdminUpdateAccountPassword = x.ComAtprotoAdminUpdateAccountHandle = x.ComAtprotoAdminUpdateAccountEmail = x.ComAtprotoAdminSendEmail = x.ComAtprotoAdminSearchAccounts = x.ComAtprotoAdminGetSubjectStatus = x.ComAtprotoAdminGetInviteCodes = x.ComAtprotoAdminGetAccountInfos = x.ComAtprotoAdminGetAccountInfo = x.ComAtprotoAdminEnableAccountInvites = x.ComAtprotoAdminDisableInviteCodes = x.ComAtprotoAdminDisableAccountInvites = x.ComAtprotoAdminDeleteAccount = x.ComAtprotoAdminDefs = void 0;
x.AppBskyFeedGetFeedGenerator = x.AppBskyFeedGetFeed = x.AppBskyFeedGetAuthorFeed = x.AppBskyFeedGetActorLikes = x.AppBskyFeedGetActorFeeds = x.AppBskyFeedGenerator = x.AppBskyFeedDescribeFeedGenerator = x.AppBskyFeedDefs = x.AppBskyEmbedRecordWithMedia = x.AppBskyEmbedRecord = x.AppBskyEmbedImages = x.AppBskyEmbedExternal = x.AppBskyActorSearchActorsTypeahead = x.AppBskyActorSearchActors = x.AppBskyActorPutPreferences = x.AppBskyActorProfile = x.AppBskyActorGetSuggestions = x.AppBskyActorGetProfiles = x.AppBskyActorGetProfile = x.AppBskyActorGetPreferences = x.AppBskyActorDefs = x.ComAtprotoTempRequestPhoneVerification = x.ComAtprotoTempFetchLabels = x.ComAtprotoTempCheckSignupQueue = x.ComAtprotoSyncSubscribeRepos = x.ComAtprotoSyncRequestCrawl = x.ComAtprotoSyncNotifyOfUpdate = x.ComAtprotoSyncListRepos = x.ComAtprotoSyncListBlobs = x.ComAtprotoSyncGetRepoStatus = x.ComAtprotoSyncGetRepo = x.ComAtprotoSyncGetRecord = x.ComAtprotoSyncGetLatestCommit = x.ComAtprotoSyncGetHead = x.ComAtprotoSyncGetCheckout = x.ComAtprotoSyncGetBlocks = x.ComAtprotoSyncGetBlob = x.ComAtprotoServerUpdateEmail = x.ComAtprotoServerRevokeAppPassword = x.ComAtprotoServerResetPassword = x.ComAtprotoServerReserveSigningKey = x.ComAtprotoServerRequestPasswordReset = x.ComAtprotoServerRequestEmailUpdate = x.ComAtprotoServerRequestEmailConfirmation = x.ComAtprotoServerRequestAccountDelete = x.ComAtprotoServerRefreshSession = x.ComAtprotoServerListAppPasswords = x.ComAtprotoServerGetSession = x.ComAtprotoServerGetServiceAuth = x.ComAtprotoServerGetAccountInviteCodes = void 0;
x.AppBskyNotificationUpdateSeen = x.AppBskyNotificationRegisterPush = x.AppBskyNotificationPutPreferences = x.AppBskyNotificationListNotifications = x.AppBskyNotificationGetUnreadCount = x.AppBskyLabelerService = x.AppBskyLabelerGetServices = x.AppBskyLabelerDefs = x.AppBskyGraphUnmuteThread = x.AppBskyGraphUnmuteActorList = x.AppBskyGraphUnmuteActor = x.AppBskyGraphStarterpack = x.AppBskyGraphMuteThread = x.AppBskyGraphMuteActorList = x.AppBskyGraphMuteActor = x.AppBskyGraphListitem = x.AppBskyGraphListblock = x.AppBskyGraphList = x.AppBskyGraphGetSuggestedFollowsByActor = x.AppBskyGraphGetStarterPacks = x.AppBskyGraphGetStarterPack = x.AppBskyGraphGetRelationships = x.AppBskyGraphGetMutes = x.AppBskyGraphGetLists = x.AppBskyGraphGetListMutes = x.AppBskyGraphGetListBlocks = x.AppBskyGraphGetList = x.AppBskyGraphGetKnownFollowers = x.AppBskyGraphGetFollows = x.AppBskyGraphGetFollowers = x.AppBskyGraphGetBlocks = x.AppBskyGraphGetActorStarterPacks = x.AppBskyGraphFollow = x.AppBskyGraphDefs = x.AppBskyGraphBlock = x.AppBskyFeedThreadgate = x.AppBskyFeedSendInteractions = x.AppBskyFeedSearchPosts = x.AppBskyFeedRepost = x.AppBskyFeedPost = x.AppBskyFeedLike = x.AppBskyFeedGetTimeline = x.AppBskyFeedGetSuggestedFeeds = x.AppBskyFeedGetRepostedBy = x.AppBskyFeedGetPosts = x.AppBskyFeedGetPostThread = x.AppBskyFeedGetListFeed = x.AppBskyFeedGetLikes = x.AppBskyFeedGetFeedSkeleton = x.AppBskyFeedGetFeedGenerators = void 0;
x.TOOLS_OZONE_MODERATION = x.APP_BSKY_GRAPH = x.APP_BSKY_FEED = x.COM_ATPROTO_MODERATION = x.ToolsOzoneTeamUpdateMember = x.ToolsOzoneTeamListMembers = x.ToolsOzoneTeamDeleteMember = x.ToolsOzoneTeamDefs = x.ToolsOzoneTeamAddMember = x.ToolsOzoneServerGetConfig = x.ToolsOzoneModerationSearchRepos = x.ToolsOzoneModerationQueryStatuses = x.ToolsOzoneModerationQueryEvents = x.ToolsOzoneModerationGetRepo = x.ToolsOzoneModerationGetRecord = x.ToolsOzoneModerationGetEvent = x.ToolsOzoneModerationEmitEvent = x.ToolsOzoneModerationDefs = x.ToolsOzoneCommunicationUpdateTemplate = x.ToolsOzoneCommunicationListTemplates = x.ToolsOzoneCommunicationDeleteTemplate = x.ToolsOzoneCommunicationDefs = x.ToolsOzoneCommunicationCreateTemplate = x.ChatBskyModerationUpdateActorAccess = x.ChatBskyModerationGetMessageContext = x.ChatBskyModerationGetActorMetadata = x.ChatBskyConvoUpdateRead = x.ChatBskyConvoUnmuteConvo = x.ChatBskyConvoSendMessageBatch = x.ChatBskyConvoSendMessage = x.ChatBskyConvoMuteConvo = x.ChatBskyConvoListConvos = x.ChatBskyConvoLeaveConvo = x.ChatBskyConvoGetMessages = x.ChatBskyConvoGetLog = x.ChatBskyConvoGetConvoForMembers = x.ChatBskyConvoGetConvo = x.ChatBskyConvoDeleteMessageForSelf = x.ChatBskyConvoDefs = x.ChatBskyActorExportAccountData = x.ChatBskyActorDeleteAccount = x.ChatBskyActorDefs = x.ChatBskyActorDeclaration = x.AppBskyUnspeccedSearchPostsSkeleton = x.AppBskyUnspeccedSearchActorsSkeleton = x.AppBskyUnspeccedGetTaggedSuggestions = x.AppBskyUnspeccedGetSuggestionsSkeleton = x.AppBskyUnspeccedGetPopularFeedGenerators = x.AppBskyUnspeccedDefs = x.AppBskyRichtextFacet = void 0;
x.ToolsOzoneTeamNS = x.ToolsOzoneServerNS = x.ToolsOzoneModerationNS = x.ToolsOzoneCommunicationNS = x.ToolsOzoneNS = x.ToolsNS = x.ChatBskyModerationNS = x.ChatBskyConvoNS = x.DeclarationRecord = x.ChatBskyActorNS = x.ChatBskyNS = x.ChatNS = x.AppBskyUnspeccedNS = x.AppBskyRichtextNS = x.AppBskyNotificationNS = x.ServiceRecord = x.AppBskyLabelerNS = x.StarterpackRecord = x.ListitemRecord = x.ListblockRecord = x.ListRecord = x.FollowRecord = x.BlockRecord = x.AppBskyGraphNS = x.ThreadgateRecord = x.RepostRecord = x.PostRecord = x.LikeRecord = x.GeneratorRecord = x.AppBskyFeedNS = x.AppBskyEmbedNS = x.ProfileRecord = x.AppBskyActorNS = x.AppBskyNS = x.AppNS = x.ComAtprotoTempNS = x.ComAtprotoSyncNS = x.ComAtprotoServerNS = x.ComAtprotoRepoNS = x.ComAtprotoModerationNS = x.ComAtprotoLabelNS = x.ComAtprotoIdentityNS = x.ComAtprotoAdminNS = x.ComAtprotoNS = x.ComNS = x.AtpServiceClient = x.AtpBaseClient = x.TOOLS_OZONE_TEAM = void 0;
const dB = q, fB = Le, pB = _(Da), hB = _(Pa), mB = _(Ba), yB = _(Ia), bB = _(Ua), gB = _(Oa), xB = _(Ka), EB = _(Ma), vB = _(Na), RB = _(Va), AB = _(ja), _B = _(Fa), wB = _($a), TB = _(Ga), CB = _(qa), SB = _(za), LB = _(Xa), kB = _(Ha), DB = _(Za), PB = _(Wa), BB = _(Ya), IB = _(Ja), UB = _(St), OB = _(Nn), KB = _(Vn), MB = _(Qa), NB = _(eo), VB = _(to), jB = _(Ni), FB = _(Vi), $B = _(jn), GB = _(ro), qB = _(io), zB = _(no), XB = _(Rr), HB = _(Lt), ZB = _(Vr), WB = _(ao), YB = _(ji), JB = _(Fi), QB = _(oo), eI = _($i), tI = _(lo), rI = _(Ar), iI = _(Fn), nI = _($n), sI = _(uo), aI = _(jr), oI = _(Gn), lI = _(co), uI = _(fo), cI = _(po), dI = _(ho), fI = _(mo), pI = _(Gi), hI = _(yo), mI = _(Fr), yI = _(ar), bI = _(or), gI = _(bo), xI = _(qn), EI = _(_r), vI = _(lr), RI = _(wr), AI = _(zn), _I = _(Tr), wI = _(qi), TI = _(vo), CI = _(Ro), SI = _(Ao), LI = _(_o), kI = _(wo), DI = _(To), PI = _(Co), BI = _(So), II = _(Lo), UI = _(ko), OI = _(Do), KI = _(Po), MI = _(Cr), NI = _(Bo), VI = _(zi), jI = _(Xi), FI = _(Xn), $I = _(Io), GI = _(Uo), qI = _(Hn), zI = _(Hi), XI = _(Zn), HI = _(Wn), ZI = _(Oo), WI = _(Ko), YI = _(Mo), JI = _(No), QI = _(Yn), eU = _(Vo), tU = _(jo), rU = _(Fo), iU = _($o), nU = _(Go), sU = _(qo), aU = _(zo), oU = _(Xo), lU = _(Ho), uU = _(Zo), cU = _(Wo), dU = _(Jn), fU = _(Yo), pU = _(Jo), hU = _(Qo), mU = _(el), yU = _(tl), bU = _(rl), gU = _(il), xU = _(nl), EU = _(sl), vU = _(al), RU = _(ol), AU = _(Zi), _U = _(ll), wU = _(ul), TU = _(cl), CU = _(dl), SU = _(fl), LU = _(Wi), kU = _(Qn), DU = _(es), PU = _(pl), BU = _(hl), IU = _(ml), UU = _(yl), OU = _(bl), KU = _(gl), MU = _(xl), NU = _(El), VU = _(vl), jU = _(Rl), FU = _(Al), $U = _(Yi), GU = _(_l), qU = _(wl), zU = _(Ji), XU = _(Tl), HU = _(Cl), ZU = _(Sl), WU = _(Ll), YU = _(kl), JU = _(Dl), QU = _(ts), eO = _(Pl), tO = _(rs), rO = _(is), iO = _(Bl), nO = _(Il), sO = _(Ul), aO = _(Sr), oO = _(ns), lO = _(Qi), uO = _(Ol), cO = _(ss);
x.ComAtprotoAdminDefs = _(Ut);
x.ComAtprotoAdminDeleteAccount = _(Da);
x.ComAtprotoAdminDisableAccountInvites = _(Pa);
x.ComAtprotoAdminDisableInviteCodes = _(Ba);
x.ComAtprotoAdminEnableAccountInvites = _(Ia);
x.ComAtprotoAdminGetAccountInfo = _(Ua);
x.ComAtprotoAdminGetAccountInfos = _(Oa);
x.ComAtprotoAdminGetInviteCodes = _(Ka);
x.ComAtprotoAdminGetSubjectStatus = _(Ma);
x.ComAtprotoAdminSearchAccounts = _(Na);
x.ComAtprotoAdminSendEmail = _(Va);
x.ComAtprotoAdminUpdateAccountEmail = _(ja);
x.ComAtprotoAdminUpdateAccountHandle = _(Fa);
x.ComAtprotoAdminUpdateAccountPassword = _($a);
x.ComAtprotoAdminUpdateSubjectStatus = _(Ga);
x.ComAtprotoIdentityGetRecommendedDidCredentials = _(qa);
x.ComAtprotoIdentityRequestPlcOperationSignature = _(za);
x.ComAtprotoIdentityResolveHandle = _(Xa);
x.ComAtprotoIdentitySignPlcOperation = _(Ha);
x.ComAtprotoIdentitySubmitPlcOperation = _(Za);
x.ComAtprotoIdentityUpdateHandle = _(Wa);
x.ComAtprotoLabelDefs = _(ht);
x.ComAtprotoLabelQueryLabels = _(Ya);
x.ComAtprotoLabelSubscribeLabels = _(ni);
x.ComAtprotoModerationCreateReport = _(Ja);
x.ComAtprotoModerationDefs = _(Yt);
x.ComAtprotoRepoApplyWrites = _(St);
x.ComAtprotoRepoCreateRecord = _(Nn);
x.ComAtprotoRepoDeleteRecord = _(Vn);
x.ComAtprotoRepoDescribeRepo = _(Qa);
x.ComAtprotoRepoGetRecord = _(eo);
x.ComAtprotoRepoImportRepo = _(to);
x.ComAtprotoRepoListMissingBlobs = _(Ni);
x.ComAtprotoRepoListRecords = _(Vi);
x.ComAtprotoRepoPutRecord = _(jn);
x.ComAtprotoRepoStrongRef = _(Ts);
x.ComAtprotoRepoUploadBlob = _(ro);
x.ComAtprotoServerActivateAccount = _(io);
x.ComAtprotoServerCheckAccountStatus = _(no);
x.ComAtprotoServerConfirmEmail = _(Rr);
x.ComAtprotoServerCreateAccount = _(Lt);
x.ComAtprotoServerCreateAppPassword = _(Vr);
x.ComAtprotoServerCreateInviteCode = _(ao);
x.ComAtprotoServerCreateInviteCodes = _(ji);
x.ComAtprotoServerCreateSession = _(Fi);
x.ComAtprotoServerDeactivateAccount = _(oo);
x.ComAtprotoServerDefs = _(si);
x.ComAtprotoServerDeleteAccount = _($i);
x.ComAtprotoServerDeleteSession = _(lo);
x.ComAtprotoServerDescribeServer = _(Ar);
x.ComAtprotoServerGetAccountInviteCodes = _(Fn);
x.ComAtprotoServerGetServiceAuth = _($n);
x.ComAtprotoServerGetSession = _(uo);
x.ComAtprotoServerListAppPasswords = _(jr);
x.ComAtprotoServerRefreshSession = _(Gn);
x.ComAtprotoServerRequestAccountDelete = _(co);
x.ComAtprotoServerRequestEmailConfirmation = _(fo);
x.ComAtprotoServerRequestEmailUpdate = _(po);
x.ComAtprotoServerRequestPasswordReset = _(ho);
x.ComAtprotoServerReserveSigningKey = _(mo);
x.ComAtprotoServerResetPassword = _(Gi);
x.ComAtprotoServerRevokeAppPassword = _(yo);
x.ComAtprotoServerUpdateEmail = _(Fr);
x.ComAtprotoSyncGetBlob = _(ar);
x.ComAtprotoSyncGetBlocks = _(or);
x.ComAtprotoSyncGetCheckout = _(bo);
x.ComAtprotoSyncGetHead = _(qn);
x.ComAtprotoSyncGetLatestCommit = _(_r);
x.ComAtprotoSyncGetRecord = _(lr);
x.ComAtprotoSyncGetRepo = _(wr);
x.ComAtprotoSyncGetRepoStatus = _(zn);
x.ComAtprotoSyncListBlobs = _(Tr);
x.ComAtprotoSyncListRepos = _(qi);
x.ComAtprotoSyncNotifyOfUpdate = _(vo);
x.ComAtprotoSyncRequestCrawl = _(Ro);
x.ComAtprotoSyncSubscribeRepos = _(qe);
x.ComAtprotoTempCheckSignupQueue = _(Ao);
x.ComAtprotoTempFetchLabels = _(_o);
x.ComAtprotoTempRequestPhoneVerification = _(wo);
x.AppBskyActorDefs = _(oe);
x.AppBskyActorGetPreferences = _(To);
x.AppBskyActorGetProfile = _(Co);
x.AppBskyActorGetProfiles = _(So);
x.AppBskyActorGetSuggestions = _(Lo);
x.AppBskyActorProfile = _(Cs);
x.AppBskyActorPutPreferences = _(ko);
x.AppBskyActorSearchActors = _(Do);
x.AppBskyActorSearchActorsTypeahead = _(Po);
x.AppBskyEmbedExternal = _(Ot);
x.AppBskyEmbedImages = _(mt);
x.AppBskyEmbedRecord = _(yt);
x.AppBskyEmbedRecordWithMedia = _(ai);
x.AppBskyFeedDefs = _(de);
x.AppBskyFeedDescribeFeedGenerator = _(Cr);
x.AppBskyFeedGenerator = _(Ss);
x.AppBskyFeedGetActorFeeds = _(Bo);
x.AppBskyFeedGetActorLikes = _(zi);
x.AppBskyFeedGetAuthorFeed = _(Xi);
x.AppBskyFeedGetFeed = _(Xn);
x.AppBskyFeedGetFeedGenerator = _(Io);
x.AppBskyFeedGetFeedGenerators = _(Uo);
x.AppBskyFeedGetFeedSkeleton = _(Hn);
x.AppBskyFeedGetLikes = _(Hi);
x.AppBskyFeedGetListFeed = _(Zn);
x.AppBskyFeedGetPostThread = _(Wn);
x.AppBskyFeedGetPosts = _(Oo);
x.AppBskyFeedGetRepostedBy = _(Ko);
x.AppBskyFeedGetSuggestedFeeds = _(Mo);
x.AppBskyFeedGetTimeline = _(No);
x.AppBskyFeedLike = _(Ls);
x.AppBskyFeedPost = _(Kt);
x.AppBskyFeedRepost = _(ks);
x.AppBskyFeedSearchPosts = _(Yn);
x.AppBskyFeedSendInteractions = _(Vo);
x.AppBskyFeedThreadgate = _(Mt);
x.AppBskyGraphBlock = _(Ds);
x.AppBskyGraphDefs = _(Ne);
x.AppBskyGraphFollow = _(Ps);
x.AppBskyGraphGetActorStarterPacks = _(jo);
x.AppBskyGraphGetBlocks = _(Fo);
x.AppBskyGraphGetFollowers = _($o);
x.AppBskyGraphGetFollows = _(Go);
x.AppBskyGraphGetKnownFollowers = _(qo);
x.AppBskyGraphGetList = _(zo);
x.AppBskyGraphGetListBlocks = _(Xo);
x.AppBskyGraphGetListMutes = _(Ho);
x.AppBskyGraphGetLists = _(Zo);
x.AppBskyGraphGetMutes = _(Wo);
x.AppBskyGraphGetRelationships = _(Jn);
x.AppBskyGraphGetStarterPack = _(Yo);
x.AppBskyGraphGetStarterPacks = _(Jo);
x.AppBskyGraphGetSuggestedFollowsByActor = _(Qo);
x.AppBskyGraphList = _(Bs);
x.AppBskyGraphListblock = _(Is);
x.AppBskyGraphListitem = _(Us);
x.AppBskyGraphMuteActor = _(el);
x.AppBskyGraphMuteActorList = _(tl);
x.AppBskyGraphMuteThread = _(rl);
x.AppBskyGraphStarterpack = _(oi);
x.AppBskyGraphUnmuteActor = _(il);
x.AppBskyGraphUnmuteActorList = _(nl);
x.AppBskyGraphUnmuteThread = _(sl);
x.AppBskyLabelerDefs = _(Nt);
x.AppBskyLabelerGetServices = _(al);
x.AppBskyLabelerService = _(Os);
x.AppBskyNotificationGetUnreadCount = _(ol);
x.AppBskyNotificationListNotifications = _(Zi);
x.AppBskyNotificationPutPreferences = _(ll);
x.AppBskyNotificationRegisterPush = _(ul);
x.AppBskyNotificationUpdateSeen = _(cl);
x.AppBskyRichtextFacet = _(bt);
x.AppBskyUnspeccedDefs = _(li);
x.AppBskyUnspeccedGetPopularFeedGenerators = _(dl);
x.AppBskyUnspeccedGetSuggestionsSkeleton = _(fl);
x.AppBskyUnspeccedGetTaggedSuggestions = _(Wi);
x.AppBskyUnspeccedSearchActorsSkeleton = _(Qn);
x.AppBskyUnspeccedSearchPostsSkeleton = _(es);
x.ChatBskyActorDeclaration = _(Ks);
x.ChatBskyActorDefs = _(Ms);
x.ChatBskyActorDeleteAccount = _(pl);
x.ChatBskyActorExportAccountData = _(hl);
x.ChatBskyConvoDefs = _(Oe);
x.ChatBskyConvoDeleteMessageForSelf = _(ml);
x.ChatBskyConvoGetConvo = _(yl);
x.ChatBskyConvoGetConvoForMembers = _(bl);
x.ChatBskyConvoGetLog = _(gl);
x.ChatBskyConvoGetMessages = _(xl);
x.ChatBskyConvoLeaveConvo = _(El);
x.ChatBskyConvoListConvos = _(vl);
x.ChatBskyConvoMuteConvo = _(Rl);
x.ChatBskyConvoSendMessage = _(Al);
x.ChatBskyConvoSendMessageBatch = _(Yi);
x.ChatBskyConvoUnmuteConvo = _(_l);
x.ChatBskyConvoUpdateRead = _(wl);
x.ChatBskyModerationGetActorMetadata = _(Ji);
x.ChatBskyModerationGetMessageContext = _(Tl);
x.ChatBskyModerationUpdateActorAccess = _(Cl);
x.ToolsOzoneCommunicationCreateTemplate = _(Sl);
x.ToolsOzoneCommunicationDefs = _(Ns);
x.ToolsOzoneCommunicationDeleteTemplate = _(Ll);
x.ToolsOzoneCommunicationListTemplates = _(kl);
x.ToolsOzoneCommunicationUpdateTemplate = _(Dl);
x.ToolsOzoneModerationDefs = _(J);
x.ToolsOzoneModerationEmitEvent = _(ts);
x.ToolsOzoneModerationGetEvent = _(Pl);
x.ToolsOzoneModerationGetRecord = _(rs);
x.ToolsOzoneModerationGetRepo = _(is);
x.ToolsOzoneModerationQueryEvents = _(Bl);
x.ToolsOzoneModerationQueryStatuses = _(Il);
x.ToolsOzoneModerationSearchRepos = _(Ul);
x.ToolsOzoneServerGetConfig = _(Sr);
x.ToolsOzoneTeamAddMember = _(ns);
x.ToolsOzoneTeamDefs = _(Dr);
x.ToolsOzoneTeamDeleteMember = _(Qi);
x.ToolsOzoneTeamListMembers = _(Ol);
x.ToolsOzoneTeamUpdateMember = _(ss);
x.COM_ATPROTO_MODERATION = {
  DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
  DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
  DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
  DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
  DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
  DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
  DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
};
x.APP_BSKY_FEED = {
  DefsRequestLess: "app.bsky.feed.defs#requestLess",
  DefsRequestMore: "app.bsky.feed.defs#requestMore",
  DefsClickthroughItem: "app.bsky.feed.defs#clickthroughItem",
  DefsClickthroughAuthor: "app.bsky.feed.defs#clickthroughAuthor",
  DefsClickthroughReposter: "app.bsky.feed.defs#clickthroughReposter",
  DefsClickthroughEmbed: "app.bsky.feed.defs#clickthroughEmbed",
  DefsInteractionSeen: "app.bsky.feed.defs#interactionSeen",
  DefsInteractionLike: "app.bsky.feed.defs#interactionLike",
  DefsInteractionRepost: "app.bsky.feed.defs#interactionRepost",
  DefsInteractionReply: "app.bsky.feed.defs#interactionReply",
  DefsInteractionQuote: "app.bsky.feed.defs#interactionQuote",
  DefsInteractionShare: "app.bsky.feed.defs#interactionShare"
};
x.APP_BSKY_GRAPH = {
  DefsModlist: "app.bsky.graph.defs#modlist",
  DefsCuratelist: "app.bsky.graph.defs#curatelist",
  DefsReferencelist: "app.bsky.graph.defs#referencelist"
};
x.TOOLS_OZONE_MODERATION = {
  DefsReviewOpen: "tools.ozone.moderation.defs#reviewOpen",
  DefsReviewEscalated: "tools.ozone.moderation.defs#reviewEscalated",
  DefsReviewClosed: "tools.ozone.moderation.defs#reviewClosed",
  DefsReviewNone: "tools.ozone.moderation.defs#reviewNone"
};
x.TOOLS_OZONE_TEAM = {
  DefsRoleAdmin: "tools.ozone.team.defs#roleAdmin",
  DefsRoleModerator: "tools.ozone.team.defs#roleModerator",
  DefsRoleTriage: "tools.ozone.team.defs#roleTriage"
};
class dO {
  constructor() {
    Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new dB.Client()
    }), this.xrpc.addLexicons(fB.schemas);
  }
  service(e) {
    return new W0(this, this.xrpc.service(e));
  }
}
x.AtpBaseClient = dO;
class W0 {
  constructor(e, r) {
    Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "com", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "app", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._baseClient = e, this.xrpc = r, this.com = new Y0(this), this.app = new om(this), this.chat = new km(this), this.tools = new Om(this);
  }
  setHeader(e, r) {
    this.xrpc.setHeader(e, r);
  }
}
x.AtpServiceClient = W0;
class Y0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "atproto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.atproto = new J0(e);
  }
}
x.ComNS = Y0;
class J0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "admin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "identity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sync", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.admin = new Q0(e), this.identity = new em(e), this.label = new tm(e), this.moderation = new rm(e), this.repo = new im(e), this.server = new nm(e), this.sync = new sm(e), this.temp = new am(e);
  }
}
x.ComAtprotoNS = J0;
class Q0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.admin.deleteAccount", r?.qp, e, r).catch((i) => {
      throw pB.toKnownErr(i);
    });
  }
  disableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", r?.qp, e, r).catch((i) => {
      throw hB.toKnownErr(i);
    });
  }
  disableInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", r?.qp, e, r).catch((i) => {
      throw mB.toKnownErr(i);
    });
  }
  enableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", r?.qp, e, r).catch((i) => {
      throw yB.toKnownErr(i);
    });
  }
  getAccountInfo(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfo", e, void 0, r).catch((i) => {
      throw bB.toKnownErr(i);
    });
  }
  getAccountInfos(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfos", e, void 0, r).catch((i) => {
      throw gB.toKnownErr(i);
    });
  }
  getInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getInviteCodes", e, void 0, r).catch((i) => {
      throw xB.toKnownErr(i);
    });
  }
  getSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", e, void 0, r).catch((i) => {
      throw EB.toKnownErr(i);
    });
  }
  searchAccounts(e, r) {
    return this._service.xrpc.call("com.atproto.admin.searchAccounts", e, void 0, r).catch((i) => {
      throw vB.toKnownErr(i);
    });
  }
  sendEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.sendEmail", r?.qp, e, r).catch((i) => {
      throw RB.toKnownErr(i);
    });
  }
  updateAccountEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", r?.qp, e, r).catch((i) => {
      throw AB.toKnownErr(i);
    });
  }
  updateAccountHandle(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", r?.qp, e, r).catch((i) => {
      throw _B.toKnownErr(i);
    });
  }
  updateAccountPassword(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountPassword", r?.qp, e, r).catch((i) => {
      throw wB.toKnownErr(i);
    });
  }
  updateSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", r?.qp, e, r).catch((i) => {
      throw TB.toKnownErr(i);
    });
  }
}
x.ComAtprotoAdminNS = Q0;
class em {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getRecommendedDidCredentials(e, r) {
    return this._service.xrpc.call("com.atproto.identity.getRecommendedDidCredentials", e, void 0, r).catch((i) => {
      throw CB.toKnownErr(i);
    });
  }
  requestPlcOperationSignature(e, r) {
    return this._service.xrpc.call("com.atproto.identity.requestPlcOperationSignature", r?.qp, e, r).catch((i) => {
      throw SB.toKnownErr(i);
    });
  }
  resolveHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.resolveHandle", e, void 0, r).catch((i) => {
      throw LB.toKnownErr(i);
    });
  }
  signPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.signPlcOperation", r?.qp, e, r).catch((i) => {
      throw kB.toKnownErr(i);
    });
  }
  submitPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.submitPlcOperation", r?.qp, e, r).catch((i) => {
      throw DB.toKnownErr(i);
    });
  }
  updateHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.updateHandle", r?.qp, e, r).catch((i) => {
      throw PB.toKnownErr(i);
    });
  }
}
x.ComAtprotoIdentityNS = em;
class tm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  queryLabels(e, r) {
    return this._service.xrpc.call("com.atproto.label.queryLabels", e, void 0, r).catch((i) => {
      throw BB.toKnownErr(i);
    });
  }
}
x.ComAtprotoLabelNS = tm;
class rm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createReport(e, r) {
    return this._service.xrpc.call("com.atproto.moderation.createReport", r?.qp, e, r).catch((i) => {
      throw IB.toKnownErr(i);
    });
  }
}
x.ComAtprotoModerationNS = rm;
class im {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  applyWrites(e, r) {
    return this._service.xrpc.call("com.atproto.repo.applyWrites", r?.qp, e, r).catch((i) => {
      throw UB.toKnownErr(i);
    });
  }
  createRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.createRecord", r?.qp, e, r).catch((i) => {
      throw OB.toKnownErr(i);
    });
  }
  deleteRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.deleteRecord", r?.qp, e, r).catch((i) => {
      throw KB.toKnownErr(i);
    });
  }
  describeRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.describeRepo", e, void 0, r).catch((i) => {
      throw MB.toKnownErr(i);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.getRecord", e, void 0, r).catch((i) => {
      throw NB.toKnownErr(i);
    });
  }
  importRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.importRepo", r?.qp, e, r).catch((i) => {
      throw VB.toKnownErr(i);
    });
  }
  listMissingBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listMissingBlobs", e, void 0, r).catch((i) => {
      throw jB.toKnownErr(i);
    });
  }
  listRecords(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listRecords", e, void 0, r).catch((i) => {
      throw FB.toKnownErr(i);
    });
  }
  putRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.putRecord", r?.qp, e, r).catch((i) => {
      throw $B.toKnownErr(i);
    });
  }
  uploadBlob(e, r) {
    return this._service.xrpc.call("com.atproto.repo.uploadBlob", r?.qp, e, r).catch((i) => {
      throw GB.toKnownErr(i);
    });
  }
}
x.ComAtprotoRepoNS = im;
class nm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  activateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.activateAccount", r?.qp, e, r).catch((i) => {
      throw qB.toKnownErr(i);
    });
  }
  checkAccountStatus(e, r) {
    return this._service.xrpc.call("com.atproto.server.checkAccountStatus", e, void 0, r).catch((i) => {
      throw zB.toKnownErr(i);
    });
  }
  confirmEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.confirmEmail", r?.qp, e, r).catch((i) => {
      throw XB.toKnownErr(i);
    });
  }
  createAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAccount", r?.qp, e, r).catch((i) => {
      throw HB.toKnownErr(i);
    });
  }
  createAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAppPassword", r?.qp, e, r).catch((i) => {
      throw ZB.toKnownErr(i);
    });
  }
  createInviteCode(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCode", r?.qp, e, r).catch((i) => {
      throw WB.toKnownErr(i);
    });
  }
  createInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCodes", r?.qp, e, r).catch((i) => {
      throw YB.toKnownErr(i);
    });
  }
  createSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.createSession", r?.qp, e, r).catch((i) => {
      throw JB.toKnownErr(i);
    });
  }
  deactivateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deactivateAccount", r?.qp, e, r).catch((i) => {
      throw QB.toKnownErr(i);
    });
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteAccount", r?.qp, e, r).catch((i) => {
      throw eI.toKnownErr(i);
    });
  }
  deleteSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteSession", r?.qp, e, r).catch((i) => {
      throw tI.toKnownErr(i);
    });
  }
  describeServer(e, r) {
    return this._service.xrpc.call("com.atproto.server.describeServer", e, void 0, r).catch((i) => {
      throw rI.toKnownErr(i);
    });
  }
  getAccountInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", e, void 0, r).catch((i) => {
      throw iI.toKnownErr(i);
    });
  }
  getServiceAuth(e, r) {
    return this._service.xrpc.call("com.atproto.server.getServiceAuth", e, void 0, r).catch((i) => {
      throw nI.toKnownErr(i);
    });
  }
  getSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.getSession", e, void 0, r).catch((i) => {
      throw sI.toKnownErr(i);
    });
  }
  listAppPasswords(e, r) {
    return this._service.xrpc.call("com.atproto.server.listAppPasswords", e, void 0, r).catch((i) => {
      throw aI.toKnownErr(i);
    });
  }
  refreshSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.refreshSession", r?.qp, e, r).catch((i) => {
      throw oI.toKnownErr(i);
    });
  }
  requestAccountDelete(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestAccountDelete", r?.qp, e, r).catch((i) => {
      throw lI.toKnownErr(i);
    });
  }
  requestEmailConfirmation(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", r?.qp, e, r).catch((i) => {
      throw uI.toKnownErr(i);
    });
  }
  requestEmailUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", r?.qp, e, r).catch((i) => {
      throw cI.toKnownErr(i);
    });
  }
  requestPasswordReset(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestPasswordReset", r?.qp, e, r).catch((i) => {
      throw dI.toKnownErr(i);
    });
  }
  reserveSigningKey(e, r) {
    return this._service.xrpc.call("com.atproto.server.reserveSigningKey", r?.qp, e, r).catch((i) => {
      throw fI.toKnownErr(i);
    });
  }
  resetPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.resetPassword", r?.qp, e, r).catch((i) => {
      throw pI.toKnownErr(i);
    });
  }
  revokeAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.revokeAppPassword", r?.qp, e, r).catch((i) => {
      throw hI.toKnownErr(i);
    });
  }
  updateEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.updateEmail", r?.qp, e, r).catch((i) => {
      throw mI.toKnownErr(i);
    });
  }
}
x.ComAtprotoServerNS = nm;
class sm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getBlob(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlob", e, void 0, r).catch((i) => {
      throw yI.toKnownErr(i);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlocks", e, void 0, r).catch((i) => {
      throw bI.toKnownErr(i);
    });
  }
  getCheckout(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getCheckout", e, void 0, r).catch((i) => {
      throw gI.toKnownErr(i);
    });
  }
  getHead(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getHead", e, void 0, r).catch((i) => {
      throw xI.toKnownErr(i);
    });
  }
  getLatestCommit(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getLatestCommit", e, void 0, r).catch((i) => {
      throw EI.toKnownErr(i);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRecord", e, void 0, r).catch((i) => {
      throw vI.toKnownErr(i);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepo", e, void 0, r).catch((i) => {
      throw RI.toKnownErr(i);
    });
  }
  getRepoStatus(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepoStatus", e, void 0, r).catch((i) => {
      throw AI.toKnownErr(i);
    });
  }
  listBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listBlobs", e, void 0, r).catch((i) => {
      throw _I.toKnownErr(i);
    });
  }
  listRepos(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listRepos", e, void 0, r).catch((i) => {
      throw wI.toKnownErr(i);
    });
  }
  notifyOfUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", r?.qp, e, r).catch((i) => {
      throw TI.toKnownErr(i);
    });
  }
  requestCrawl(e, r) {
    return this._service.xrpc.call("com.atproto.sync.requestCrawl", r?.qp, e, r).catch((i) => {
      throw CI.toKnownErr(i);
    });
  }
}
x.ComAtprotoSyncNS = sm;
class am {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  checkSignupQueue(e, r) {
    return this._service.xrpc.call("com.atproto.temp.checkSignupQueue", e, void 0, r).catch((i) => {
      throw SI.toKnownErr(i);
    });
  }
  fetchLabels(e, r) {
    return this._service.xrpc.call("com.atproto.temp.fetchLabels", e, void 0, r).catch((i) => {
      throw LI.toKnownErr(i);
    });
  }
  requestPhoneVerification(e, r) {
    return this._service.xrpc.call("com.atproto.temp.requestPhoneVerification", r?.qp, e, r).catch((i) => {
      throw kI.toKnownErr(i);
    });
  }
}
x.ComAtprotoTempNS = am;
class om {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new lm(e);
  }
}
x.AppNS = om;
class lm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "feed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "graph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labeler", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "notification", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "richtext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "unspecced", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new um(e), this.embed = new dm(e), this.feed = new fm(e), this.graph = new gm(e), this.labeler = new wm(e), this.notification = new Cm(e), this.richtext = new Sm(e), this.unspecced = new Lm(e);
  }
}
x.AppBskyNS = lm;
class um {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "profile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.profile = new cm(e);
  }
  getPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getPreferences", e, void 0, r).catch((i) => {
      throw DI.toKnownErr(i);
    });
  }
  getProfile(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfile", e, void 0, r).catch((i) => {
      throw PI.toKnownErr(i);
    });
  }
  getProfiles(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfiles", e, void 0, r).catch((i) => {
      throw BI.toKnownErr(i);
    });
  }
  getSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getSuggestions", e, void 0, r).catch((i) => {
      throw II.toKnownErr(i);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.putPreferences", r?.qp, e, r).catch((i) => {
      throw UI.toKnownErr(i);
    });
  }
  searchActors(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActors", e, void 0, r).catch((i) => {
      throw OI.toKnownErr(i);
    });
  }
  searchActorsTypeahead(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", e, void 0, r).catch((i) => {
      throw KI.toKnownErr(i);
    });
  }
}
x.AppBskyActorNS = um;
class cm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.actor.profile", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.actor.profile", rkey: "self", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.actor.profile", ...e }, { headers: r });
  }
}
x.ProfileRecord = cm;
class dm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
x.AppBskyEmbedNS = dm;
class fm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "like", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "post", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "threadgate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.generator = new pm(e), this.like = new hm(e), this.post = new mm(e), this.repost = new ym(e), this.threadgate = new bm(e);
  }
  describeFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", e, void 0, r).catch((i) => {
      throw MI.toKnownErr(i);
    });
  }
  getActorFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorFeeds", e, void 0, r).catch((i) => {
      throw NI.toKnownErr(i);
    });
  }
  getActorLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorLikes", e, void 0, r).catch((i) => {
      throw VI.toKnownErr(i);
    });
  }
  getAuthorFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", e, void 0, r).catch((i) => {
      throw jI.toKnownErr(i);
    });
  }
  getFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeed", e, void 0, r).catch((i) => {
      throw FI.toKnownErr(i);
    });
  }
  getFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", e, void 0, r).catch((i) => {
      throw $I.toKnownErr(i);
    });
  }
  getFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", e, void 0, r).catch((i) => {
      throw GI.toKnownErr(i);
    });
  }
  getFeedSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", e, void 0, r).catch((i) => {
      throw qI.toKnownErr(i);
    });
  }
  getLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getLikes", e, void 0, r).catch((i) => {
      throw zI.toKnownErr(i);
    });
  }
  getListFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getListFeed", e, void 0, r).catch((i) => {
      throw XI.toKnownErr(i);
    });
  }
  getPostThread(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPostThread", e, void 0, r).catch((i) => {
      throw HI.toKnownErr(i);
    });
  }
  getPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPosts", e, void 0, r).catch((i) => {
      throw ZI.toKnownErr(i);
    });
  }
  getRepostedBy(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getRepostedBy", e, void 0, r).catch((i) => {
      throw WI.toKnownErr(i);
    });
  }
  getSuggestedFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", e, void 0, r).catch((i) => {
      throw YI.toKnownErr(i);
    });
  }
  getTimeline(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getTimeline", e, void 0, r).catch((i) => {
      throw JI.toKnownErr(i);
    });
  }
  searchPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.searchPosts", e, void 0, r).catch((i) => {
      throw QI.toKnownErr(i);
    });
  }
  sendInteractions(e, r) {
    return this._service.xrpc.call("app.bsky.feed.sendInteractions", r?.qp, e, r).catch((i) => {
      throw eU.toKnownErr(i);
    });
  }
}
x.AppBskyFeedNS = fm;
class pm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.generator", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.generator", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.generator", ...e }, { headers: r });
  }
}
x.GeneratorRecord = pm;
class hm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.like", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.like", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.like", ...e }, { headers: r });
  }
}
x.LikeRecord = hm;
class mm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.post", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.post", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.post", ...e }, { headers: r });
  }
}
x.PostRecord = mm;
class ym {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.repost", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.repost", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.repost", ...e }, { headers: r });
  }
}
x.RepostRecord = ym;
class bm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.threadgate", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e }, { headers: r });
  }
}
x.ThreadgateRecord = bm;
class gm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "block", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "follow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "list", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listblock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listitem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "starterpack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.block = new xm(e), this.follow = new Em(e), this.list = new vm(e), this.listblock = new Rm(e), this.listitem = new Am(e), this.starterpack = new _m(e);
  }
  getActorStarterPacks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getActorStarterPacks", e, void 0, r).catch((i) => {
      throw tU.toKnownErr(i);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getBlocks", e, void 0, r).catch((i) => {
      throw rU.toKnownErr(i);
    });
  }
  getFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollowers", e, void 0, r).catch((i) => {
      throw iU.toKnownErr(i);
    });
  }
  getFollows(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollows", e, void 0, r).catch((i) => {
      throw nU.toKnownErr(i);
    });
  }
  getKnownFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getKnownFollowers", e, void 0, r).catch((i) => {
      throw sU.toKnownErr(i);
    });
  }
  getList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getList", e, void 0, r).catch((i) => {
      throw aU.toKnownErr(i);
    });
  }
  getListBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListBlocks", e, void 0, r).catch((i) => {
      throw oU.toKnownErr(i);
    });
  }
  getListMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListMutes", e, void 0, r).catch((i) => {
      throw lU.toKnownErr(i);
    });
  }
  getLists(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getLists", e, void 0, r).catch((i) => {
      throw uU.toKnownErr(i);
    });
  }
  getMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getMutes", e, void 0, r).catch((i) => {
      throw cU.toKnownErr(i);
    });
  }
  getRelationships(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getRelationships", e, void 0, r).catch((i) => {
      throw dU.toKnownErr(i);
    });
  }
  getStarterPack(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getStarterPack", e, void 0, r).catch((i) => {
      throw fU.toKnownErr(i);
    });
  }
  getStarterPacks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getStarterPacks", e, void 0, r).catch((i) => {
      throw pU.toKnownErr(i);
    });
  }
  getSuggestedFollowsByActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", e, void 0, r).catch((i) => {
      throw hU.toKnownErr(i);
    });
  }
  muteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActor", r?.qp, e, r).catch((i) => {
      throw mU.toKnownErr(i);
    });
  }
  muteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActorList", r?.qp, e, r).catch((i) => {
      throw yU.toKnownErr(i);
    });
  }
  muteThread(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteThread", r?.qp, e, r).catch((i) => {
      throw bU.toKnownErr(i);
    });
  }
  unmuteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActor", r?.qp, e, r).catch((i) => {
      throw gU.toKnownErr(i);
    });
  }
  unmuteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActorList", r?.qp, e, r).catch((i) => {
      throw xU.toKnownErr(i);
    });
  }
  unmuteThread(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteThread", r?.qp, e, r).catch((i) => {
      throw EU.toKnownErr(i);
    });
  }
}
x.AppBskyGraphNS = gm;
class xm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.block", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.block", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.block", ...e }, { headers: r });
  }
}
x.BlockRecord = xm;
class Em {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.follow", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.follow", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.follow", ...e }, { headers: r });
  }
}
x.FollowRecord = Em;
class vm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.list", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.list", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.list", ...e }, { headers: r });
  }
}
x.ListRecord = vm;
class Rm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.listblock", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listblock", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listblock", ...e }, { headers: r });
  }
}
x.ListblockRecord = Rm;
class Am {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.listitem", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listitem", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listitem", ...e }, { headers: r });
  }
}
x.ListitemRecord = Am;
class _m {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.starterpack",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.starterpack",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.starterpack", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.starterpack", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.starterpack", ...e }, { headers: r });
  }
}
x.StarterpackRecord = _m;
class wm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.service = new Tm(e);
  }
  getServices(e, r) {
    return this._service.xrpc.call("app.bsky.labeler.getServices", e, void 0, r).catch((i) => {
      throw vU.toKnownErr(i);
    });
  }
}
x.AppBskyLabelerNS = wm;
class Tm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.labeler.service", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "app.bsky.labeler.service",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.labeler.service", ...e }, { headers: r });
  }
}
x.ServiceRecord = Tm;
class Cm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getUnreadCount(e, r) {
    return this._service.xrpc.call("app.bsky.notification.getUnreadCount", e, void 0, r).catch((i) => {
      throw RU.toKnownErr(i);
    });
  }
  listNotifications(e, r) {
    return this._service.xrpc.call("app.bsky.notification.listNotifications", e, void 0, r).catch((i) => {
      throw AU.toKnownErr(i);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.notification.putPreferences", r?.qp, e, r).catch((i) => {
      throw _U.toKnownErr(i);
    });
  }
  registerPush(e, r) {
    return this._service.xrpc.call("app.bsky.notification.registerPush", r?.qp, e, r).catch((i) => {
      throw wU.toKnownErr(i);
    });
  }
  updateSeen(e, r) {
    return this._service.xrpc.call("app.bsky.notification.updateSeen", r?.qp, e, r).catch((i) => {
      throw TU.toKnownErr(i);
    });
  }
}
x.AppBskyNotificationNS = Cm;
class Sm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
x.AppBskyRichtextNS = Sm;
class Lm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getPopularFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", e, void 0, r).catch((i) => {
      throw CU.toKnownErr(i);
    });
  }
  getSuggestionsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getSuggestionsSkeleton", e, void 0, r).catch((i) => {
      throw SU.toKnownErr(i);
    });
  }
  getTaggedSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getTaggedSuggestions", e, void 0, r).catch((i) => {
      throw LU.toKnownErr(i);
    });
  }
  searchActorsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", e, void 0, r).catch((i) => {
      throw kU.toKnownErr(i);
    });
  }
  searchPostsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", e, void 0, r).catch((i) => {
      throw DU.toKnownErr(i);
    });
  }
}
x.AppBskyUnspeccedNS = Lm;
class km {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new Dm(e);
  }
}
x.ChatNS = km;
class Dm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "convo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new Pm(e), this.convo = new Im(e), this.moderation = new Um(e);
  }
}
x.ChatBskyNS = Dm;
class Pm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "declaration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.declaration = new Bm(e);
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("chat.bsky.actor.deleteAccount", r?.qp, e, r).catch((i) => {
      throw PU.toKnownErr(i);
    });
  }
  exportAccountData(e, r) {
    return this._service.xrpc.call("chat.bsky.actor.exportAccountData", e, void 0, r).catch((i) => {
      throw BU.toKnownErr(i);
    });
  }
}
x.ChatBskyActorNS = Pm;
class Bm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "chat.bsky.actor.declaration",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "chat.bsky.actor.declaration",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "chat.bsky.actor.declaration", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "chat.bsky.actor.declaration",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "chat.bsky.actor.declaration", ...e }, { headers: r });
  }
}
x.DeclarationRecord = Bm;
class Im {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteMessageForSelf(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.deleteMessageForSelf", r?.qp, e, r).catch((i) => {
      throw IU.toKnownErr(i);
    });
  }
  getConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getConvo", e, void 0, r).catch((i) => {
      throw UU.toKnownErr(i);
    });
  }
  getConvoForMembers(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getConvoForMembers", e, void 0, r).catch((i) => {
      throw OU.toKnownErr(i);
    });
  }
  getLog(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getLog", e, void 0, r).catch((i) => {
      throw KU.toKnownErr(i);
    });
  }
  getMessages(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getMessages", e, void 0, r).catch((i) => {
      throw MU.toKnownErr(i);
    });
  }
  leaveConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.leaveConvo", r?.qp, e, r).catch((i) => {
      throw NU.toKnownErr(i);
    });
  }
  listConvos(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.listConvos", e, void 0, r).catch((i) => {
      throw VU.toKnownErr(i);
    });
  }
  muteConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.muteConvo", r?.qp, e, r).catch((i) => {
      throw jU.toKnownErr(i);
    });
  }
  sendMessage(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.sendMessage", r?.qp, e, r).catch((i) => {
      throw FU.toKnownErr(i);
    });
  }
  sendMessageBatch(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.sendMessageBatch", r?.qp, e, r).catch((i) => {
      throw $U.toKnownErr(i);
    });
  }
  unmuteConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.unmuteConvo", r?.qp, e, r).catch((i) => {
      throw GU.toKnownErr(i);
    });
  }
  updateRead(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.updateRead", r?.qp, e, r).catch((i) => {
      throw qU.toKnownErr(i);
    });
  }
}
x.ChatBskyConvoNS = Im;
class Um {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getActorMetadata(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.getActorMetadata", e, void 0, r).catch((i) => {
      throw zU.toKnownErr(i);
    });
  }
  getMessageContext(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.getMessageContext", e, void 0, r).catch((i) => {
      throw XU.toKnownErr(i);
    });
  }
  updateActorAccess(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.updateActorAccess", r?.qp, e, r).catch((i) => {
      throw HU.toKnownErr(i);
    });
  }
}
x.ChatBskyModerationNS = Um;
class Om {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ozone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.ozone = new Km(e);
  }
}
x.ToolsNS = Om;
class Km {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "communication", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "team", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.communication = new Mm(e), this.moderation = new Nm(e), this.server = new Vm(e), this.team = new jm(e);
  }
}
x.ToolsOzoneNS = Km;
class Mm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.createTemplate", r?.qp, e, r).catch((i) => {
      throw ZU.toKnownErr(i);
    });
  }
  deleteTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.deleteTemplate", r?.qp, e, r).catch((i) => {
      throw WU.toKnownErr(i);
    });
  }
  listTemplates(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.listTemplates", e, void 0, r).catch((i) => {
      throw YU.toKnownErr(i);
    });
  }
  updateTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.updateTemplate", r?.qp, e, r).catch((i) => {
      throw JU.toKnownErr(i);
    });
  }
}
x.ToolsOzoneCommunicationNS = Mm;
class Nm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  emitEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.emitEvent", r?.qp, e, r).catch((i) => {
      throw QU.toKnownErr(i);
    });
  }
  getEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getEvent", e, void 0, r).catch((i) => {
      throw eO.toKnownErr(i);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRecord", e, void 0, r).catch((i) => {
      throw tO.toKnownErr(i);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRepo", e, void 0, r).catch((i) => {
      throw rO.toKnownErr(i);
    });
  }
  queryEvents(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryEvents", e, void 0, r).catch((i) => {
      throw iO.toKnownErr(i);
    });
  }
  queryStatuses(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryStatuses", e, void 0, r).catch((i) => {
      throw nO.toKnownErr(i);
    });
  }
  searchRepos(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.searchRepos", e, void 0, r).catch((i) => {
      throw sO.toKnownErr(i);
    });
  }
}
x.ToolsOzoneModerationNS = Nm;
class Vm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getConfig(e, r) {
    return this._service.xrpc.call("tools.ozone.server.getConfig", e, void 0, r).catch((i) => {
      throw aO.toKnownErr(i);
    });
  }
}
x.ToolsOzoneServerNS = Vm;
class jm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  addMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.addMember", r?.qp, e, r).catch((i) => {
      throw oO.toKnownErr(i);
    });
  }
  deleteMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.deleteMember", r?.qp, e, r).catch((i) => {
      throw lO.toKnownErr(i);
    });
  }
  listMembers(e, r) {
    return this._service.xrpc.call("tools.ozone.team.listMembers", e, void 0, r).catch((i) => {
      throw uO.toKnownErr(i);
    });
  }
  updateMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.updateMember", r?.qp, e, r).catch((i) => {
      throw cO.toKnownErr(i);
    });
  }
}
x.ToolsOzoneTeamNS = jm;
var Vs = {};
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.AtpAgent = void 0;
const fO = q, au = q, pf = vi, pO = x, hO = ka, mO = "com.atproto.server.refreshSession";
class vr {
  get com() {
    return this.api.com;
  }
  /**
   * Configures the API globally.
   */
  static configure(e) {
    e.fetch && (vr.fetch = e.fetch), e.appLabelers && (vr.appLabelers = e.appLabelers);
  }
  constructor(e) {
    Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "api", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "session", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labelersHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "proxyHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pdsUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_persistSession", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_refreshSessionPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uploadBlob", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, i) => this.api.com.atproto.repo.uploadBlob(r, i)
    }), Object.defineProperty(this, "resolveHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, i) => this.api.com.atproto.identity.resolveHandle(r, i)
    }), Object.defineProperty(this, "updateHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, i) => this.api.com.atproto.identity.updateHandle(r, i)
    }), Object.defineProperty(this, "createModerationReport", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, i) => this.api.com.atproto.moderation.createReport(r, i)
    }), this.service = e.service instanceof URL ? e.service : new URL(e.service), this._persistSession = e.persistSession, this._baseClient = new pO.AtpBaseClient(), this._baseClient.xrpc.fetch = this._fetch.bind(this), this.api = this._baseClient.service(e.service);
  }
  clone() {
    const e = new vr({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  copyInto(e) {
    e.session = this.session, e.labelersHeader = this.labelersHeader, e.proxyHeader = this.proxyHeader, e.pdsUrl = this.pdsUrl, e.api.xrpc.uri = this.pdsUrl || this.service;
  }
  withProxy(e, r) {
    const i = this.clone();
    return i.configureProxyHeader(e, r), i;
  }
  /**
   * Is there any active session?
   */
  get hasSession() {
    return !!this.session;
  }
  /**
   * Sets the "Persist Session" method which can be used to store access tokens
   * as they change.
   */
  setPersistSessionHandler(e) {
    this._persistSession = e;
  }
  /**
   * Configures the moderation services to be applied on requests.
   * NOTE: this is called automatically by getPreferences() and the relevant moderation config
   * methods in BskyAgent instances.
   */
  configureLabelersHeader(e) {
    this.labelersHeader = e;
  }
  /**
   * Configures the atproto-proxy header to be applied on requests
   */
  configureProxyHeader(e, r) {
    r.startsWith("did:") && (this.proxyHeader = `${r}#${e}`);
  }
  /**
   * Create a new account and hydrate its session in this agent.
   */
  async createAccount(e) {
    try {
      const r = await this.api.com.atproto.server.createAccount(e);
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: e.email,
        emailConfirmed: !1,
        emailAuthFactor: !1,
        active: !0
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Start a new session with this agent.
   */
  async login(e) {
    try {
      const r = await this.api.com.atproto.server.createSession({
        identifier: e.identifier,
        password: e.password,
        authFactorToken: e.authFactorToken
      });
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: r.data.email,
        emailConfirmed: r.data.emailConfirmed,
        emailAuthFactor: r.data.emailAuthFactor,
        active: r.data.active ?? !0,
        status: r.data.status
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Resume a pre-existing session with this agent.
   */
  async resumeSession(e) {
    try {
      this.session = e;
      const r = await this.api.com.atproto.server.getSession();
      if (r.data.did !== this.session.did)
        throw new au.XRPCError(au.ResponseType.InvalidRequest, "Invalid session", "InvalidDID");
      return this.session.email = r.data.email, this.session.handle = r.data.handle, this.session.emailConfirmed = r.data.emailConfirmed, this.session.emailAuthFactor = r.data.emailAuthFactor, this.session.active = r.data.active ?? !0, this.session.status = r.data.status, this._updateApiEndpoint(r.data.didDoc), this._persistSession?.("update", this.session), r;
    } catch (r) {
      throw this.session = void 0, r instanceof au.XRPCError ? [1, 408, 425, 429, 500, 502, 503, 504, 522, 524].includes(r.status) ? this._persistSession?.("network-error", void 0) : this._persistSession?.("expired", void 0) : this._persistSession?.("network-error", void 0), r;
    }
  }
  /**
   * Internal helper to add authorization headers to requests.
   */
  _addHeaders(e) {
    !e.authorization && this.session?.accessJwt && (e = {
      ...e,
      authorization: `Bearer ${this.session.accessJwt}`
    }), this.proxyHeader && (e = {
      ...e,
      "atproto-proxy": this.proxyHeader
    });
    const r = "atproto-accept-labelers", i = vr.appLabelers.map((a) => `${a};redact`).concat(this.labelersHeader.filter((a) => a.startsWith("did:")));
    return e[r] && i.push(
      ...e[r].split(",").map((a) => a.trim())
    ), e = {
      ...e,
      [r]: i.join(", ")
    }, e;
  }
  /**
   * Internal fetch handler which adds access-token management
   */
  async _fetch(e, r, i, a) {
    if (!vr.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    await this._refreshSessionPromise;
    let c = await vr.fetch(e, r, this._addHeaders(i), a);
    return hf(c, ["ExpiredToken"]) && this.session?.refreshJwt && (await this.refreshSession(), c = await vr.fetch(e, r, this._addHeaders(i), a)), c;
  }
  /**
   * Internal helper to refresh sessions
   * - Wraps the actual implementation in a promise-guard to ensure only
   *   one refresh is attempted at a time.
   */
  async refreshSession() {
    if (this._refreshSessionPromise)
      return this._refreshSessionPromise;
    this._refreshSessionPromise = this._refreshSessionInner();
    try {
      await this._refreshSessionPromise;
    } finally {
      this._refreshSessionPromise = void 0;
    }
  }
  /**
   * Internal helper to refresh sessions (actual behavior)
   */
  async _refreshSessionInner() {
    if (!vr.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    if (!this.session?.refreshJwt)
      return;
    const e = new URL((this.pdsUrl || this.service).origin);
    e.pathname = `/xrpc/${mO}`;
    const r = await vr.fetch(e.toString(), "POST", {
      authorization: `Bearer ${this.session.refreshJwt}`
    }, void 0);
    hf(r, ["ExpiredToken", "InvalidToken"]) ? (this.session = void 0, this._persistSession?.("expired", void 0)) : bO(this._baseClient, r.body) && (this.session = {
      ...this.session || {},
      accessJwt: r.body.accessJwt,
      refreshJwt: r.body.refreshJwt,
      handle: r.body.handle,
      did: r.body.did
    }, this._updateApiEndpoint(r.body.didDoc), this._persistSession?.("update", this.session));
  }
  /**
   * Helper to update the pds endpoint dynamically.
   *
   * The session methods (create, resume, refresh) may respond with the user's
   * did document which contains the user's canonical PDS endpoint. That endpoint
   * may differ from the endpoint used to contact the server. We capture that
   * PDS endpoint and update the client to use that given endpoint for future
   * requests. (This helps ensure smooth migrations between PDSes, especially
   * when the PDSes are operated by a single org.)
   */
  _updateApiEndpoint(e) {
    if ((0, pf.isValidDidDoc)(e)) {
      const r = (0, pf.getPdsEndpoint)(e);
      this.pdsUrl = r ? new URL(r) : void 0;
    }
    this.api.xrpc.uri = this.pdsUrl || this.service;
  }
}
Vs.AtpAgent = vr;
Object.defineProperty(vr, "fetch", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: au.defaultFetchHandler
});
Object.defineProperty(vr, "appLabelers", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: [hO.BSKY_LABELER_DID]
});
function yO(t) {
  return fO.errorResponseBody.safeParse(t).success;
}
function hf(t, e) {
  return t.status !== 400 || !yO(t.body) ? !1 : typeof t.body.error == "string" && e.includes(t.body.error);
}
function bO(t, e) {
  try {
    return t.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", e), !0;
  } catch {
    return !1;
  }
}
var js = {}, Xs = {};
Object.defineProperty(Xs, "__esModule", { value: !0 });
Xs.UnicodeString = void 0;
const gO = vi, mf = new TextEncoder(), xO = new TextDecoder();
class EO {
  constructor(e) {
    Object.defineProperty(this, "utf16", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "utf8", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_graphemeLen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.utf16 = e, this.utf8 = mf.encode(e);
  }
  get length() {
    return this.utf8.byteLength;
  }
  get graphemeLength() {
    return this._graphemeLen || (this._graphemeLen = (0, gO.graphemeLen)(this.utf16)), this._graphemeLen;
  }
  slice(e, r) {
    return xO.decode(this.utf8.slice(e, r));
  }
  utf16IndexToUtf8Index(e) {
    return mf.encode(this.utf16.slice(0, e)).byteLength;
  }
  toString() {
    return this.utf16;
  }
}
Xs.UnicodeString = EO;
var jl = {};
Object.defineProperty(jl, "__esModule", { value: !0 });
jl.sanitizeRichText = void 0;
const vO = Xs, RO = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/, AO = `

`;
function _O(t, e) {
  return e.cleanNewlines && (t = wO(t, RO, AO)), t;
}
jl.sanitizeRichText = _O;
function wO(t, e, r) {
  t = t.clone();
  let i = t.unicodeText.utf16.match(e);
  for (; i && typeof i.index < "u"; ) {
    const a = t.unicodeText, c = t.unicodeText.utf16IndexToUtf8Index(i.index), h = c + new vO.UnicodeString(i[0]).length;
    if (t.delete(c, h), t.unicodeText.utf16 === a.utf16)
      break;
    t.insert(c, r), i = t.unicodeText.utf16.match(e);
  }
  return t;
}
var $u = {};
const TO = [
  "aaa",
  "aarp",
  "abb",
  "abbott",
  "abbvie",
  "abc",
  "able",
  "abogado",
  "abudhabi",
  "ac",
  "academy",
  "accenture",
  "accountant",
  "accountants",
  "aco",
  "actor",
  "ad",
  "ads",
  "adult",
  "ae",
  "aeg",
  "aero",
  "aetna",
  "af",
  "afl",
  "africa",
  "ag",
  "agakhan",
  "agency",
  "ai",
  "aig",
  "airbus",
  "airforce",
  "airtel",
  "akdn",
  "al",
  "alibaba",
  "alipay",
  "allfinanz",
  "allstate",
  "ally",
  "alsace",
  "alstom",
  "am",
  "amazon",
  "americanexpress",
  "americanfamily",
  "amex",
  "amfam",
  "amica",
  "amsterdam",
  "analytics",
  "android",
  "anquan",
  "anz",
  "ao",
  "aol",
  "apartments",
  "app",
  "apple",
  "aq",
  "aquarelle",
  "ar",
  "arab",
  "aramco",
  "archi",
  "army",
  "arpa",
  "art",
  "arte",
  "as",
  "asda",
  "asia",
  "associates",
  "at",
  "athleta",
  "attorney",
  "au",
  "auction",
  "audi",
  "audible",
  "audio",
  "auspost",
  "author",
  "auto",
  "autos",
  "aw",
  "aws",
  "ax",
  "axa",
  "az",
  "azure",
  "ba",
  "baby",
  "baidu",
  "banamex",
  "band",
  "bank",
  "bar",
  "barcelona",
  "barclaycard",
  "barclays",
  "barefoot",
  "bargains",
  "baseball",
  "basketball",
  "bauhaus",
  "bayern",
  "bb",
  "bbc",
  "bbt",
  "bbva",
  "bcg",
  "bcn",
  "bd",
  "be",
  "beats",
  "beauty",
  "beer",
  "bentley",
  "berlin",
  "best",
  "bestbuy",
  "bet",
  "bf",
  "bg",
  "bh",
  "bharti",
  "bi",
  "bible",
  "bid",
  "bike",
  "bing",
  "bingo",
  "bio",
  "biz",
  "bj",
  "black",
  "blackfriday",
  "blockbuster",
  "blog",
  "bloomberg",
  "blue",
  "bm",
  "bms",
  "bmw",
  "bn",
  "bnpparibas",
  "bo",
  "boats",
  "boehringer",
  "bofa",
  "bom",
  "bond",
  "boo",
  "book",
  "booking",
  "bosch",
  "bostik",
  "boston",
  "bot",
  "boutique",
  "box",
  "br",
  "bradesco",
  "bridgestone",
  "broadway",
  "broker",
  "brother",
  "brussels",
  "bs",
  "bt",
  "build",
  "builders",
  "business",
  "buy",
  "buzz",
  "bv",
  "bw",
  "by",
  "bz",
  "bzh",
  "ca",
  "cab",
  "cafe",
  "cal",
  "call",
  "calvinklein",
  "cam",
  "camera",
  "camp",
  "canon",
  "capetown",
  "capital",
  "capitalone",
  "car",
  "caravan",
  "cards",
  "care",
  "career",
  "careers",
  "cars",
  "casa",
  "case",
  "cash",
  "casino",
  "cat",
  "catering",
  "catholic",
  "cba",
  "cbn",
  "cbre",
  "cc",
  "cd",
  "center",
  "ceo",
  "cern",
  "cf",
  "cfa",
  "cfd",
  "cg",
  "ch",
  "chanel",
  "channel",
  "charity",
  "chase",
  "chat",
  "cheap",
  "chintai",
  "christmas",
  "chrome",
  "church",
  "ci",
  "cipriani",
  "circle",
  "cisco",
  "citadel",
  "citi",
  "citic",
  "city",
  "ck",
  "cl",
  "claims",
  "cleaning",
  "click",
  "clinic",
  "clinique",
  "clothing",
  "cloud",
  "club",
  "clubmed",
  "cm",
  "cn",
  "co",
  "coach",
  "codes",
  "coffee",
  "college",
  "cologne",
  "com",
  "commbank",
  "community",
  "company",
  "compare",
  "computer",
  "comsec",
  "condos",
  "construction",
  "consulting",
  "contact",
  "contractors",
  "cooking",
  "cool",
  "coop",
  "corsica",
  "country",
  "coupon",
  "coupons",
  "courses",
  "cpa",
  "cr",
  "credit",
  "creditcard",
  "creditunion",
  "cricket",
  "crown",
  "crs",
  "cruise",
  "cruises",
  "cu",
  "cuisinella",
  "cv",
  "cw",
  "cx",
  "cy",
  "cymru",
  "cyou",
  "cz",
  "dad",
  "dance",
  "data",
  "date",
  "dating",
  "datsun",
  "day",
  "dclk",
  "dds",
  "de",
  "deal",
  "dealer",
  "deals",
  "degree",
  "delivery",
  "dell",
  "deloitte",
  "delta",
  "democrat",
  "dental",
  "dentist",
  "desi",
  "design",
  "dev",
  "dhl",
  "diamonds",
  "diet",
  "digital",
  "direct",
  "directory",
  "discount",
  "discover",
  "dish",
  "diy",
  "dj",
  "dk",
  "dm",
  "dnp",
  "do",
  "docs",
  "doctor",
  "dog",
  "domains",
  "dot",
  "download",
  "drive",
  "dtv",
  "dubai",
  "dunlop",
  "dupont",
  "durban",
  "dvag",
  "dvr",
  "dz",
  "earth",
  "eat",
  "ec",
  "eco",
  "edeka",
  "edu",
  "education",
  "ee",
  "eg",
  "email",
  "emerck",
  "energy",
  "engineer",
  "engineering",
  "enterprises",
  "epson",
  "equipment",
  "er",
  "ericsson",
  "erni",
  "es",
  "esq",
  "estate",
  "et",
  "eu",
  "eurovision",
  "eus",
  "events",
  "exchange",
  "expert",
  "exposed",
  "express",
  "extraspace",
  "fage",
  "fail",
  "fairwinds",
  "faith",
  "family",
  "fan",
  "fans",
  "farm",
  "farmers",
  "fashion",
  "fast",
  "fedex",
  "feedback",
  "ferrari",
  "ferrero",
  "fi",
  "fidelity",
  "fido",
  "film",
  "final",
  "finance",
  "financial",
  "fire",
  "firestone",
  "firmdale",
  "fish",
  "fishing",
  "fit",
  "fitness",
  "fj",
  "fk",
  "flickr",
  "flights",
  "flir",
  "florist",
  "flowers",
  "fly",
  "fm",
  "fo",
  "foo",
  "food",
  "football",
  "ford",
  "forex",
  "forsale",
  "forum",
  "foundation",
  "fox",
  "fr",
  "free",
  "fresenius",
  "frl",
  "frogans",
  "frontier",
  "ftr",
  "fujitsu",
  "fun",
  "fund",
  "furniture",
  "futbol",
  "fyi",
  "ga",
  "gal",
  "gallery",
  "gallo",
  "gallup",
  "game",
  "games",
  "gap",
  "garden",
  "gay",
  "gb",
  "gbiz",
  "gd",
  "gdn",
  "ge",
  "gea",
  "gent",
  "genting",
  "george",
  "gf",
  "gg",
  "ggee",
  "gh",
  "gi",
  "gift",
  "gifts",
  "gives",
  "giving",
  "gl",
  "glass",
  "gle",
  "global",
  "globo",
  "gm",
  "gmail",
  "gmbh",
  "gmo",
  "gmx",
  "gn",
  "godaddy",
  "gold",
  "goldpoint",
  "golf",
  "goo",
  "goodyear",
  "goog",
  "google",
  "gop",
  "got",
  "gov",
  "gp",
  "gq",
  "gr",
  "grainger",
  "graphics",
  "gratis",
  "green",
  "gripe",
  "grocery",
  "group",
  "gs",
  "gt",
  "gu",
  "gucci",
  "guge",
  "guide",
  "guitars",
  "guru",
  "gw",
  "gy",
  "hair",
  "hamburg",
  "hangout",
  "haus",
  "hbo",
  "hdfc",
  "hdfcbank",
  "health",
  "healthcare",
  "help",
  "helsinki",
  "here",
  "hermes",
  "hiphop",
  "hisamitsu",
  "hitachi",
  "hiv",
  "hk",
  "hkt",
  "hm",
  "hn",
  "hockey",
  "holdings",
  "holiday",
  "homedepot",
  "homegoods",
  "homes",
  "homesense",
  "honda",
  "horse",
  "hospital",
  "host",
  "hosting",
  "hot",
  "hotels",
  "hotmail",
  "house",
  "how",
  "hr",
  "hsbc",
  "ht",
  "hu",
  "hughes",
  "hyatt",
  "hyundai",
  "ibm",
  "icbc",
  "ice",
  "icu",
  "id",
  "ie",
  "ieee",
  "ifm",
  "ikano",
  "il",
  "im",
  "imamat",
  "imdb",
  "immo",
  "immobilien",
  "in",
  "inc",
  "industries",
  "infiniti",
  "info",
  "ing",
  "ink",
  "institute",
  "insurance",
  "insure",
  "int",
  "international",
  "intuit",
  "investments",
  "io",
  "ipiranga",
  "iq",
  "ir",
  "irish",
  "is",
  "ismaili",
  "ist",
  "istanbul",
  "it",
  "itau",
  "itv",
  "jaguar",
  "java",
  "jcb",
  "je",
  "jeep",
  "jetzt",
  "jewelry",
  "jio",
  "jll",
  "jm",
  "jmp",
  "jnj",
  "jo",
  "jobs",
  "joburg",
  "jot",
  "joy",
  "jp",
  "jpmorgan",
  "jprs",
  "juegos",
  "juniper",
  "kaufen",
  "kddi",
  "ke",
  "kerryhotels",
  "kerrylogistics",
  "kerryproperties",
  "kfh",
  "kg",
  "kh",
  "ki",
  "kia",
  "kids",
  "kim",
  "kindle",
  "kitchen",
  "kiwi",
  "km",
  "kn",
  "koeln",
  "komatsu",
  "kosher",
  "kp",
  "kpmg",
  "kpn",
  "kr",
  "krd",
  "kred",
  "kuokgroup",
  "kw",
  "ky",
  "kyoto",
  "kz",
  "la",
  "lacaixa",
  "lamborghini",
  "lamer",
  "lancaster",
  "land",
  "landrover",
  "lanxess",
  "lasalle",
  "lat",
  "latino",
  "latrobe",
  "law",
  "lawyer",
  "lb",
  "lc",
  "lds",
  "lease",
  "leclerc",
  "lefrak",
  "legal",
  "lego",
  "lexus",
  "lgbt",
  "li",
  "lidl",
  "life",
  "lifeinsurance",
  "lifestyle",
  "lighting",
  "like",
  "lilly",
  "limited",
  "limo",
  "lincoln",
  "link",
  "lipsy",
  "live",
  "living",
  "lk",
  "llc",
  "llp",
  "loan",
  "loans",
  "locker",
  "locus",
  "lol",
  "london",
  "lotte",
  "lotto",
  "love",
  "lpl",
  "lplfinancial",
  "lr",
  "ls",
  "lt",
  "ltd",
  "ltda",
  "lu",
  "lundbeck",
  "luxe",
  "luxury",
  "lv",
  "ly",
  "ma",
  "madrid",
  "maif",
  "maison",
  "makeup",
  "man",
  "management",
  "mango",
  "map",
  "market",
  "marketing",
  "markets",
  "marriott",
  "marshalls",
  "mattel",
  "mba",
  "mc",
  "mckinsey",
  "md",
  "me",
  "med",
  "media",
  "meet",
  "melbourne",
  "meme",
  "memorial",
  "men",
  "menu",
  "merckmsd",
  "mg",
  "mh",
  "miami",
  "microsoft",
  "mil",
  "mini",
  "mint",
  "mit",
  "mitsubishi",
  "mk",
  "ml",
  "mlb",
  "mls",
  "mm",
  "mma",
  "mn",
  "mo",
  "mobi",
  "mobile",
  "moda",
  "moe",
  "moi",
  "mom",
  "monash",
  "money",
  "monster",
  "mormon",
  "mortgage",
  "moscow",
  "moto",
  "motorcycles",
  "mov",
  "movie",
  "mp",
  "mq",
  "mr",
  "ms",
  "msd",
  "mt",
  "mtn",
  "mtr",
  "mu",
  "museum",
  "music",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "nab",
  "nagoya",
  "name",
  "navy",
  "nba",
  "nc",
  "ne",
  "nec",
  "net",
  "netbank",
  "netflix",
  "network",
  "neustar",
  "new",
  "news",
  "next",
  "nextdirect",
  "nexus",
  "nf",
  "nfl",
  "ng",
  "ngo",
  "nhk",
  "ni",
  "nico",
  "nike",
  "nikon",
  "ninja",
  "nissan",
  "nissay",
  "nl",
  "no",
  "nokia",
  "norton",
  "now",
  "nowruz",
  "nowtv",
  "np",
  "nr",
  "nra",
  "nrw",
  "ntt",
  "nu",
  "nyc",
  "nz",
  "obi",
  "observer",
  "office",
  "okinawa",
  "olayan",
  "olayangroup",
  "ollo",
  "om",
  "omega",
  "one",
  "ong",
  "onl",
  "online",
  "ooo",
  "open",
  "oracle",
  "orange",
  "org",
  "organic",
  "origins",
  "osaka",
  "otsuka",
  "ott",
  "ovh",
  "pa",
  "page",
  "panasonic",
  "paris",
  "pars",
  "partners",
  "parts",
  "party",
  "pay",
  "pccw",
  "pe",
  "pet",
  "pf",
  "pfizer",
  "pg",
  "ph",
  "pharmacy",
  "phd",
  "philips",
  "phone",
  "photo",
  "photography",
  "photos",
  "physio",
  "pics",
  "pictet",
  "pictures",
  "pid",
  "pin",
  "ping",
  "pink",
  "pioneer",
  "pizza",
  "pk",
  "pl",
  "place",
  "play",
  "playstation",
  "plumbing",
  "plus",
  "pm",
  "pn",
  "pnc",
  "pohl",
  "poker",
  "politie",
  "porn",
  "post",
  "pr",
  "pramerica",
  "praxi",
  "press",
  "prime",
  "pro",
  "prod",
  "productions",
  "prof",
  "progressive",
  "promo",
  "properties",
  "property",
  "protection",
  "pru",
  "prudential",
  "ps",
  "pt",
  "pub",
  "pw",
  "pwc",
  "py",
  "qa",
  "qpon",
  "quebec",
  "quest",
  "racing",
  "radio",
  "re",
  "read",
  "realestate",
  "realtor",
  "realty",
  "recipes",
  "red",
  "redstone",
  "redumbrella",
  "rehab",
  "reise",
  "reisen",
  "reit",
  "reliance",
  "ren",
  "rent",
  "rentals",
  "repair",
  "report",
  "republican",
  "rest",
  "restaurant",
  "review",
  "reviews",
  "rexroth",
  "rich",
  "richardli",
  "ricoh",
  "ril",
  "rio",
  "rip",
  "ro",
  "rocks",
  "rodeo",
  "rogers",
  "room",
  "rs",
  "rsvp",
  "ru",
  "rugby",
  "ruhr",
  "run",
  "rw",
  "rwe",
  "ryukyu",
  "sa",
  "saarland",
  "safe",
  "safety",
  "sakura",
  "sale",
  "salon",
  "samsclub",
  "samsung",
  "sandvik",
  "sandvikcoromant",
  "sanofi",
  "sap",
  "sarl",
  "sas",
  "save",
  "saxo",
  "sb",
  "sbi",
  "sbs",
  "sc",
  "scb",
  "schaeffler",
  "schmidt",
  "scholarships",
  "school",
  "schule",
  "schwarz",
  "science",
  "scot",
  "sd",
  "se",
  "search",
  "seat",
  "secure",
  "security",
  "seek",
  "select",
  "sener",
  "services",
  "seven",
  "sew",
  "sex",
  "sexy",
  "sfr",
  "sg",
  "sh",
  "shangrila",
  "sharp",
  "shell",
  "shia",
  "shiksha",
  "shoes",
  "shop",
  "shopping",
  "shouji",
  "show",
  "si",
  "silk",
  "sina",
  "singles",
  "site",
  "sj",
  "sk",
  "ski",
  "skin",
  "sky",
  "skype",
  "sl",
  "sling",
  "sm",
  "smart",
  "smile",
  "sn",
  "sncf",
  "so",
  "soccer",
  "social",
  "softbank",
  "software",
  "sohu",
  "solar",
  "solutions",
  "song",
  "sony",
  "soy",
  "spa",
  "space",
  "sport",
  "spot",
  "sr",
  "srl",
  "ss",
  "st",
  "stada",
  "staples",
  "star",
  "statebank",
  "statefarm",
  "stc",
  "stcgroup",
  "stockholm",
  "storage",
  "store",
  "stream",
  "studio",
  "study",
  "style",
  "su",
  "sucks",
  "supplies",
  "supply",
  "support",
  "surf",
  "surgery",
  "suzuki",
  "sv",
  "swatch",
  "swiss",
  "sx",
  "sy",
  "sydney",
  "systems",
  "sz",
  "tab",
  "taipei",
  "talk",
  "taobao",
  "target",
  "tatamotors",
  "tatar",
  "tattoo",
  "tax",
  "taxi",
  "tc",
  "tci",
  "td",
  "tdk",
  "team",
  "tech",
  "technology",
  "tel",
  "temasek",
  "tennis",
  "teva",
  "tf",
  "tg",
  "th",
  "thd",
  "theater",
  "theatre",
  "tiaa",
  "tickets",
  "tienda",
  "tips",
  "tires",
  "tirol",
  "tj",
  "tjmaxx",
  "tjx",
  "tk",
  "tkmaxx",
  "tl",
  "tm",
  "tmall",
  "tn",
  "to",
  "today",
  "tokyo",
  "tools",
  "top",
  "toray",
  "toshiba",
  "total",
  "tours",
  "town",
  "toyota",
  "toys",
  "tr",
  "trade",
  "trading",
  "training",
  "travel",
  "travelers",
  "travelersinsurance",
  "trust",
  "trv",
  "tt",
  "tube",
  "tui",
  "tunes",
  "tushu",
  "tv",
  "tvs",
  "tw",
  "tz",
  "ua",
  "ubank",
  "ubs",
  "ug",
  "uk",
  "unicom",
  "university",
  "uno",
  "uol",
  "ups",
  "us",
  "uy",
  "uz",
  "va",
  "vacations",
  "vana",
  "vanguard",
  "vc",
  "ve",
  "vegas",
  "ventures",
  "verisign",
  "vermögensberater",
  "vermögensberatung",
  "versicherung",
  "vet",
  "vg",
  "vi",
  "viajes",
  "video",
  "vig",
  "viking",
  "villas",
  "vin",
  "vip",
  "virgin",
  "visa",
  "vision",
  "viva",
  "vivo",
  "vlaanderen",
  "vn",
  "vodka",
  "volvo",
  "vote",
  "voting",
  "voto",
  "voyage",
  "vu",
  "wales",
  "walmart",
  "walter",
  "wang",
  "wanggou",
  "watch",
  "watches",
  "weather",
  "weatherchannel",
  "webcam",
  "weber",
  "website",
  "wed",
  "wedding",
  "weibo",
  "weir",
  "wf",
  "whoswho",
  "wien",
  "wiki",
  "williamhill",
  "win",
  "windows",
  "wine",
  "winners",
  "wme",
  "wolterskluwer",
  "woodside",
  "work",
  "works",
  "world",
  "wow",
  "ws",
  "wtc",
  "wtf",
  "xbox",
  "xerox",
  "xihuan",
  "xin",
  "xxx",
  "xyz",
  "yachts",
  "yahoo",
  "yamaxun",
  "yandex",
  "ye",
  "yodobashi",
  "yoga",
  "yokohama",
  "you",
  "youtube",
  "yt",
  "yun",
  "za",
  "zappos",
  "zara",
  "zero",
  "zip",
  "zm",
  "zone",
  "zuerich",
  "zw",
  "ελ",
  "ευ",
  "бг",
  "бел",
  "дети",
  "ею",
  "католик",
  "ком",
  "мкд",
  "мон",
  "москва",
  "онлайн",
  "орг",
  "рус",
  "рф",
  "сайт",
  "срб",
  "укр",
  "қаз",
  "հայ",
  "ישראל",
  "קום",
  "ابوظبي",
  "ارامكو",
  "الاردن",
  "البحرين",
  "الجزائر",
  "السعودية",
  "العليان",
  "المغرب",
  "امارات",
  "ایران",
  "بارت",
  "بازار",
  "بيتك",
  "بھارت",
  "تونس",
  "سودان",
  "سورية",
  "شبكة",
  "عراق",
  "عرب",
  "عمان",
  "فلسطين",
  "قطر",
  "كاثوليك",
  "كوم",
  "مصر",
  "مليسيا",
  "موريتانيا",
  "موقع",
  "همراه",
  "پاکستان",
  "ڀارت",
  "कॉम",
  "नेट",
  "भारत",
  "भारतम्",
  "भारोत",
  "संगठन",
  "বাংলা",
  "ভারত",
  "ভাৰত",
  "ਭਾਰਤ",
  "ભારત",
  "ଭାରତ",
  "இந்தியா",
  "இலங்கை",
  "சிங்கப்பூர்",
  "భారత్",
  "ಭಾರತ",
  "ഭാരതം",
  "ලංකා",
  "คอม",
  "ไทย",
  "ລາວ",
  "გე",
  "みんな",
  "アマゾン",
  "クラウド",
  "グーグル",
  "コム",
  "ストア",
  "セール",
  "ファッション",
  "ポイント",
  "世界",
  "中信",
  "中国",
  "中國",
  "中文网",
  "亚马逊",
  "企业",
  "佛山",
  "信息",
  "健康",
  "八卦",
  "公司",
  "公益",
  "台湾",
  "台灣",
  "商城",
  "商店",
  "商标",
  "嘉里",
  "嘉里大酒店",
  "在线",
  "大拿",
  "天主教",
  "娱乐",
  "家電",
  "广东",
  "微博",
  "慈善",
  "我爱你",
  "手机",
  "招聘",
  "政务",
  "政府",
  "新加坡",
  "新闻",
  "时尚",
  "書籍",
  "机构",
  "淡马锡",
  "游戏",
  "澳門",
  "点看",
  "移动",
  "组织机构",
  "网址",
  "网店",
  "网站",
  "网络",
  "联通",
  "谷歌",
  "购物",
  "通販",
  "集团",
  "電訊盈科",
  "飞利浦",
  "食品",
  "餐厅",
  "香格里拉",
  "香港",
  "닷넷",
  "닷컴",
  "삼성",
  "한국"
];
var $r = {};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.TAG_REGEX = $r.TRAILING_PUNCTUATION_REGEX = $r.URL_REGEX = $r.MENTION_REGEX = void 0;
$r.MENTION_REGEX = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
$r.URL_REGEX = /(^|\s|\()((https?:\/\/[\S]+)|((?<domain>[a-z][a-z0-9]*(\.[a-z0-9]+)+)[\S]*))/gim;
$r.TRAILING_PUNCTUATION_REGEX = /\p{P}+$/gu;
$r.TAG_REGEX = // eslint-disable-next-line no-misleading-character-class
/(^|\s)[#＃]((?!\ufe0f)[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*[^\d\s\p{P}\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]+[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*)?/gu;
var CO = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty($u, "__esModule", { value: !0 });
$u.detectFacets = void 0;
const SO = CO(TO), nu = $r;
function LO(t) {
  let e;
  const r = [];
  {
    const i = nu.MENTION_REGEX;
    for (; e = i.exec(t.utf16); ) {
      if (!yf(e[3]) && !e[3].endsWith(".test"))
        continue;
      const a = t.utf16.indexOf(e[3], e.index) - 1;
      r.push({
        $type: "app.bsky.richtext.facet",
        index: {
          byteStart: t.utf16IndexToUtf8Index(a),
          byteEnd: t.utf16IndexToUtf8Index(a + e[3].length + 1)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#mention",
            did: e[3]
            // must be resolved afterwards
          }
        ]
      });
    }
  }
  {
    const i = nu.URL_REGEX;
    for (; e = i.exec(t.utf16); ) {
      let a = e[2];
      if (!a.startsWith("http")) {
        const m = e.groups?.domain;
        if (!m || !yf(m))
          continue;
        a = `https://${a}`;
      }
      const c = t.utf16.indexOf(e[2], e.index), h = { start: c, end: c + e[2].length };
      /[.,;:!?]$/.test(a) && (a = a.slice(0, -1), h.end--), /[)]$/.test(a) && !a.includes("(") && (a = a.slice(0, -1), h.end--), r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(h.start),
          byteEnd: t.utf16IndexToUtf8Index(h.end)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#link",
            uri: a
          }
        ]
      });
    }
  }
  {
    const i = nu.TAG_REGEX;
    for (; e = i.exec(t.utf16); ) {
      const a = e[1];
      let c = e[2];
      if (!c || (c = c.trim().replace(nu.TRAILING_PUNCTUATION_REGEX, ""), c.length === 0 || c.length > 64))
        continue;
      const h = e.index + a.length;
      r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(h),
          byteEnd: t.utf16IndexToUtf8Index(h + 1 + c.length)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#tag",
            tag: c
          }
        ]
      });
    }
  }
  return r.length > 0 ? r : void 0;
}
$u.detectFacets = LO;
function yf(t) {
  return !!SO.default.find((e) => {
    const r = t.lastIndexOf(e);
    return r === -1 ? !1 : t.charAt(r - 1) === "." && r === t.length - e.length;
  });
}
Object.defineProperty(js, "__esModule", { value: !0 });
js.RichText = js.RichTextSegment = void 0;
const In = x, hc = Xs, kO = jl, bf = $u;
class bs {
  constructor(e, r) {
    Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "facet", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  get link() {
    const e = this.facet?.features.find(In.AppBskyRichtextFacet.isLink);
    if (In.AppBskyRichtextFacet.isLink(e))
      return e;
  }
  isLink() {
    return !!this.link;
  }
  get mention() {
    const e = this.facet?.features.find(In.AppBskyRichtextFacet.isMention);
    if (In.AppBskyRichtextFacet.isMention(e))
      return e;
  }
  isMention() {
    return !!this.mention;
  }
  get tag() {
    const e = this.facet?.features.find(In.AppBskyRichtextFacet.isTag);
    if (In.AppBskyRichtextFacet.isTag(e))
      return e;
  }
  isTag() {
    return !!this.tag;
  }
}
js.RichTextSegment = bs;
class rd {
  constructor(e, r) {
    Object.defineProperty(this, "unicodeText", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "facets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.unicodeText = new hc.UnicodeString(e.text), this.facets = e.facets, !this.facets?.length && e.entities?.length && (this.facets = DO(this.unicodeText, e.entities)), this.facets && this.facets.sort(mc), r?.cleanNewlines && (0, kO.sanitizeRichText)(this, { cleanNewlines: !0 }).copyInto(this);
  }
  get text() {
    return this.unicodeText.toString();
  }
  get length() {
    return this.unicodeText.length;
  }
  get graphemeLength() {
    return this.unicodeText.graphemeLength;
  }
  clone() {
    return new rd({
      text: this.unicodeText.utf16,
      facets: gf(this.facets)
    });
  }
  copyInto(e) {
    e.unicodeText = this.unicodeText, e.facets = gf(this.facets);
  }
  *segments() {
    const e = this.facets || [];
    if (!e.length) {
      yield new bs(this.unicodeText.utf16);
      return;
    }
    let r = 0, i = 0;
    do {
      const a = e[i];
      if (r < a.index.byteStart)
        yield new bs(this.unicodeText.slice(r, a.index.byteStart));
      else if (r > a.index.byteStart) {
        i++;
        continue;
      }
      if (a.index.byteStart < a.index.byteEnd) {
        const c = this.unicodeText.slice(a.index.byteStart, a.index.byteEnd);
        c.trim() ? yield new bs(c, a) : yield new bs(c);
      }
      r = a.index.byteEnd, i++;
    } while (i < e.length);
    r < this.unicodeText.length && (yield new bs(this.unicodeText.slice(r, this.unicodeText.length)));
  }
  insert(e, r) {
    if (this.unicodeText = new hc.UnicodeString(this.unicodeText.slice(0, e) + r + this.unicodeText.slice(e)), !this.facets?.length)
      return this;
    const i = r.length;
    for (const a of this.facets)
      e <= a.index.byteStart ? (a.index.byteStart += i, a.index.byteEnd += i) : e >= a.index.byteStart && e < a.index.byteEnd && (a.index.byteEnd += i);
    return this;
  }
  delete(e, r) {
    if (this.unicodeText = new hc.UnicodeString(this.unicodeText.slice(0, e) + this.unicodeText.slice(r)), !this.facets?.length)
      return this;
    const i = r - e;
    for (const a of this.facets)
      e <= a.index.byteStart && r >= a.index.byteEnd ? (a.index.byteStart = 0, a.index.byteEnd = 0) : e > a.index.byteEnd || (e > a.index.byteStart && e <= a.index.byteEnd && r > a.index.byteEnd ? a.index.byteEnd = e : e >= a.index.byteStart && r <= a.index.byteEnd ? a.index.byteEnd -= i : e < a.index.byteStart && r >= a.index.byteStart && r <= a.index.byteEnd ? (a.index.byteStart = e, a.index.byteEnd -= i) : r < a.index.byteStart && (a.index.byteStart -= i, a.index.byteEnd -= i));
    return this.facets = this.facets.filter((a) => a.index.byteStart < a.index.byteEnd), this;
  }
  /**
   * Detects facets such as links and mentions
   * Note: Overwrites the existing facets with auto-detected facets
   */
  async detectFacets(e) {
    if (this.facets = (0, bf.detectFacets)(this.unicodeText), this.facets) {
      for (const r of this.facets)
        for (const i of r.features)
          if (In.AppBskyRichtextFacet.isMention(i)) {
            const a = await e.resolveHandle({ handle: i.did }).catch((c) => {
            }).then((c) => c?.data.did);
            i.did = a || "";
          }
      this.facets.sort(mc);
    }
  }
  /**
   * Detects facets such as links and mentions but does not resolve them
   * Will produce invalid facets! For instance, mentions will not have their DIDs set.
   * Note: Overwrites the existing facets with auto-detected facets
   */
  detectFacetsWithoutResolution() {
    this.facets = (0, bf.detectFacets)(this.unicodeText), this.facets && this.facets.sort(mc);
  }
}
js.RichText = rd;
const mc = (t, e) => t.index.byteStart - e.index.byteStart;
function DO(t, e) {
  const r = [];
  for (const i of e)
    i.type === "link" ? r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(i.index.start),
        byteEnd: t.utf16IndexToUtf8Index(i.index.end)
      },
      features: [{ $type: "app.bsky.richtext.facet#link", uri: i.value }]
    }) : i.type === "mention" && r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(i.index.start),
        byteEnd: t.utf16IndexToUtf8Index(i.index.end)
      },
      features: [
        { $type: "app.bsky.richtext.facet#mention", did: i.value }
      ]
    });
  return r;
}
function gf(t) {
  return typeof t > "u" ? t : JSON.parse(JSON.stringify(t));
}
var id = {}, xi = {}, zr = {}, ur = {};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.NOOP_BEHAVIOR = ur.HIDE_BEHAVIOR = ur.MUTEWORD_BEHAVIOR = ur.MUTE_BEHAVIOR = ur.BLOCK_BEHAVIOR = ur.CUSTOM_LABEL_VALUE_RE = void 0;
ur.CUSTOM_LABEL_VALUE_RE = /^[a-z-]+$/;
ur.BLOCK_BEHAVIOR = {
  profileList: "blur",
  profileView: "alert",
  avatar: "blur",
  banner: "blur",
  contentList: "blur",
  contentView: "blur"
};
ur.MUTE_BEHAVIOR = {
  profileList: "inform",
  profileView: "alert",
  contentList: "blur",
  contentView: "inform"
};
ur.MUTEWORD_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
ur.HIDE_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
ur.NOOP_BEHAVIOR = {};
var Fl = {};
Object.defineProperty(Fl, "__esModule", { value: !0 });
Fl.ModerationUI = void 0;
class PO {
  constructor() {
    Object.defineProperty(this, "noOverride", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "filters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blurs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "alerts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "informs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  get filter() {
    return this.filters.length !== 0;
  }
  get blur() {
    return this.blurs.length !== 0;
  }
  get alert() {
    return this.alerts.length !== 0;
  }
  get inform() {
    return this.informs.length !== 0;
  }
}
Fl.ModerationUI = PO;
var En = {};
Object.defineProperty(En, "__esModule", { value: !0 });
En.LABELS = En.DEFAULT_LABEL_SETTINGS = void 0;
En.DEFAULT_LABEL_SETTINGS = {
  porn: "hide",
  sexual: "warn",
  nudity: "ignore",
  "graphic-media": "warn"
};
En.LABELS = {
  "!hide": {
    identifier: "!hide",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "no-self"],
    severity: "alert",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!warn": {
    identifier: "!warn",
    configurable: !1,
    defaultSetting: "warn",
    flags: ["no-self"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!no-unauthenticated": {
    identifier: "!no-unauthenticated",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "unauthed"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  porn: {
    identifier: "porn",
    configurable: !0,
    defaultSetting: "hide",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  sexual: {
    identifier: "sexual",
    configurable: !0,
    defaultSetting: "warn",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  nudity: {
    identifier: "nudity",
    configurable: !0,
    defaultSetting: "ignore",
    flags: [],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  "graphic-media": {
    identifier: "graphic-media",
    flags: ["adult"],
    configurable: !0,
    defaultSetting: "warn",
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  }
};
Object.defineProperty(zr, "__esModule", { value: !0 });
zr.ModerationDecision = void 0;
const mr = ur, BO = Fl, xf = En;
var cn;
(function(t) {
  t[t.High = 0] = "High", t[t.Medium = 1] = "Medium", t[t.Low = 2] = "Low";
})(cn || (cn = {}));
class nd {
  constructor() {
    Object.defineProperty(this, "did", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "isMe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "causes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  static merge(...e) {
    const r = e.filter((a) => !!a), i = new nd();
    return r[0] && (i.did = r[0].did, i.isMe = r[0].isMe), i.causes = r.flatMap((a) => a.causes), i;
  }
  downgrade() {
    for (const e of this.causes)
      e.downgraded = !0;
    return this;
  }
  get blocked() {
    return !!this.blockCause;
  }
  get muted() {
    return !!this.muteCause;
  }
  get blockCause() {
    return this.causes.find((e) => e.type === "blocking" || e.type === "blocked-by" || e.type === "block-other");
  }
  get muteCause() {
    return this.causes.find((e) => e.type === "muted");
  }
  get labelCauses() {
    return this.causes.filter((e) => e.type === "label");
  }
  ui(e) {
    const r = new BO.ModerationUI();
    for (const i of this.causes)
      if (i.type === "blocking" || i.type === "blocked-by" || i.type === "block-other") {
        if (this.isMe)
          continue;
        (e === "profileList" || e === "contentList") && r.filters.push(i), i.downgraded || (mr.BLOCK_BEHAVIOR[e] === "blur" ? (r.noOverride = !0, r.blurs.push(i)) : mr.BLOCK_BEHAVIOR[e] === "alert" ? r.alerts.push(i) : mr.BLOCK_BEHAVIOR[e] === "inform" && r.informs.push(i));
      } else if (i.type === "muted") {
        if (this.isMe)
          continue;
        (e === "profileList" || e === "contentList") && r.filters.push(i), i.downgraded || (mr.MUTE_BEHAVIOR[e] === "blur" ? r.blurs.push(i) : mr.MUTE_BEHAVIOR[e] === "alert" ? r.alerts.push(i) : mr.MUTE_BEHAVIOR[e] === "inform" && r.informs.push(i));
      } else if (i.type === "mute-word") {
        if (this.isMe)
          continue;
        e === "contentList" && r.filters.push(i), i.downgraded || (mr.MUTEWORD_BEHAVIOR[e] === "blur" ? r.blurs.push(i) : mr.MUTEWORD_BEHAVIOR[e] === "alert" ? r.alerts.push(i) : mr.MUTEWORD_BEHAVIOR[e] === "inform" && r.informs.push(i));
      } else i.type === "hidden" ? ((e === "profileList" || e === "contentList") && r.filters.push(i), i.downgraded || (mr.HIDE_BEHAVIOR[e] === "blur" ? r.blurs.push(i) : mr.HIDE_BEHAVIOR[e] === "alert" ? r.alerts.push(i) : mr.HIDE_BEHAVIOR[e] === "inform" && r.informs.push(i))) : i.type === "label" && (e === "profileList" && i.target === "account" ? i.setting === "hide" && !this.isMe && r.filters.push(i) : e === "contentList" && (i.target === "account" || i.target === "content") && i.setting === "hide" && !this.isMe && r.filters.push(i), i.downgraded || (i.behavior[e] === "blur" ? (r.blurs.push(i), i.noOverride && !this.isMe && (r.noOverride = !0)) : i.behavior[e] === "alert" ? r.alerts.push(i) : i.behavior[e] === "inform" && r.informs.push(i)));
    return r.filters.sort(Ef), r.blurs.sort(Ef), r;
  }
  setDid(e) {
    this.did = e;
  }
  setIsMe(e) {
    this.isMe = e;
  }
  addHidden(e) {
    e && this.causes.push({
      type: "hidden",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedWord(e) {
    e && this.causes.push({
      type: "mute-word",
      source: { type: "user" },
      priority: 6
    });
  }
  addBlocking(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "user" },
      priority: 3
    });
  }
  addBlockingByList(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "list", list: e },
      priority: 3
    });
  }
  addBlockedBy(e) {
    e && this.causes.push({
      type: "blocked-by",
      source: { type: "user" },
      priority: 4
    });
  }
  addBlockOther(e) {
    e && this.causes.push({
      type: "block-other",
      source: { type: "user" },
      priority: 4
    });
  }
  addLabel(e, r, i) {
    const a = mr.CUSTOM_LABEL_VALUE_RE.test(r.val) && i.labelDefs?.[r.src]?.find((A) => A.identifier === r.val) || xf.LABELS[r.val];
    if (!a)
      return;
    const c = r.src === this.did, h = c ? void 0 : i.prefs.labelers.find((A) => A.did === r.src);
    if (!c && !h || c && a.flags.includes("no-self"))
      return;
    let m = a.defaultSetting || "ignore";
    if (a.configurable ? a.flags.includes("adult") && !i.prefs.adultContentEnabled ? m = "hide" : h?.labels[a.identifier] ? m = h?.labels[a.identifier] : i.prefs.labels[a.identifier] && (m = i.prefs.labels[a.identifier]) : m = a.defaultSetting || "hide", m === "ignore" || a.flags.includes("unauthed") && i.userDid)
      return;
    let p;
    const y = IO(a.behaviors[e]);
    a.flags.includes("no-override") || a.flags.includes("adult") && !i.prefs.adultContentEnabled ? p = 1 : m === "hide" ? p = 2 : y === cn.High ? p = 5 : y === cn.Medium ? p = 7 : p = 8;
    let d = !1;
    (a.flags.includes("no-override") || a.flags.includes("adult") && !i.prefs.adultContentEnabled) && (d = !0), this.causes.push({
      type: "label",
      source: c || !h ? { type: "user" } : { type: "labeler", did: h.did },
      label: r,
      labelDef: a,
      target: e,
      setting: m,
      behavior: a.behaviors[e] || mr.NOOP_BEHAVIOR,
      noOverride: d,
      priority: p
    });
  }
  addMuted(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedByList(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "list", list: e },
      priority: 6
    });
  }
}
zr.ModerationDecision = nd;
function IO(t) {
  return t ? t.profileView === "blur" || t.contentView === "blur" ? cn.High : t.contentList === "blur" || t.contentMedia === "blur" ? cn.Medium : cn.Low : cn.Low;
}
function Ef(t, e) {
  return t.priority - e.priority;
}
Object.defineProperty(xi, "__esModule", { value: !0 });
xi.filterAccountLabels = xi.decideAccount = void 0;
const UO = zr;
function OO(t, e) {
  const r = new UO.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid), t.viewer?.muted && (t.viewer?.mutedByList ? r.addMutedByList(t.viewer?.mutedByList) : r.addMuted(t.viewer?.muted)), t.viewer?.blocking && (t.viewer?.blockingByList ? r.addBlockingByList(t.viewer?.blockingByList) : r.addBlocking(t.viewer?.blocking)), r.addBlockedBy(t.viewer?.blockedBy);
  for (const i of Fm(t.labels))
    r.addLabel("account", i, e);
  return r;
}
xi.decideAccount = OO;
function Fm(t) {
  return t ? t.filter((e) => !e.uri.endsWith("/app.bsky.actor.profile/self") || e.val === "!no-unauthenticated") : [];
}
xi.filterAccountLabels = Fm;
var Ei = {};
Object.defineProperty(Ei, "__esModule", { value: !0 });
Ei.filterProfileLabels = Ei.decideProfile = void 0;
const KO = zr;
function MO(t, e) {
  const r = new KO.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid);
  for (const i of $m(t.labels))
    r.addLabel("profile", i, e);
  return r;
}
Ei.decideProfile = MO;
function $m(t) {
  return t ? t.filter((e) => e.uri.endsWith("/app.bsky.actor.profile/self")) : [];
}
Ei.filterProfileLabels = $m;
var Gu = {};
Object.defineProperty(Gu, "__esModule", { value: !0 });
Gu.decideNotification = void 0;
const vf = zr, NO = xi, VO = Ei;
function jO(t, e) {
  const r = new vf.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const i of t.labels)
      r.addLabel("content", i, e);
  return vf.ModerationDecision.merge(r, (0, NO.decideAccount)(t.author, e), (0, VO.decideProfile)(t.author, e));
}
Gu.decideNotification = jO;
var qu = {}, $l = {};
Object.defineProperty($l, "__esModule", { value: !0 });
$l.hasMutedWord = void 0;
const FO = x, Rf = {
  LEADING_TRAILING_PUNCTUATION: /(?:^\p{P}+|\p{P}+$)/gu,
  ESCAPE: /[[\]{}()*+?.\\^$|\s]/g,
  SEPARATORS: /[/\-–—()[\]_]+/g,
  WORD_BOUNDARY: /[\s\n\t\r\f\v]+?/g
}, $O = [
  "ja",
  // Japanese
  "zh",
  // Chinese
  "ko",
  // Korean
  "th",
  // Thai
  "vi"
  // Vietnamese
];
function GO({ mutedWords: t, text: e, facets: r, outlineTags: i, languages: a, actor: c }) {
  const h = $O.includes(a?.[0] || ""), m = [].concat(i || []).concat((r || []).flatMap((p) => p.features.filter(FO.AppBskyRichtextFacet.isTag).map((y) => y.tag))).map((p) => p.toLowerCase());
  for (const p of t) {
    const y = p.value.toLowerCase(), d = e.toLowerCase();
    if (p.expiresAt && p.expiresAt < (/* @__PURE__ */ new Date()).toISOString() || p.actorTarget === "exclude-following" && c?.viewer?.following)
      continue;
    if (m.includes(y))
      return !0;
    if (!p.targets.includes("content"))
      continue;
    if ((y.length === 1 || h) && d.includes(y))
      return !0;
    if (y.length > d.length)
      continue;
    if (y === d || /(?:\s|\p{P})+?/u.test(y) && d.includes(y))
      return !0;
    const A = d.split(Rf.WORD_BOUNDARY);
    for (const B of A) {
      if (B === y)
        return !0;
      const K = B.replace(Rf.LEADING_TRAILING_PUNCTUATION, "");
      if (y === K)
        return !0;
      if (!(y.length > K.length) && /\p{P}+/u.test(K)) {
        const O = K.replace(/\p{P}+/gu, " ");
        if (O === y || O.replace(/\s/gu, "") === y)
          return !0;
        const X = K.split(/\p{P}+/u);
        for (const H of X)
          if (H === y)
            return !0;
      }
    }
  }
  return !1;
}
$l.hasMutedWord = GO;
Object.defineProperty(qu, "__esModule", { value: !0 });
qu.decidePost = void 0;
const Ea = zr, nt = x, Qr = $l, Gm = xi, qm = Ei;
function qO(t, e) {
  const r = new Ea.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const a of t.labels)
      r.addLabel("content", a, e);
  r.addHidden(zO(t, e.prefs.hiddenPosts)), r.isMe || r.addMutedWord(XO(t, e.prefs.mutedWords));
  let i;
  return t.embed && (nt.AppBskyEmbedRecord.isViewRecord(t.embed.record) ? i = Af(t.embed.record, e) : nt.AppBskyEmbedRecordWithMedia.isView(t.embed) && nt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) ? i = Af(t.embed.record.record, e) : nt.AppBskyEmbedRecord.isViewBlocked(t.embed.record) ? i = _f(t.embed.record, e) : nt.AppBskyEmbedRecordWithMedia.isView(t.embed) && nt.AppBskyEmbedRecord.isViewBlocked(t.embed.record.record) && (i = _f(t.embed.record.record, e))), Ea.ModerationDecision.merge(r, i?.downgrade(), (0, Gm.decideAccount)(t.author, e), (0, qm.decideProfile)(t.author, e));
}
qu.decidePost = qO;
function Af(t, e) {
  const r = new Ea.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const i of t.labels)
      r.addLabel("content", i, e);
  return Ea.ModerationDecision.merge(r, (0, Gm.decideAccount)(t.author, e), (0, qm.decideProfile)(t.author, e));
}
function _f(t, e) {
  const r = new Ea.ModerationDecision();
  return r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.author.viewer?.muted && (t.author.viewer?.mutedByList ? r.addMutedByList(t.author.viewer?.mutedByList) : r.addMuted(t.author.viewer?.muted)), t.author.viewer?.blocking && (t.author.viewer?.blockingByList ? r.addBlockingByList(t.author.viewer?.blockingByList) : r.addBlocking(t.author.viewer?.blocking)), r.addBlockedBy(t.author.viewer?.blockedBy), r;
}
function zO(t, e) {
  return e?.length ? !!(e.includes(t.uri) || t.embed && (nt.AppBskyEmbedRecord.isViewRecord(t.embed.record) && e.includes(t.embed.record.uri) || nt.AppBskyEmbedRecordWithMedia.isView(t.embed) && nt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) && e.includes(t.embed.record.record.uri))) : !1;
}
function XO(t, e) {
  if (!e?.length)
    return !1;
  const r = t.author;
  if (nt.AppBskyFeedPost.isRecord(t.record)) {
    if ((0, Qr.hasMutedWord)({
      mutedWords: e,
      text: t.record.text,
      facets: t.record.facets,
      outlineTags: t.record.tags,
      languages: t.record.langs,
      actor: r
    }))
      return !0;
    if (t.record.embed && nt.AppBskyEmbedImages.isMain(t.record.embed)) {
      for (const i of t.record.embed.images)
        if ((0, Qr.hasMutedWord)({
          mutedWords: e,
          text: i.alt,
          languages: t.record.langs,
          actor: r
        }))
          return !0;
    }
  }
  if (t.embed) {
    if (nt.AppBskyEmbedRecord.isViewRecord(t.embed.record)) {
      if (nt.AppBskyFeedPost.isRecord(t.embed.record.value)) {
        const i = t.embed.record.value, a = t.embed.record.author;
        if ((0, Qr.hasMutedWord)({
          mutedWords: e,
          text: i.text,
          facets: i.facets,
          outlineTags: i.tags,
          languages: i.langs,
          actor: a
        }))
          return !0;
        if (nt.AppBskyEmbedImages.isMain(i.embed)) {
          for (const c of i.embed.images)
            if ((0, Qr.hasMutedWord)({
              mutedWords: e,
              text: c.alt,
              languages: i.langs,
              actor: a
            }))
              return !0;
        }
        if (nt.AppBskyEmbedExternal.isMain(i.embed)) {
          const { external: c } = i.embed;
          if ((0, Qr.hasMutedWord)({
            mutedWords: e,
            text: c.title + " " + c.description,
            languages: [],
            actor: a
          }))
            return !0;
        }
        if (nt.AppBskyEmbedRecordWithMedia.isMain(i.embed)) {
          if (nt.AppBskyEmbedExternal.isMain(i.embed.media)) {
            const { external: c } = i.embed.media;
            if ((0, Qr.hasMutedWord)({
              mutedWords: e,
              text: c.title + " " + c.description,
              languages: [],
              actor: a
            }))
              return !0;
          }
          if (nt.AppBskyEmbedImages.isMain(i.embed.media)) {
            for (const c of i.embed.media.images)
              if ((0, Qr.hasMutedWord)({
                mutedWords: e,
                text: c.alt,
                languages: nt.AppBskyFeedPost.isRecord(i.record) ? i.langs : [],
                actor: a
              }))
                return !0;
          }
        }
      }
    } else if (nt.AppBskyEmbedExternal.isView(t.embed)) {
      const { external: i } = t.embed;
      if ((0, Qr.hasMutedWord)({
        mutedWords: e,
        text: i.title + " " + i.description,
        languages: [],
        actor: r
      }))
        return !0;
    } else if (nt.AppBskyEmbedRecordWithMedia.isView(t.embed) && nt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record)) {
      const i = t.embed.record.record.author;
      if (nt.AppBskyFeedPost.isRecord(t.embed.record.record.value)) {
        const a = t.embed.record.record.value;
        if ((0, Qr.hasMutedWord)({
          mutedWords: e,
          text: a.text,
          facets: a.facets,
          outlineTags: a.tags,
          languages: a.langs,
          actor: i
        }))
          return !0;
      }
      if (nt.AppBskyEmbedImages.isView(t.embed.media)) {
        for (const a of t.embed.media.images)
          if ((0, Qr.hasMutedWord)({
            mutedWords: e,
            text: a.alt,
            languages: nt.AppBskyFeedPost.isRecord(t.record) ? t.record.langs : [],
            actor: i
          }))
            return !0;
      }
    }
  }
  return !1;
}
var zu = {};
Object.defineProperty(zu, "__esModule", { value: !0 });
zu.decideFeedGenerator = void 0;
const wf = zr, HO = xi, ZO = Ei;
function WO(t, e) {
  const r = new wf.ModerationDecision();
  if (r.setDid(t.creator.did), r.setIsMe(t.creator.did === e.userDid), t.labels?.length)
    for (const i of t.labels)
      r.addLabel("content", i, e);
  return wf.ModerationDecision.merge(r, (0, HO.decideAccount)(t.creator, e), (0, ZO.decideProfile)(t.creator, e));
}
zu.decideFeedGenerator = WO;
var Xu = {};
Object.defineProperty(Xu, "__esModule", { value: !0 });
Xu.decideUserList = void 0;
const YO = as, Tf = zr, JO = xi, QO = Ei;
function eK(t, e) {
  const r = new Tf.ModerationDecision(), i = tK(t.creator) ? t.creator : void 0;
  if (i) {
    if (r.setDid(i.did), r.setIsMe(i.did === e.userDid), t.labels?.length)
      for (const c of t.labels)
        r.addLabel("content", c, e);
    return Tf.ModerationDecision.merge(r, (0, JO.decideAccount)(i, e), (0, QO.decideProfile)(i, e));
  }
  const a = new YO.AtUri(t.uri).hostname;
  if (r.setDid(a), r.setIsMe(a === e.userDid), t.labels?.length)
    for (const c of t.labels)
      r.addLabel("content", c, e);
  return r;
}
Xu.decideUserList = eK;
function tK(t) {
  return t && typeof t == "object" && "did" in t;
}
var ui = {};
Object.defineProperty(ui, "__esModule", { value: !0 });
ui.interpretLabelValueDefinitions = ui.interpretLabelValueDefinition = ui.isQuotedPostWithMedia = ui.isQuotedPost = void 0;
const sd = x;
function rK(t) {
  return !!(t && sd.AppBskyEmbedRecord.isView(t));
}
ui.isQuotedPost = rK;
function iK(t) {
  return !!(t && sd.AppBskyEmbedRecordWithMedia.isView(t));
}
ui.isQuotedPostWithMedia = iK;
function zm(t, e) {
  const r = {
    account: {},
    profile: {},
    content: {}
  }, i = t.severity === "alert" ? "alert" : t.severity === "inform" ? "inform" : void 0;
  t.blurs === "content" ? (r.account.profileList = i, r.account.profileView = i, r.account.contentList = "blur", r.account.contentView = t.adultOnly ? "blur" : i, r.profile.profileList = i, r.profile.profileView = i, r.content.contentList = "blur", r.content.contentView = t.adultOnly ? "blur" : i) : t.blurs === "media" ? (r.account.profileList = i, r.account.profileView = i, r.account.avatar = "blur", r.account.banner = "blur", r.profile.profileList = i, r.profile.profileView = i, r.profile.avatar = "blur", r.profile.banner = "blur", r.content.contentMedia = "blur") : t.blurs === "none" && (r.account.profileList = i, r.account.profileView = i, r.account.contentList = i, r.account.contentView = i, r.profile.profileList = i, r.profile.profileView = i, r.content.contentList = i, r.content.contentView = i);
  let a = "warn";
  (t.defaultSetting === "hide" || t.defaultSetting === "ignore") && (a = t.defaultSetting);
  const c = ["no-self"];
  return t.adultOnly && c.push("adult"), {
    ...t,
    definedBy: e,
    configurable: !0,
    defaultSetting: a,
    flags: c,
    behaviors: r
  };
}
ui.interpretLabelValueDefinition = zm;
function nK(t) {
  return (t.policies?.labelValueDefinitions || []).filter((e) => sd.ComAtprotoLabelDefs.validateLabelValueDefinition(e).success).map((e) => zm(e, t.creator.did));
}
ui.interpretLabelValueDefinitions = nK;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.moderateUserList = t.moderateFeedGenerator = t.moderateNotification = t.moderatePost = t.moderateProfile = t.interpretLabelValueDefinitions = t.interpretLabelValueDefinition = t.hasMutedWord = t.ModerationDecision = t.ModerationUI = void 0;
  const e = xi, r = Ei, i = Gu, a = qu, c = zu, h = Xu, m = zr;
  var p = Fl;
  Object.defineProperty(t, "ModerationUI", { enumerable: !0, get: function() {
    return p.ModerationUI;
  } });
  var y = zr;
  Object.defineProperty(t, "ModerationDecision", { enumerable: !0, get: function() {
    return y.ModerationDecision;
  } });
  var d = $l;
  Object.defineProperty(t, "hasMutedWord", { enumerable: !0, get: function() {
    return d.hasMutedWord;
  } });
  var A = ui;
  Object.defineProperty(t, "interpretLabelValueDefinition", { enumerable: !0, get: function() {
    return A.interpretLabelValueDefinition;
  } }), Object.defineProperty(t, "interpretLabelValueDefinitions", { enumerable: !0, get: function() {
    return A.interpretLabelValueDefinitions;
  } });
  function B(H, V) {
    return m.ModerationDecision.merge((0, e.decideAccount)(H, V), (0, r.decideProfile)(H, V));
  }
  t.moderateProfile = B;
  function K(H, V) {
    return (0, a.decidePost)(H, V);
  }
  t.moderatePost = K;
  function O(H, V) {
    return (0, i.decideNotification)(H, V);
  }
  t.moderateNotification = O;
  function z(H, V) {
    return (0, c.decideFeedGenerator)(H, V);
  }
  t.moderateFeedGenerator = z;
  function X(H, V) {
    return (0, h.decideUserList)(H, V);
  }
  t.moderateUserList = X;
})(id);
var Hu = {};
Object.defineProperty(Hu, "__esModule", { value: !0 });
Hu.mock = void 0;
const ea = "bafyreiclp443lavogvhj3d2ob2cxbfuscni2k5jk7bebjzg7khl3esabwq";
Hu.mock = {
  post({ text: t, facets: e, reply: r, embed: i }) {
    return {
      $type: "app.bsky.feed.post",
      text: t,
      facets: e,
      reply: r,
      embed: i,
      langs: ["en"],
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  postView({ record: t, author: e, embed: r, replyCount: i, repostCount: a, likeCount: c, viewer: h, labels: m }) {
    return {
      $type: "app.bsky.feed.defs#postView",
      uri: `at://${e.did}/app.bsky.feed.post/fake`,
      cid: ea,
      author: e,
      record: t,
      embed: r,
      replyCount: i,
      repostCount: a,
      likeCount: c,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      viewer: h,
      labels: m
    };
  },
  embedRecordView({ record: t, author: e, labels: r }) {
    return {
      $type: "app.bsky.embed.record#view",
      record: {
        $type: "app.bsky.embed.record#viewRecord",
        uri: `at://${e.did}/app.bsky.feed.post/fake`,
        cid: ea,
        author: e,
        value: t,
        labels: r,
        indexedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  },
  profileViewBasic({ handle: t, displayName: e, description: r, viewer: i, labels: a }) {
    return {
      did: `did:web:${t}`,
      handle: t,
      displayName: e,
      description: r,
      // technically not in ProfileViewBasic but useful in some cases
      viewer: i,
      labels: a
    };
  },
  actorViewerState({ muted: t, mutedByList: e, blockedBy: r, blocking: i, blockingByList: a, following: c, followedBy: h }) {
    return {
      muted: t,
      mutedByList: e,
      blockedBy: r,
      blocking: i,
      blockingByList: a,
      following: c,
      followedBy: h
    };
  },
  listViewBasic({ name: t }) {
    return {
      uri: "at://did:plc:fake/app.bsky.graph.list/fake",
      cid: ea,
      name: t,
      purpose: "app.bsky.graph.defs#modlist",
      indexedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  replyNotification({ author: t, record: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.feed.post/fake`,
      cid: ea,
      author: t,
      reason: "reply",
      reasonSubject: `at://${t.did}/app.bsky.feed.post/fake-parent`,
      record: e,
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  followNotification({ author: t, subjectDid: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.graph.follow/fake`,
      cid: ea,
      author: t,
      reason: "follow",
      record: {
        $type: "app.bsky.graph.follow",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        subject: e
      },
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  label({ val: t, uri: e, src: r }) {
    return {
      src: r || "did:plc:fake-labeler",
      uri: e,
      val: t,
      cts: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};
var Zu = {}, ad = {}, ei = ne && ne.__classPrivateFieldGet || function(t, e, r, i) {
  if (r === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? i : r === "a" ? i.call(t) : i ? i.value : e.get(t);
}, yc = ne && ne.__classPrivateFieldSet || function(t, e, r, i, a) {
  if (i === "m") throw new TypeError("Private method is not writable");
  if (i === "a" && !a) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? a.call(t, r) : a ? a.value = r : e.set(t, r), r;
}, Di, an;
Object.defineProperty(ad, "__esModule", { value: !0 });
class sK {
  constructor() {
    Di.set(this, !1), an.set(this, /* @__PURE__ */ new Set());
  }
  /**
   * Whether the lock is currently acquired or not. Accessing this property does not affect the
   * status of the lock.
   */
  get acquired() {
    return ei(this, Di, "f");
  }
  /**
   * Acquires the lock, waiting if necessary for it to become free if it is already locked. The
   * returned promise is fulfilled once the lock is acquired.
   *
   * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before
   * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid
   * timeout values depends on how `setTimeout` handles those values.
   *
   * After acquiring the lock, you **must** call `release` when you are done with it.
   */
  acquireAsync({ timeout: e } = {}) {
    if (!ei(this, Di, "f"))
      return yc(this, Di, !0, "f"), Promise.resolve();
    if (e == null)
      return new Promise((a) => {
        ei(this, an, "f").add(a);
      });
    let r, i;
    return Promise.race([
      new Promise((a) => {
        r = () => {
          clearTimeout(i), a();
        }, ei(this, an, "f").add(r);
      }),
      new Promise((a, c) => {
        i = setTimeout(() => {
          ei(this, an, "f").delete(r), c(new Error("Timed out waiting for lock"));
        }, e);
      })
    ]);
  }
  /**
   * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns
   * `true` if the lock was free and is now acquired, and `false` otherwise.
   *
   * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs
   * synchronously without waiting for the JavaScript task queue.
   */
  tryAcquire() {
    return ei(this, Di, "f") ? !1 : (yc(this, Di, !0, "f"), !0);
  }
  /**
   * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer
   * must release the lock exactly once.
   */
  release() {
    if (!ei(this, Di, "f"))
      throw new Error("Cannot release an unacquired lock");
    if (ei(this, an, "f").size > 0) {
      const [e] = ei(this, an, "f");
      ei(this, an, "f").delete(e), e();
    } else
      yc(this, Di, !1, "f");
  }
}
ad.default = sK;
Di = /* @__PURE__ */ new WeakMap(), an = /* @__PURE__ */ new WeakMap();
var aK = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Zu, "__esModule", { value: !0 });
Zu.BskyAgent = void 0;
const ms = as, on = vi, oK = aK(ad), lK = Vs, le = x, uK = En, ln = Nr, cK = id, Cf = {
  hideReplies: !1,
  hideRepliesByUnfollowed: !0,
  hideRepliesByLikeCount: 0,
  hideReposts: !1,
  hideQuotePosts: !1
}, dK = {
  sort: "oldest",
  prioritizeFollowedUsers: !0
};
class gs extends lK.AtpAgent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_prefsLock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new oK.default()
    }), Object.defineProperty(this, "getTimeline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getTimeline(e, r)
    }), Object.defineProperty(this, "getAuthorFeed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getAuthorFeed(e, r)
    }), Object.defineProperty(this, "getActorLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getActorLikes(e, r)
    }), Object.defineProperty(this, "getPostThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPostThread(e, r)
    }), Object.defineProperty(this, "getPost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e) => this.api.app.bsky.feed.post.get(e)
    }), Object.defineProperty(this, "getPosts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPosts(e, r)
    }), Object.defineProperty(this, "getLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getLikes(e, r)
    }), Object.defineProperty(this, "getRepostedBy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getRepostedBy(e, r)
    }), Object.defineProperty(this, "getFollows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollows(e, r)
    }), Object.defineProperty(this, "getFollowers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollowers(e, r)
    }), Object.defineProperty(this, "getProfile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfile(e, r)
    }), Object.defineProperty(this, "getProfiles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfiles(e, r)
    }), Object.defineProperty(this, "getSuggestions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getSuggestions(e, r)
    }), Object.defineProperty(this, "searchActors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActors(e, r)
    }), Object.defineProperty(this, "searchActorsTypeahead", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActorsTypeahead(e, r)
    }), Object.defineProperty(this, "listNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.listNotifications(e, r)
    }), Object.defineProperty(this, "countUnreadNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.getUnreadCount(e, r)
    }), Object.defineProperty(this, "getLabelers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.labeler.getServices(e, r)
    });
  }
  clone() {
    const e = new gs({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  get app() {
    return this.api.app;
  }
  async getLabelDefinitions(e) {
    let r = gs.appLabelers;
    hK(e) ? r = r.concat(e.moderationPrefs.labelers.map((c) => c.did)) : Xm(e) ? r = r.concat(e.labelers.map((c) => c.did)) : r = r.concat(e);
    const i = await this.getLabelers({
      dids: r,
      detailed: !0
    }), a = {};
    if (i.data)
      for (const c of i.data.views)
        a[c.creator.did] = (0, cK.interpretLabelValueDefinitions)(c);
    return a;
  }
  async post(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return e.createdAt = e.createdAt || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.feed.post.create({ repo: this.session.did }, e);
  }
  async deletePost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new ms.AtUri(e);
    return await this.api.app.bsky.feed.post.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async like(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteLike(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new ms.AtUri(e);
    return await this.api.app.bsky.feed.like.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async repost(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteRepost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new ms.AtUri(e);
    return await this.api.app.bsky.feed.repost.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async follow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteFollow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new ms.AtUri(e);
    return await this.api.app.bsky.graph.follow.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async upsertProfile(e) {
    if (!this.session)
      throw new Error("Not logged in");
    let r = 5;
    for (; r >= 0; ) {
      const i = await this.com.atproto.repo.getRecord({
        repo: this.session.did,
        collection: "app.bsky.actor.profile",
        rkey: "self"
      }).catch((h) => {
      }), a = await e(i?.data.value);
      a && (a.$type = "app.bsky.actor.profile");
      const c = le.AppBskyActorProfile.validateRecord(a);
      if (!c.success)
        throw c.error;
      try {
        await this.com.atproto.repo.putRecord({
          repo: this.session.did,
          collection: "app.bsky.actor.profile",
          rkey: "self",
          record: a,
          swapRecord: i?.data.cid || null
        });
      } catch (h) {
        if (r > 0 && h instanceof le.ComAtprotoRepoPutRecord.InvalidSwapError) {
          r--;
          continue;
        } else
          throw h;
      }
      break;
    }
  }
  async mute(e) {
    return this.api.app.bsky.graph.muteActor({ actor: e });
  }
  async unmute(e) {
    return this.api.app.bsky.graph.unmuteActor({ actor: e });
  }
  async muteModList(e) {
    return this.api.app.bsky.graph.muteActorList({
      list: e
    });
  }
  async unmuteModList(e) {
    return this.api.app.bsky.graph.unmuteActorList({
      list: e
    });
  }
  async blockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async unblockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = await this.api.app.bsky.graph.getList({
      list: e,
      limit: 1
    });
    if (!r.data.list.viewer?.blocked)
      return;
    const { rkey: i } = new ms.AtUri(r.data.list.viewer.blocked);
    return await this.api.app.bsky.graph.listblock.delete({
      repo: this.session.did,
      rkey: i
    });
  }
  async updateSeenNotifications(e) {
    return e = e || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.notification.updateSeen({
      seenAt: e
    });
  }
  async getPreferences() {
    const e = {
      feeds: {
        saved: void 0,
        pinned: void 0
      },
      // @ts-ignore populating below
      savedFeeds: void 0,
      feedViewPrefs: {
        home: {
          ...Cf
        }
      },
      threadViewPrefs: { ...dK },
      moderationPrefs: {
        adultContentEnabled: !1,
        labels: { ...uK.DEFAULT_LABEL_SETTINGS },
        labelers: gs.appLabelers.map((a) => ({ did: a, labels: {} })),
        mutedWords: [],
        hiddenPosts: []
      },
      birthDate: void 0,
      interests: {
        tags: []
      },
      bskyAppState: {
        queuedNudges: [],
        activeProgressGuide: void 0
      }
    }, r = await this.app.bsky.actor.getPreferences({}), i = [];
    for (const a of r.data.preferences)
      if (le.AppBskyActorDefs.isAdultContentPref(a) && le.AppBskyActorDefs.validateAdultContentPref(a).success)
        e.moderationPrefs.adultContentEnabled = a.enabled;
      else if (le.AppBskyActorDefs.isContentLabelPref(a) && le.AppBskyActorDefs.validateContentLabelPref(a).success) {
        const c = fK(a);
        i.push(c);
      } else if (le.AppBskyActorDefs.isLabelersPref(a) && le.AppBskyActorDefs.validateLabelersPref(a).success)
        e.moderationPrefs.labelers = gs.appLabelers.map((c) => ({ did: c, labels: {} })).concat(a.labelers.map((c) => ({
          ...c,
          labels: {}
        })));
      else if (le.AppBskyActorDefs.isSavedFeedsPrefV2(a) && le.AppBskyActorDefs.validateSavedFeedsPrefV2(a).success)
        e.savedFeeds = a.items;
      else if (le.AppBskyActorDefs.isSavedFeedsPref(a) && le.AppBskyActorDefs.validateSavedFeedsPref(a).success)
        e.feeds.saved = a.saved, e.feeds.pinned = a.pinned;
      else if (le.AppBskyActorDefs.isPersonalDetailsPref(a) && le.AppBskyActorDefs.validatePersonalDetailsPref(a).success)
        a.birthDate && (e.birthDate = new Date(a.birthDate));
      else if (le.AppBskyActorDefs.isFeedViewPref(a) && le.AppBskyActorDefs.validateFeedViewPref(a).success) {
        const { $type: c, feed: h, ...m } = a;
        e.feedViewPrefs[a.feed] = { ...Cf, ...m };
      } else if (le.AppBskyActorDefs.isThreadViewPref(a) && le.AppBskyActorDefs.validateThreadViewPref(a).success) {
        const { $type: c, ...h } = a;
        e.threadViewPrefs = { ...e.threadViewPrefs, ...h };
      } else if (le.AppBskyActorDefs.isInterestsPref(a) && le.AppBskyActorDefs.validateInterestsPref(a).success) {
        const { $type: c, ...h } = a;
        e.interests = { ...e.interests, ...h };
      } else if (le.AppBskyActorDefs.isMutedWordsPref(a) && le.AppBskyActorDefs.validateMutedWordsPref(a).success) {
        const { $type: c, ...h } = a;
        e.moderationPrefs.mutedWords = h.items, e.moderationPrefs.mutedWords.length && (e.moderationPrefs.mutedWords = e.moderationPrefs.mutedWords.map((m) => (m.actorTarget = m.actorTarget || "all", m)));
      } else if (le.AppBskyActorDefs.isHiddenPostsPref(a) && le.AppBskyActorDefs.validateHiddenPostsPref(a).success) {
        const { $type: c, ...h } = a;
        e.moderationPrefs.hiddenPosts = h.items;
      } else if (le.AppBskyActorDefs.isBskyAppStatePref(a) && le.AppBskyActorDefs.validateBskyAppStatePref(a).success) {
        const { $type: c, ...h } = a;
        e.bskyAppState.queuedNudges = h.queuedNudges || [], e.bskyAppState.activeProgressGuide = h.activeProgressGuide;
      }
    if (e.savedFeeds === void 0) {
      const { saved: a, pinned: c } = e.feeds;
      if (a && c) {
        const h = /* @__PURE__ */ new Map();
        h.set("timeline", {
          id: on.TID.nextStr(),
          type: "timeline",
          value: "following",
          pinned: !0
        });
        for (const m of c) {
          const p = (0, ln.getSavedFeedType)(m);
          p !== "unknown" && h.set(m, {
            id: on.TID.nextStr(),
            type: p,
            value: m,
            pinned: !0
          });
        }
        for (const m of a)
          if (!h.has(m)) {
            const p = (0, ln.getSavedFeedType)(m);
            if (p === "unknown")
              continue;
            h.set(m, {
              id: on.TID.nextStr(),
              type: p,
              value: m,
              pinned: !1
            });
          }
        e.savedFeeds = Array.from(h.values());
      } else
        e.savedFeeds = [
          {
            id: on.TID.nextStr(),
            type: "timeline",
            value: "following",
            pinned: !0
          }
        ];
      await this.overwriteSavedFeeds(e.savedFeeds);
    }
    for (const a of i)
      if (a.labelerDid) {
        const c = e.moderationPrefs.labelers.find((h) => h.did === a.labelerDid);
        if (!c)
          continue;
        c.labels[a.label] = a.visibility;
      } else
        e.moderationPrefs.labels[a.label] = a.visibility;
    return e.moderationPrefs.labels = pK(e.moderationPrefs.labels), this.configureLabelersHeader(bc(r.data.preferences)), e;
  }
  async overwriteSavedFeeds(e) {
    e.forEach(ln.validateSavedFeed);
    const r = /* @__PURE__ */ new Map();
    return e.forEach((i) => {
      r.has(i.id) && r.delete(i.id), r.set(i.id, i);
    }), su(this, () => Array.from(r.values()));
  }
  async updateSavedFeeds(e) {
    return e.map(ln.validateSavedFeed), su(this, (r) => r.map((i) => {
      const a = e.find((c) => i.id === c.id);
      return a ? {
        ...i,
        // only update pinned
        pinned: a.pinned
      } : i;
    }));
  }
  async addSavedFeeds(e) {
    const r = e.map((i) => ({
      ...i,
      id: on.TID.nextStr()
    }));
    return r.forEach(ln.validateSavedFeed), su(this, (i) => [
      ...i,
      ...r
    ]);
  }
  async removeSavedFeeds(e) {
    return su(this, (r) => [
      ...r.filter((i) => !e.find((a) => i.id === a))
    ]);
  }
  /**
   * @deprecated use `overwriteSavedFeeds`
   */
  async setSavedFeeds(e, r) {
    return ta(this, () => ({
      saved: e,
      pinned: r
    }));
  }
  /**
   * @deprecated use `addSavedFeeds`
   */
  async addSavedFeed(e) {
    return ta(this, (r, i) => ({
      saved: [...r.filter((a) => a !== e), e],
      pinned: i
    }));
  }
  /**
   * @deprecated use `removeSavedFeeds`
   */
  async removeSavedFeed(e) {
    return ta(this, (r, i) => ({
      saved: r.filter((a) => a !== e),
      pinned: i.filter((a) => a !== e)
    }));
  }
  /**
   * @deprecated use `addSavedFeeds` or `updateSavedFeeds`
   */
  async addPinnedFeed(e) {
    return ta(this, (r, i) => ({
      saved: [...r.filter((a) => a !== e), e],
      pinned: [...i.filter((a) => a !== e), e]
    }));
  }
  /**
   * @deprecated use `updateSavedFeeds` or `removeSavedFeeds`
   */
  async removePinnedFeed(e) {
    return ta(this, (r, i) => ({
      saved: r,
      pinned: i.filter((a) => a !== e)
    }));
  }
  async setAdultContentEnabled(e) {
    await $t(this, (r) => {
      let i = r.findLast((a) => le.AppBskyActorDefs.isAdultContentPref(a) && le.AppBskyActorDefs.validateAdultContentPref(a).success);
      return i ? i.enabled = e : i = {
        $type: "app.bsky.actor.defs#adultContentPref",
        enabled: e
      }, r.filter((a) => !le.AppBskyActorDefs.isAdultContentPref(a)).concat([i]);
    });
  }
  async setContentLabelPref(e, r, i) {
    i && (0, ms.ensureValidDid)(i), await $t(this, (a) => {
      let c = a.findLast((m) => le.AppBskyActorDefs.isContentLabelPref(m) && le.AppBskyActorDefs.validateContentLabelPref(m).success && m.label === e && m.labelerDid === i), h;
      if (c ? c.visibility = r : c = {
        $type: "app.bsky.actor.defs#contentLabelPref",
        label: e,
        labelerDid: i,
        visibility: r
      }, le.AppBskyActorDefs.isContentLabelPref(c) && !c.labelerDid) {
        const m = {
          "graphic-media": "gore",
          porn: "nsfw",
          sexual: "suggestive"
        }[c.label];
        m && (h = a.findLast((p) => le.AppBskyActorDefs.isContentLabelPref(p) && le.AppBskyActorDefs.validateContentLabelPref(p).success && p.label === m && p.labelerDid === void 0), h ? h.visibility = r : h = {
          $type: "app.bsky.actor.defs#contentLabelPref",
          label: m,
          labelerDid: void 0,
          visibility: r
        });
      }
      return a.filter((m) => !le.AppBskyActorDefs.isContentLabelPref(m) || !(m.label === e && m.labelerDid === i)).concat([c]).filter((m) => h ? !le.AppBskyActorDefs.isContentLabelPref(m) || !(m.label === h.label && m.labelerDid === void 0) : !0).concat(h ? [h] : []);
    });
  }
  async addLabeler(e) {
    const r = await $t(this, (i) => {
      let a = i.findLast((c) => le.AppBskyActorDefs.isLabelersPref(c) && le.AppBskyActorDefs.validateLabelersPref(c).success);
      if (a || (a = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), le.AppBskyActorDefs.isLabelersPref(a)) {
        let c = a.labelers.find((h) => h.did === e);
        c || (c = {
          did: e
        }, a.labelers.push(c));
      }
      return i.filter((c) => !le.AppBskyActorDefs.isLabelersPref(c)).concat([a]);
    });
    this.configureLabelersHeader(bc(r));
  }
  async removeLabeler(e) {
    const r = await $t(this, (i) => {
      let a = i.findLast((c) => le.AppBskyActorDefs.isLabelersPref(c) && le.AppBskyActorDefs.validateLabelersPref(c).success);
      return a || (a = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), le.AppBskyActorDefs.isLabelersPref(a) && (a.labelers = a.labelers.filter((c) => c.did !== e)), i.filter((c) => !le.AppBskyActorDefs.isLabelersPref(c)).concat([a]);
    });
    this.configureLabelersHeader(bc(r));
  }
  async setPersonalDetails({ birthDate: e }) {
    e = e instanceof Date ? e.toISOString() : e, await $t(this, (r) => {
      let i = r.findLast((a) => le.AppBskyActorDefs.isPersonalDetailsPref(a) && le.AppBskyActorDefs.validatePersonalDetailsPref(a).success);
      return i ? i.birthDate = e : i = {
        $type: "app.bsky.actor.defs#personalDetailsPref",
        birthDate: e
      }, r.filter((a) => !le.AppBskyActorDefs.isPersonalDetailsPref(a)).concat([i]);
    });
  }
  async setFeedViewPrefs(e, r) {
    await $t(this, (i) => {
      const a = i.findLast((c) => le.AppBskyActorDefs.isFeedViewPref(c) && le.AppBskyActorDefs.validateFeedViewPref(c).success && c.feed === e);
      return a && (r = { ...a, ...r }), i.filter((c) => !le.AppBskyActorDefs.isFeedViewPref(r) || c.feed !== e).concat([{ ...r, $type: "app.bsky.actor.defs#feedViewPref", feed: e }]);
    });
  }
  async setThreadViewPrefs(e) {
    await $t(this, (r) => {
      const i = r.findLast((a) => le.AppBskyActorDefs.isThreadViewPref(a) && le.AppBskyActorDefs.validateThreadViewPref(a).success);
      return i && (e = { ...i, ...e }), r.filter((a) => !le.AppBskyActorDefs.isThreadViewPref(a)).concat([{ ...e, $type: "app.bsky.actor.defs#threadViewPref" }]);
    });
  }
  async setInterestsPref(e) {
    await $t(this, (r) => {
      const i = r.findLast((a) => le.AppBskyActorDefs.isInterestsPref(a) && le.AppBskyActorDefs.validateInterestsPref(a).success);
      return i && (e = { ...i, ...e }), r.filter((a) => !le.AppBskyActorDefs.isInterestsPref(a)).concat([{ ...e, $type: "app.bsky.actor.defs#interestsPref" }]);
    });
  }
  /**
   * Add a muted word to user preferences.
   */
  async addMutedWord(e) {
    const r = (0, ln.sanitizeMutedWordValue)(e.value);
    r && await $t(this, (i) => {
      let a = i.findLast((h) => le.AppBskyActorDefs.isMutedWordsPref(h) && le.AppBskyActorDefs.validateMutedWordsPref(h).success);
      const c = {
        id: on.TID.nextStr(),
        value: r,
        targets: e.targets || [],
        actorTarget: e.actorTarget || "all",
        expiresAt: e.expiresAt || void 0
      };
      return a && le.AppBskyActorDefs.isMutedWordsPref(a) ? (a.items.push(c), a.items = gc(a.items)) : a = {
        items: [c]
      }, i.filter((h) => !le.AppBskyActorDefs.isMutedWordsPref(h)).concat([
        { ...a, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ]);
    });
  }
  /**
   * Convenience method to add muted words to user preferences
   */
  async addMutedWords(e) {
    await Promise.all(e.map((r) => this.addMutedWord(r)));
  }
  /**
   * @deprecated use `addMutedWords` or `addMutedWord` instead
   */
  async upsertMutedWords(e) {
    await this.addMutedWords(e);
  }
  /**
   * Update a muted word in user preferences.
   */
  async updateMutedWord(e) {
    await $t(this, (r) => {
      const i = r.findLast((a) => le.AppBskyActorDefs.isMutedWordsPref(a) && le.AppBskyActorDefs.validateMutedWordsPref(a).success);
      return i && le.AppBskyActorDefs.isMutedWordsPref(i) ? (i.items = i.items.map((a) => {
        if (Lf(a, e)) {
          const h = {
            ...a,
            ...e
          };
          return {
            id: a.id || on.TID.nextStr(),
            value: (0, ln.sanitizeMutedWordValue)(h.value) || a.value,
            targets: h.targets || [],
            actorTarget: h.actorTarget || "all",
            expiresAt: h.expiresAt || void 0
          };
        } else
          return a;
      }), i.items = gc(i.items), r.filter((a) => !le.AppBskyActorDefs.isMutedWordsPref(a)).concat([
        { ...i, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ])) : r;
    });
  }
  /**
   * Remove a muted word from user preferences.
   */
  async removeMutedWord(e) {
    await $t(this, (r) => {
      const i = r.findLast((a) => le.AppBskyActorDefs.isMutedWordsPref(a) && le.AppBskyActorDefs.validateMutedWordsPref(a).success);
      if (i && le.AppBskyActorDefs.isMutedWordsPref(i)) {
        for (let a = 0; a < i.items.length; a++)
          if (Lf(i.items[a], e)) {
            i.items.splice(a, 1);
            break;
          }
        return i.items = gc(i.items), r.filter((a) => !le.AppBskyActorDefs.isMutedWordsPref(a)).concat([
          { ...i, $type: "app.bsky.actor.defs#mutedWordsPref" }
        ]);
      }
      return r;
    });
  }
  /**
   * Convenience method to remove muted words from user preferences
   */
  async removeMutedWords(e) {
    await Promise.all(e.map((r) => this.removeMutedWord(r)));
  }
  async hidePost(e) {
    await Sf(this, e, "hide");
  }
  async unhidePost(e) {
    await Sf(this, e, "unhide");
  }
  async bskyAppQueueNudges(e) {
    await $t(this, (r) => {
      let i = r.findLast((a) => le.AppBskyActorDefs.isBskyAppStatePref(a) && le.AppBskyActorDefs.validateBskyAppStatePref(a).success);
      return i = i || {}, e = Array.isArray(e) ? e : [e], i.queuedNudges = (i.queuedNudges || []).concat(e), r.filter((a) => !le.AppBskyActorDefs.isBskyAppStatePref(a)).concat([
        {
          ...i,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
  async bskyAppDismissNudges(e) {
    await $t(this, (r) => {
      let i = r.findLast((a) => le.AppBskyActorDefs.isBskyAppStatePref(a) && le.AppBskyActorDefs.validateBskyAppStatePref(a).success);
      return i = i || {}, e = Array.isArray(e) ? e : [e], i.queuedNudges = (i.queuedNudges || []).filter((a) => !e.includes(a)), r.filter((a) => !le.AppBskyActorDefs.isBskyAppStatePref(a)).concat([
        {
          ...i,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
  async bskyAppSetActiveProgressGuide(e) {
    if (e && !le.AppBskyActorDefs.validateBskyAppProgressGuide(e).success)
      throw new Error("Invalid progress guide");
    await $t(this, (r) => {
      let i = r.findLast((a) => le.AppBskyActorDefs.isBskyAppStatePref(a) && le.AppBskyActorDefs.validateBskyAppStatePref(a).success);
      return i = i || {}, i.activeProgressGuide = e, r.filter((a) => !le.AppBskyActorDefs.isBskyAppStatePref(a)).concat([
        {
          ...i,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
}
Zu.BskyAgent = gs;
async function $t(t, e) {
  try {
    await t._prefsLock.acquireAsync();
    const r = await t.app.bsky.actor.getPreferences({}), i = e(r.data.preferences);
    return i === !1 ? r.data.preferences : (await t.app.bsky.actor.putPreferences({
      preferences: i
    }), i);
  } finally {
    t._prefsLock.release();
  }
}
async function ta(t, e) {
  let r;
  return await $t(t, (i) => {
    let a = i.findLast((c) => le.AppBskyActorDefs.isSavedFeedsPref(c) && le.AppBskyActorDefs.validateSavedFeedsPref(c).success);
    return a ? (r = e(a.saved, a.pinned), a.saved = r.saved, a.pinned = r.pinned) : (r = e([], []), a = {
      $type: "app.bsky.actor.defs#savedFeedsPref",
      saved: r.saved,
      pinned: r.pinned
    }), i.filter((c) => !le.AppBskyActorDefs.isSavedFeedsPref(c)).concat([a]);
  }), r;
}
async function su(t, e) {
  let r = [];
  return await $t(t, (i) => {
    let a = i.findLast((y) => le.AppBskyActorDefs.isSavedFeedsPrefV2(y) && le.AppBskyActorDefs.validateSavedFeedsPrefV2(y).success), c = i.findLast((y) => le.AppBskyActorDefs.isSavedFeedsPref(y) && le.AppBskyActorDefs.validateSavedFeedsPref(y).success);
    a ? (r = e(a.items), a = {
      ...a,
      items: r
    }) : (r = e([]), a = {
      $type: "app.bsky.actor.defs#savedFeedsPrefV2",
      items: r
    });
    const h = a.items.filter((y) => y.pinned), m = a.items.filter((y) => !y.pinned);
    a.items = h.concat(m);
    let p = i.filter((y) => !le.AppBskyActorDefs.isSavedFeedsPrefV2(y)).concat(a);
    if (c) {
      const { saved: y, pinned: d } = c, A = (0, ln.savedFeedsToUriArrays)(
        // v1 only supports feeds and lists
        a.items.filter((B) => ["feed", "list"].includes(B.type))
      );
      c = {
        ...c,
        saved: Array.from(/* @__PURE__ */ new Set([...y, ...A.saved])),
        pinned: Array.from(/* @__PURE__ */ new Set([...d, ...A.pinned]))
      }, p = p.filter((B) => !le.AppBskyActorDefs.isSavedFeedsPref(B)).concat(c);
    }
    return p;
  }), r;
}
function fK(t) {
  let e = t.visibility;
  return e === "show" && (e = "ignore"), { ...t, visibility: e };
}
function pK(t) {
  const e = { ...t }, r = {
    gore: "graphic-media",
    nsfw: "porn",
    suggestive: "sexual"
  };
  for (const i in e) {
    const a = r[i];
    a && (e[a] = e[i]);
  }
  return e;
}
function bc(t) {
  const e = t.findLast((i) => le.AppBskyActorDefs.isLabelersPref(i) && le.AppBskyActorDefs.validateLabelersPref(i).success);
  let r = [];
  return e && (r = e.labelers.map((i) => i.did)), r;
}
async function Sf(t, e, r) {
  await $t(t, (i) => {
    let a = i.findLast((c) => le.AppBskyActorDefs.isHiddenPostsPref(c) && le.AppBskyActorDefs.validateHiddenPostsPref(c).success);
    return a && le.AppBskyActorDefs.isHiddenPostsPref(a) ? a.items = r === "hide" ? Array.from(/* @__PURE__ */ new Set([...a.items, e])) : a.items.filter((c) => c !== e) : r === "hide" && (a = {
      $type: "app.bsky.actor.defs#hiddenPostsPref",
      items: [e]
    }), i.filter((c) => !le.AppBskyActorDefs.isInterestsPref(c)).concat([{ ...a, $type: "app.bsky.actor.defs#hiddenPostsPref" }]);
  });
}
function hK(t) {
  return t && typeof t == "object" && "moderationPrefs" in t && Xm(t.moderationPrefs);
}
function Xm(t) {
  return t && typeof t == "object" && "labelers" in t;
}
function gc(t) {
  return t.map((e) => ({
    ...e,
    id: e.id || on.TID.nextStr()
  }));
}
function Lf(t, e) {
  const r = t.id, i = r && r === e.id, a = !r && t.value === e.value;
  return i || a;
}
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(y, d, A, B) {
    B === void 0 && (B = A);
    var K = Object.getOwnPropertyDescriptor(d, A);
    (!K || ("get" in K ? !d.__esModule : K.writable || K.configurable)) && (K = { enumerable: !0, get: function() {
      return d[A];
    } }), Object.defineProperty(y, B, K);
  } : function(y, d, A, B) {
    B === void 0 && (B = A), y[B] = d[A];
  }), r = ne && ne.__exportStar || function(y, d) {
    for (var A in y) A !== "default" && !Object.prototype.hasOwnProperty.call(d, A) && e(d, y, A);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.BskyAgent = t.DEFAULT_LABEL_SETTINGS = t.LABELS = t.parseLanguage = t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.BlobRef = t.AtUri = void 0;
  var i = as;
  Object.defineProperty(t, "AtUri", { enumerable: !0, get: function() {
    return i.AtUri;
  } });
  var a = _a;
  Object.defineProperty(t, "BlobRef", { enumerable: !0, get: function() {
    return a.BlobRef;
  } }), Object.defineProperty(t, "lexToJson", { enumerable: !0, get: function() {
    return a.lexToJson;
  } }), Object.defineProperty(t, "stringifyLex", { enumerable: !0, get: function() {
    return a.stringifyLex;
  } }), Object.defineProperty(t, "jsonToLex", { enumerable: !0, get: function() {
    return a.jsonToLex;
  } }), Object.defineProperty(t, "jsonStringToLex", { enumerable: !0, get: function() {
    return a.jsonStringToLex;
  } });
  var c = vi;
  Object.defineProperty(t, "parseLanguage", { enumerable: !0, get: function() {
    return c.parseLanguage;
  } }), r($p, t), r(ka, t), r(Nr, t), r(x, t), r(Vs, t), r(js, t), r(jl, t), r(Xs, t), r($r, t), r(id, t), r(ur, t), r(Hu, t);
  var h = En;
  Object.defineProperty(t, "LABELS", { enumerable: !0, get: function() {
    return h.LABELS;
  } }), Object.defineProperty(t, "DEFAULT_LABEL_SETTINGS", { enumerable: !0, get: function() {
    return h.DEFAULT_LABEL_SETTINGS;
  } });
  var m = Zu;
  Object.defineProperty(t, "BskyAgent", { enumerable: !0, get: function() {
    return m.BskyAgent;
  } });
  var p = Vs;
  Object.defineProperty(t, "default", { enumerable: !0, get: function() {
    return p.AtpAgent;
  } });
})(Pc);
const xc = new Pc.BskyAgent({
  service: "https://api.bsky.app"
});
var Hm = { exports: {} };
(function(t, e) {
  (function(i, a) {
    t.exports = a();
  })(ne, function() {
    return (
      /******/
      function(r) {
        var i = {};
        function a(c) {
          if (i[c])
            return i[c].exports;
          var h = i[c] = {
            /******/
            i: c,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[c].call(h.exports, h, h.exports, a), h.l = !0, h.exports;
        }
        return a.m = r, a.c = i, a.d = function(c, h, m) {
          a.o(c, h) || Object.defineProperty(c, h, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: m
            /******/
          });
        }, a.n = function(c) {
          var h = c && c.__esModule ? (
            /******/
            function() {
              return c.default;
            }
          ) : (
            /******/
            function() {
              return c;
            }
          );
          return a.d(h, "a", h), h;
        }, a.o = function(c, h) {
          return Object.prototype.hasOwnProperty.call(c, h);
        }, a.p = "/dist/", a(a.s = 8);
      }([
        /* 0 */
        /***/
        function(r, i, a) {
          a.d(i, "a", function() {
            return B;
          }), a.d(i, "b", function() {
            return K;
          });
          var c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(O) {
            return typeof O;
          } : function(O) {
            return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
          };
          function h() {
          }
          var m = {
            trace: h,
            debug: h,
            log: h,
            warn: h,
            info: h,
            error: h
          }, p = m;
          function y(O, z) {
            return z = "[" + O + "] > " + z, z;
          }
          function d(O) {
            var z = self.console[O];
            return z ? function() {
              for (var X = arguments.length, H = Array(X), V = 0; V < X; V++)
                H[V] = arguments[V];
              H[0] && (H[0] = y(O, H[0])), z.apply(self.console, H);
            } : h;
          }
          function A(O) {
            for (var z = arguments.length, X = Array(z > 1 ? z - 1 : 0), H = 1; H < z; H++)
              X[H - 1] = arguments[H];
            X.forEach(function(V) {
              p[V] = O[V] ? O[V].bind(O) : d(V);
            });
          }
          var B = function(z) {
            if (z === !0 || (typeof z > "u" ? "undefined" : c(z)) === "object") {
              A(
                z,
                // Remove out from list here to hard-disable a log-level
                //'trace',
                "debug",
                "log",
                "info",
                "warn",
                "error"
              );
              try {
                p.log();
              } catch {
                p = m;
              }
            } else
              p = m;
          }, K = p;
        },
        /* 1 */
        /***/
        function(r, i, a) {
          i.a = {
            // fired before MediaSource is attaching to media element - data: { media }
            MEDIA_ATTACHING: "hlsMediaAttaching",
            // fired when MediaSource has been succesfully attached to media element - data: { }
            MEDIA_ATTACHED: "hlsMediaAttached",
            // fired before detaching MediaSource from media element - data: { }
            MEDIA_DETACHING: "hlsMediaDetaching",
            // fired when MediaSource has been detached from media element - data: { }
            MEDIA_DETACHED: "hlsMediaDetached",
            // fired when we buffer is going to be reset - data: { }
            BUFFER_RESET: "hlsBufferReset",
            // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
            BUFFER_CODECS: "hlsBufferCodecs",
            // fired when sourcebuffers have been created - data: { tracks : tracks }
            BUFFER_CREATED: "hlsBufferCreated",
            // fired when we append a segment to the buffer - data: { segment: segment object }
            BUFFER_APPENDING: "hlsBufferAppending",
            // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
            BUFFER_APPENDED: "hlsBufferAppended",
            // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
            BUFFER_EOS: "hlsBufferEos",
            // fired when the media buffer should be flushed - data { startOffset, endOffset }
            BUFFER_FLUSHING: "hlsBufferFlushing",
            // fired when the media buffer has been flushed - data: { }
            BUFFER_FLUSHED: "hlsBufferFlushed",
            // fired to signal that a manifest loading starts - data: { url : manifestURL}
            MANIFEST_LOADING: "hlsManifestLoading",
            // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
            MANIFEST_LOADED: "hlsManifestLoaded",
            // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
            MANIFEST_PARSED: "hlsManifestParsed",
            // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
            LEVEL_SWITCH: "hlsLevelSwitch",
            // fired when a level switch is requested - data: { level : id of new level }
            LEVEL_SWITCHING: "hlsLevelSwitching",
            // fired when a level switch is effective - data: { level : id of new level }
            LEVEL_SWITCHED: "hlsLevelSwitched",
            // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
            LEVEL_LOADING: "hlsLevelLoading",
            // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
            LEVEL_LOADED: "hlsLevelLoaded",
            // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
            LEVEL_UPDATED: "hlsLevelUpdated",
            // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
            LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
            // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
            AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
            // fired when an audio track switch occurs - data: { id : audio track id } // deprecated in favor AUDIO_TRACK_SWITCHING
            AUDIO_TRACK_SWITCH: "hlsAudioTrackSwitch",
            // fired when an audio track switching is requested - data: { id : audio track id }
            AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching",
            // fired when an audio track switch actually occurs - data: { id : audio track id }
            AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched",
            // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
            AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
            // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
            AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
            // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
            SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated",
            // fired when an subtitle track switch occurs - data: { id : subtitle track id }
            SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch",
            // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
            SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading",
            // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
            SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded",
            // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
            SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed",
            // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
            INIT_PTS_FOUND: "hlsInitPtsFound",
            // fired when a fragment loading starts - data: { frag : fragment object }
            FRAG_LOADING: "hlsFragLoading",
            // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
            FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
            // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
            FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
            // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
            FRAG_LOADED: "hlsFragLoaded",
            // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
            FRAG_DECRYPTED: "hlsFragDecrypted",
            // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
            FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
            // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
            FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
            // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
            FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
            // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
            FRAG_PARSING_DATA: "hlsFragParsingData",
            // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
            FRAG_PARSED: "hlsFragParsed",
            // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
            FRAG_BUFFERED: "hlsFragBuffered",
            // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
            FRAG_CHANGED: "hlsFragChanged",
            // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
            FPS_DROP: "hlsFpsDrop",
            //triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
            FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
            // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
            ERROR: "hlsError",
            // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
            DESTROYING: "hlsDestroying",
            // fired when a decrypt key loading starts - data: { frag : fragment object }
            KEY_LOADING: "hlsKeyLoading",
            // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
            KEY_LOADED: "hlsKeyLoaded",
            // fired upon stream controller state transitions - data: { previousState, nextState }
            STREAM_STATE_TRANSITION: "hlsStreamStateTransition"
          };
        },
        /* 2 */
        /***/
        function(r, i, a) {
          a.d(i, "b", function() {
            return c;
          }), a.d(i, "a", function() {
            return h;
          });
          var c = {
            // Identifier for a network error (loading error / timeout ...)
            NETWORK_ERROR: "networkError",
            // Identifier for a media Error (video/parsing/mediasource error)
            MEDIA_ERROR: "mediaError",
            // Identifier for a mux Error (demuxing/remuxing)
            MUX_ERROR: "muxError",
            // Identifier for all other errors
            OTHER_ERROR: "otherError"
          }, h = {
            // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            MANIFEST_LOAD_ERROR: "manifestLoadError",
            // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            MANIFEST_LOAD_TIMEOUT: "manifestLoadTimeOut",
            // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
            MANIFEST_PARSING_ERROR: "manifestParsingError",
            // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
            MANIFEST_INCOMPATIBLE_CODECS_ERROR: "manifestIncompatibleCodecsError",
            // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            LEVEL_LOAD_ERROR: "levelLoadError",
            // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            LEVEL_LOAD_TIMEOUT: "levelLoadTimeOut",
            // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
            LEVEL_SWITCH_ERROR: "levelSwitchError",
            // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            AUDIO_TRACK_LOAD_ERROR: "audioTrackLoadError",
            // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            AUDIO_TRACK_LOAD_TIMEOUT: "audioTrackLoadTimeOut",
            // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
            FRAG_LOAD_ERROR: "fragLoadError",
            // Identifier for fragment loop loading error - data: { frag : fragment object}
            FRAG_LOOP_LOADING_ERROR: "fragLoopLoadingError",
            // Identifier for fragment load timeout error - data: { frag : fragment object}
            FRAG_LOAD_TIMEOUT: "fragLoadTimeOut",
            // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
            FRAG_DECRYPT_ERROR: "fragDecryptError",
            // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
            // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
            FRAG_PARSING_ERROR: "fragParsingError",
            // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
            REMUX_ALLOC_ERROR: "remuxAllocError",
            // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
            KEY_LOAD_ERROR: "keyLoadError",
            // Identifier for decrypt key load timeout error - data: { frag : fragment object}
            KEY_LOAD_TIMEOUT: "keyLoadTimeOut",
            // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
            BUFFER_ADD_CODEC_ERROR: "bufferAddCodecError",
            // Identifier for a buffer append error - data: append error description
            BUFFER_APPEND_ERROR: "bufferAppendError",
            // Identifier for a buffer appending error event - data: appending error description
            BUFFER_APPENDING_ERROR: "bufferAppendingError",
            // Identifier for a buffer stalled error event
            BUFFER_STALLED_ERROR: "bufferStalledError",
            // Identifier for a buffer full event
            BUFFER_FULL_ERROR: "bufferFullError",
            // Identifier for a buffer seek over hole event
            BUFFER_SEEK_OVER_HOLE: "bufferSeekOverHole",
            // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
            BUFFER_NUDGE_ON_STALL: "bufferNudgeOnStall",
            // Identifier for an internal exception happening inside hls.js while handling an event
            INTERNAL_EXCEPTION: "internalException"
          };
        },
        /* 3 */
        /***/
        function(r, i, a) {
          a.d(i, "b", function() {
            return m;
          });
          function c(p, y) {
            if (!(p instanceof y))
              throw new TypeError("Cannot call a class as a function");
          }
          var h = function() {
            function p() {
              c(this, p);
            }
            return p.isHeader = function(d, A) {
              return A + 10 <= d.length && d[A] === 73 && d[A + 1] === 68 && d[A + 2] === 51 && d[A + 3] < 255 && d[A + 4] < 255 && d[A + 6] < 128 && d[A + 7] < 128 && d[A + 8] < 128 && d[A + 9] < 128;
            }, p.isFooter = function(d, A) {
              return A + 10 <= d.length && d[A] === 51 && d[A + 1] === 68 && d[A + 2] === 73 && d[A + 3] < 255 && d[A + 4] < 255 && d[A + 6] < 128 && d[A + 7] < 128 && d[A + 8] < 128 && d[A + 9] < 128;
            }, p.getID3Data = function(d, A) {
              for (var B = A, K = 0; p.isHeader(d, A); ) {
                K += 10;
                var O = p._readSize(d, A + 6);
                K += O, p.isFooter(d, A + 10) && (K += 10), A += K;
              }
              if (K > 0)
                return d.subarray(B, B + K);
            }, p._readSize = function(d, A) {
              var B = 0;
              return B = (d[A] & 127) << 21, B |= (d[A + 1] & 127) << 14, B |= (d[A + 2] & 127) << 7, B |= d[A + 3] & 127, B;
            }, p.getTimeStamp = function(d) {
              for (var A = p.getID3Frames(d), B = 0; B < A.length; B++) {
                var K = A[B];
                if (p.isTimeStampFrame(K))
                  return p._readTimeStamp(K);
              }
            }, p.isTimeStampFrame = function(d) {
              return d && d.key === "PRIV" && d.info === "com.apple.streaming.transportStreamTimestamp";
            }, p._getFrameData = function(d) {
              var A = String.fromCharCode(d[0], d[1], d[2], d[3]), B = p._readSize(d, 4), K = 10;
              return { type: A, size: B, data: d.subarray(K, K + B) };
            }, p.getID3Frames = function(d) {
              for (var A = 0, B = []; p.isHeader(d, A); ) {
                var K = p._readSize(d, A + 6);
                A += 10;
                for (var O = A + K; A + 8 < O; ) {
                  var z = p._getFrameData(d.subarray(A)), X = p._decodeFrame(z);
                  X && B.push(X), A += z.size + 10;
                }
                p.isFooter(d, A) && (A += 10);
              }
              return B;
            }, p._decodeFrame = function(d) {
              if (d.type === "PRIV")
                return p._decodePrivFrame(d);
              if (d.type[0] === "T")
                return p._decodeTextFrame(d);
              if (d.type[0] === "W")
                return p._decodeURLFrame(d);
            }, p._readTimeStamp = function(d) {
              if (d.data.byteLength === 8) {
                var A = new Uint8Array(d.data), B = A[3] & 1, K = (A[4] << 23) + (A[5] << 15) + (A[6] << 7) + A[7];
                return K /= 45, B && (K += 4772185884e-2), Math.round(K);
              }
            }, p._decodePrivFrame = function(d) {
              if (!(d.size < 2)) {
                var A = p._utf8ArrayToStr(d.data, !0), B = new Uint8Array(d.data.subarray(A.length + 1));
                return { key: d.type, info: A, data: B.buffer };
              }
            }, p._decodeTextFrame = function(d) {
              if (!(d.size < 2))
                if (d.type === "TXXX") {
                  var A = 1, B = p._utf8ArrayToStr(d.data.subarray(A));
                  A += B.length + 1;
                  var K = p._utf8ArrayToStr(d.data.subarray(A));
                  return { key: d.type, info: B, data: K };
                } else {
                  var O = p._utf8ArrayToStr(d.data.subarray(1));
                  return { key: d.type, data: O };
                }
            }, p._decodeURLFrame = function(d) {
              if (d.type === "WXXX") {
                if (d.size < 2)
                  return;
                var A = 1, B = p._utf8ArrayToStr(d.data.subarray(A));
                A += B.length + 1;
                var K = p._utf8ArrayToStr(d.data.subarray(A));
                return { key: d.type, info: B, data: K };
              } else {
                var O = p._utf8ArrayToStr(d.data);
                return { key: d.type, data: O };
              }
            }, p._utf8ArrayToStr = function(d) {
              for (var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, B = d.length, K = void 0, O = void 0, z = void 0, X = "", H = 0; H < B; ) {
                if (K = d[H++], K === 0 && A)
                  return X;
                if (K === 0 || K === 3)
                  continue;
                switch (K >> 4) {
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    X += String.fromCharCode(K);
                    break;
                  case 12:
                  case 13:
                    O = d[H++], X += String.fromCharCode((K & 31) << 6 | O & 63);
                    break;
                  case 14:
                    O = d[H++], z = d[H++], X += String.fromCharCode((K & 15) << 12 | (O & 63) << 6 | (z & 63) << 0);
                    break;
                }
              }
              return X;
            }, p;
          }(), m = h._utf8ArrayToStr;
          i.a = h;
        },
        /* 4 */
        /***/
        function(r, i, a) {
          function c(V, G) {
            if (!(V instanceof G))
              throw new TypeError("Cannot call a class as a function");
          }
          var h = function() {
            function V(G, Z) {
              c(this, V), this.subtle = G, this.aesIV = Z;
            }
            return V.prototype.decrypt = function(Z, ae) {
              return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, ae, Z);
            }, V;
          }(), m = h;
          function p(V, G) {
            if (!(V instanceof G))
              throw new TypeError("Cannot call a class as a function");
          }
          var y = function() {
            function V(G, Z) {
              p(this, V), this.subtle = G, this.key = Z;
            }
            return V.prototype.expandKey = function() {
              return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, !1, ["encrypt", "decrypt"]);
            }, V;
          }(), d = y;
          function A(V, G) {
            if (!(V instanceof G))
              throw new TypeError("Cannot call a class as a function");
          }
          var B = function() {
            function V() {
              A(this, V), this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable();
            }
            return V.prototype.uint8ArrayToUint32Array_ = function(Z) {
              for (var ae = new DataView(Z), se = new Uint32Array(4), be = 0; be < 4; be++)
                se[be] = ae.getUint32(be * 4);
              return se;
            }, V.prototype.initTable = function() {
              var Z = this.sBox, ae = this.invSBox, se = this.subMix, be = se[0], me = se[1], Ae = se[2], Be = se[3], Ue = this.invSubMix, lt = Ue[0], xt = Ue[1], ut = Ue[2], qt = Ue[3], tt = new Uint32Array(256), Et = 0, Vt = 0, vt = 0;
              for (vt = 0; vt < 256; vt++)
                vt < 128 ? tt[vt] = vt << 1 : tt[vt] = vt << 1 ^ 283;
              for (vt = 0; vt < 256; vt++) {
                var at = Vt ^ Vt << 1 ^ Vt << 2 ^ Vt << 3 ^ Vt << 4;
                at = at >>> 8 ^ at & 255 ^ 99, Z[Et] = at, ae[at] = Et;
                var kt = tt[Et], Ge = tt[kt], Pr = tt[Ge], ot = tt[at] * 257 ^ at * 16843008;
                be[Et] = ot << 24 | ot >>> 8, me[Et] = ot << 16 | ot >>> 16, Ae[Et] = ot << 8 | ot >>> 24, Be[Et] = ot, ot = Pr * 16843009 ^ Ge * 65537 ^ kt * 257 ^ Et * 16843008, lt[at] = ot << 24 | ot >>> 8, xt[at] = ot << 16 | ot >>> 16, ut[at] = ot << 8 | ot >>> 24, qt[at] = ot, Et ? (Et = kt ^ tt[tt[tt[Pr ^ kt]]], Vt ^= tt[tt[Vt]]) : Et = Vt = 1;
              }
            }, V.prototype.expandKey = function(Z) {
              for (var ae = this.uint8ArrayToUint32Array_(Z), se = !0, be = 0; be < ae.length && se; )
                se = ae[be] === this.key[be], be++;
              if (!se) {
                this.key = ae;
                var me = this.keySize = ae.length;
                if (me !== 4 && me !== 6 && me !== 8)
                  throw new Error("Invalid aes key size=" + me);
                var Ae = this.ksRows = (me + 6 + 1) * 4, Be = void 0, Ue = void 0, lt = this.keySchedule = new Uint32Array(Ae), xt = this.invKeySchedule = new Uint32Array(Ae), ut = this.sBox, qt = this.rcon, tt = this.invSubMix, Et = tt[0], Vt = tt[1], vt = tt[2], at = tt[3], kt = void 0, Ge = void 0;
                for (Be = 0; Be < Ae; Be++) {
                  if (Be < me) {
                    kt = lt[Be] = ae[Be];
                    continue;
                  }
                  Ge = kt, Be % me === 0 ? (Ge = Ge << 8 | Ge >>> 24, Ge = ut[Ge >>> 24] << 24 | ut[Ge >>> 16 & 255] << 16 | ut[Ge >>> 8 & 255] << 8 | ut[Ge & 255], Ge ^= qt[Be / me | 0] << 24) : me > 6 && Be % me === 4 && (Ge = ut[Ge >>> 24] << 24 | ut[Ge >>> 16 & 255] << 16 | ut[Ge >>> 8 & 255] << 8 | ut[Ge & 255]), lt[Be] = kt = (lt[Be - me] ^ Ge) >>> 0;
                }
                for (Ue = 0; Ue < Ae; Ue++)
                  Be = Ae - Ue, Ue & 3 ? Ge = lt[Be] : Ge = lt[Be - 4], Ue < 4 || Be <= 4 ? xt[Ue] = Ge : xt[Ue] = Et[ut[Ge >>> 24]] ^ Vt[ut[Ge >>> 16 & 255]] ^ vt[ut[Ge >>> 8 & 255]] ^ at[ut[Ge & 255]], xt[Ue] = xt[Ue] >>> 0;
              }
            }, V.prototype.networkToHostOrderSwap = function(Z) {
              return Z << 24 | (Z & 65280) << 8 | (Z & 16711680) >> 8 | Z >>> 24;
            }, V.prototype.decrypt = function(Z, ae, se) {
              for (var be = this.keySize + 6, me = this.invKeySchedule, Ae = this.invSBox, Be = this.invSubMix, Ue = Be[0], lt = Be[1], xt = Be[2], ut = Be[3], qt = this.uint8ArrayToUint32Array_(se), tt = qt[0], Et = qt[1], Vt = qt[2], vt = qt[3], at = new Int32Array(Z), kt = new Int32Array(at.length), Ge = void 0, Pr = void 0, ot = void 0, tn = void 0, dr = void 0, fr = void 0, jt = void 0, pr = void 0, hr = void 0, Br = void 0, kr = void 0, ct = void 0, Tt, Cn, rr = this.networkToHostOrderSwap; ae < at.length; ) {
                for (hr = rr(at[ae]), Br = rr(at[ae + 1]), kr = rr(at[ae + 2]), ct = rr(at[ae + 3]), dr = hr ^ me[0], fr = ct ^ me[1], jt = kr ^ me[2], pr = Br ^ me[3], Tt = 4, Cn = 1; Cn < be; Cn++)
                  Ge = Ue[dr >>> 24] ^ lt[fr >> 16 & 255] ^ xt[jt >> 8 & 255] ^ ut[pr & 255] ^ me[Tt], Pr = Ue[fr >>> 24] ^ lt[jt >> 16 & 255] ^ xt[pr >> 8 & 255] ^ ut[dr & 255] ^ me[Tt + 1], ot = Ue[jt >>> 24] ^ lt[pr >> 16 & 255] ^ xt[dr >> 8 & 255] ^ ut[fr & 255] ^ me[Tt + 2], tn = Ue[pr >>> 24] ^ lt[dr >> 16 & 255] ^ xt[fr >> 8 & 255] ^ ut[jt & 255] ^ me[Tt + 3], dr = Ge, fr = Pr, jt = ot, pr = tn, Tt = Tt + 4;
                Ge = Ae[dr >>> 24] << 24 ^ Ae[fr >> 16 & 255] << 16 ^ Ae[jt >> 8 & 255] << 8 ^ Ae[pr & 255] ^ me[Tt], Pr = Ae[fr >>> 24] << 24 ^ Ae[jt >> 16 & 255] << 16 ^ Ae[pr >> 8 & 255] << 8 ^ Ae[dr & 255] ^ me[Tt + 1], ot = Ae[jt >>> 24] << 24 ^ Ae[pr >> 16 & 255] << 16 ^ Ae[dr >> 8 & 255] << 8 ^ Ae[fr & 255] ^ me[Tt + 2], tn = Ae[pr >>> 24] << 24 ^ Ae[dr >> 16 & 255] << 16 ^ Ae[fr >> 8 & 255] << 8 ^ Ae[jt & 255] ^ me[Tt + 3], Tt = Tt + 3, kt[ae] = rr(Ge ^ tt), kt[ae + 1] = rr(tn ^ Et), kt[ae + 2] = rr(ot ^ Vt), kt[ae + 3] = rr(Pr ^ vt), tt = hr, Et = Br, Vt = kr, vt = ct, ae = ae + 4;
              }
              return kt.buffer;
            }, V.prototype.destroy = function() {
              this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0;
            }, V;
          }(), K = B, O = a(2), z = a(0);
          function X(V, G) {
            if (!(V instanceof G))
              throw new TypeError("Cannot call a class as a function");
          }
          var H = function() {
            function V(G, Z) {
              X(this, V), this.observer = G, this.config = Z, this.logEnabled = !0;
              try {
                var ae = crypto || self.crypto;
                this.subtle = ae.subtle || ae.webkitSubtle;
              } catch {
              }
              this.disableWebCrypto = !this.subtle;
            }
            return V.prototype.isSync = function() {
              return this.disableWebCrypto && this.config.enableSoftwareAES;
            }, V.prototype.decrypt = function(Z, ae, se, be) {
              var me = this;
              if (this.disableWebCrypto && this.config.enableSoftwareAES) {
                this.logEnabled && (z.b.log("JS AES decrypt"), this.logEnabled = !1);
                var Ae = this.decryptor;
                Ae || (this.decryptor = Ae = new K()), Ae.expandKey(ae), be(Ae.decrypt(Z, 0, se));
              } else {
                this.logEnabled && (z.b.log("WebCrypto AES decrypt"), this.logEnabled = !1);
                var Be = this.subtle;
                this.key !== ae && (this.key = ae, this.fastAesKey = new d(Be, ae)), this.fastAesKey.expandKey().then(function(Ue) {
                  var lt = new m(Be, se);
                  lt.decrypt(Z, Ue).catch(function(xt) {
                    me.onWebCryptoError(xt, Z, ae, se, be);
                  }).then(function(xt) {
                    be(xt);
                  });
                }).catch(function(Ue) {
                  me.onWebCryptoError(Ue, Z, ae, se, be);
                });
              }
            }, V.prototype.onWebCryptoError = function(Z, ae, se, be, me) {
              this.config.enableSoftwareAES ? (z.b.log("WebCrypto Error, disable WebCrypto API"), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(ae, se, be, me)) : (z.b.error("decrypting error : " + Z.message), this.observer.trigger(Event.ERROR, { type: O.b.MEDIA_ERROR, details: O.a.FRAG_DECRYPT_ERROR, fatal: !0, reason: Z.message }));
            }, V.prototype.destroy = function() {
              var Z = this.decryptor;
              Z && (Z.destroy(), this.decryptor = void 0);
            }, V;
          }();
          i.a = H;
        },
        /* 5 */
        /***/
        function(r, i) {
          function a() {
            this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
          }
          r.exports = a, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._maxListeners = void 0, a.defaultMaxListeners = 10, a.prototype.setMaxListeners = function(y) {
            if (!h(y) || y < 0 || isNaN(y))
              throw TypeError("n must be a positive number");
            return this._maxListeners = y, this;
          }, a.prototype.emit = function(y) {
            var d, A, B, K, O, z;
            if (this._events || (this._events = {}), y === "error" && (!this._events.error || m(this._events.error) && !this._events.error.length)) {
              if (d = arguments[1], d instanceof Error)
                throw d;
              var X = new Error('Uncaught, unspecified "error" event. (' + d + ")");
              throw X.context = d, X;
            }
            if (A = this._events[y], p(A))
              return !1;
            if (c(A))
              switch (arguments.length) {
                case 1:
                  A.call(this);
                  break;
                case 2:
                  A.call(this, arguments[1]);
                  break;
                case 3:
                  A.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  K = Array.prototype.slice.call(arguments, 1), A.apply(this, K);
              }
            else if (m(A))
              for (K = Array.prototype.slice.call(arguments, 1), z = A.slice(), B = z.length, O = 0; O < B; O++)
                z[O].apply(this, K);
            return !0;
          }, a.prototype.addListener = function(y, d) {
            var A;
            if (!c(d))
              throw TypeError("listener must be a function");
            return this._events || (this._events = {}), this._events.newListener && this.emit(
              "newListener",
              y,
              c(d.listener) ? d.listener : d
            ), this._events[y] ? m(this._events[y]) ? this._events[y].push(d) : this._events[y] = [this._events[y], d] : this._events[y] = d, m(this._events[y]) && !this._events[y].warned && (p(this._maxListeners) ? A = a.defaultMaxListeners : A = this._maxListeners, A && A > 0 && this._events[y].length > A && (this._events[y].warned = !0, console.error(
              "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
              this._events[y].length
            ), typeof console.trace == "function" && console.trace())), this;
          }, a.prototype.on = a.prototype.addListener, a.prototype.once = function(y, d) {
            if (!c(d))
              throw TypeError("listener must be a function");
            var A = !1;
            function B() {
              this.removeListener(y, B), A || (A = !0, d.apply(this, arguments));
            }
            return B.listener = d, this.on(y, B), this;
          }, a.prototype.removeListener = function(y, d) {
            var A, B, K, O;
            if (!c(d))
              throw TypeError("listener must be a function");
            if (!this._events || !this._events[y])
              return this;
            if (A = this._events[y], K = A.length, B = -1, A === d || c(A.listener) && A.listener === d)
              delete this._events[y], this._events.removeListener && this.emit("removeListener", y, d);
            else if (m(A)) {
              for (O = K; O-- > 0; )
                if (A[O] === d || A[O].listener && A[O].listener === d) {
                  B = O;
                  break;
                }
              if (B < 0)
                return this;
              A.length === 1 ? (A.length = 0, delete this._events[y]) : A.splice(B, 1), this._events.removeListener && this.emit("removeListener", y, d);
            }
            return this;
          }, a.prototype.removeAllListeners = function(y) {
            var d, A;
            if (!this._events)
              return this;
            if (!this._events.removeListener)
              return arguments.length === 0 ? this._events = {} : this._events[y] && delete this._events[y], this;
            if (arguments.length === 0) {
              for (d in this._events)
                d !== "removeListener" && this.removeAllListeners(d);
              return this.removeAllListeners("removeListener"), this._events = {}, this;
            }
            if (A = this._events[y], c(A))
              this.removeListener(y, A);
            else if (A)
              for (; A.length; )
                this.removeListener(y, A[A.length - 1]);
            return delete this._events[y], this;
          }, a.prototype.listeners = function(y) {
            var d;
            return !this._events || !this._events[y] ? d = [] : c(this._events[y]) ? d = [this._events[y]] : d = this._events[y].slice(), d;
          }, a.prototype.listenerCount = function(y) {
            if (this._events) {
              var d = this._events[y];
              if (c(d))
                return 1;
              if (d)
                return d.length;
            }
            return 0;
          }, a.listenerCount = function(y, d) {
            return y.listenerCount(d);
          };
          function c(y) {
            return typeof y == "function";
          }
          function h(y) {
            return typeof y == "number";
          }
          function m(y) {
            return typeof y == "object" && y !== null;
          }
          function p(y) {
            return y === void 0;
          }
        },
        /* 6 */
        /***/
        function(r, i, a) {
          (function(c) {
            var h = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/, m = /^([^\/;?#]*)(.*)$/, p = /(?:\/|^)\.(?=\/)/g, y = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g, d = {
              // jshint ignore:line
              // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
              // E.g
              // With opts.alwaysNormalize = false (default, spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
              // With opts.alwaysNormalize = true (default, not spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
              buildAbsoluteURL: function(A, B, K) {
                if (K = K || {}, A = A.trim(), B = B.trim(), !B) {
                  if (!K.alwaysNormalize)
                    return A;
                  var O = this.parseURL(A);
                  if (!X)
                    throw new Error("Error trying to parse base URL.");
                  return O.path = d.normalizePath(O.path), d.buildURLFromParts(O);
                }
                var z = this.parseURL(B);
                if (!z)
                  throw new Error("Error trying to parse relative URL.");
                if (z.scheme)
                  return K.alwaysNormalize ? (z.path = d.normalizePath(z.path), d.buildURLFromParts(z)) : B;
                var X = this.parseURL(A);
                if (!X)
                  throw new Error("Error trying to parse base URL.");
                if (!X.netLoc && X.path && X.path[0] !== "/") {
                  var H = m.exec(X.path);
                  X.netLoc = H[1], X.path = H[2];
                }
                X.netLoc && !X.path && (X.path = "/");
                var V = {
                  // 2c) Otherwise, the embedded URL inherits the scheme of
                  // the base URL.
                  scheme: X.scheme,
                  netLoc: z.netLoc,
                  path: null,
                  params: z.params,
                  query: z.query,
                  fragment: z.fragment
                };
                if (!z.netLoc && (V.netLoc = X.netLoc, z.path[0] !== "/"))
                  if (!z.path)
                    V.path = X.path, z.params || (V.params = X.params, z.query || (V.query = X.query));
                  else {
                    var G = X.path, Z = G.substring(0, G.lastIndexOf("/") + 1) + z.path;
                    V.path = d.normalizePath(Z);
                  }
                return V.path === null && (V.path = K.alwaysNormalize ? d.normalizePath(z.path) : z.path), d.buildURLFromParts(V);
              },
              parseURL: function(A) {
                var B = h.exec(A);
                return B ? {
                  scheme: B[1] || "",
                  netLoc: B[2] || "",
                  path: B[3] || "",
                  params: B[4] || "",
                  query: B[5] || "",
                  fragment: B[6] || ""
                } : null;
              },
              normalizePath: function(A) {
                for (A = A.split("").reverse().join("").replace(p, ""); A.length !== (A = A.replace(y, "")).length; )
                  ;
                return A.split("").reverse().join("");
              },
              buildURLFromParts: function(A) {
                return A.scheme + A.netLoc + A.path + A.params + A.query + A.fragment;
              }
            };
            r.exports = d;
          })();
        },
        /* 7 */
        /***/
        function(r, i, a) {
          var c = a(1), h = a(2), m = a(4), p = a(0);
          function y(v, I, b, T) {
            var S, L, D, N, M, W = navigator.userAgent.toLowerCase(), Q = T, Y = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
            if (S = ((I[b + 2] & 192) >>> 6) + 1, L = (I[b + 2] & 60) >>> 2, L > Y.length - 1) {
              v.trigger(Event.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: !0, reason: "invalid ADTS sampling index:" + L });
              return;
            }
            return N = (I[b + 2] & 1) << 2, N |= (I[b + 3] & 192) >>> 6, p.b.log("manifest codec:" + T + ",ADTS data:type:" + S + ",sampleingIndex:" + L + "[" + Y[L] + "Hz],channelConfig:" + N), /firefox/i.test(W) ? L >= 6 ? (S = 5, M = new Array(4), D = L - 3) : (S = 2, M = new Array(2), D = L) : W.indexOf("android") !== -1 ? (S = 2, M = new Array(2), D = L) : (S = 5, M = new Array(4), T && (T.indexOf("mp4a.40.29") !== -1 || T.indexOf("mp4a.40.5") !== -1) || !T && L >= 6 ? D = L - 3 : ((T && T.indexOf("mp4a.40.2") !== -1 && (L >= 6 && N === 1 || /vivaldi/i.test(W)) || !T && N === 1) && (S = 2, M = new Array(2)), D = L)), M[0] = S << 3, M[0] |= (L & 14) >> 1, M[1] |= (L & 1) << 7, M[1] |= N << 3, S === 5 && (M[1] |= (D & 14) >> 1, M[2] = (D & 1) << 7, M[2] |= 8, M[3] = 0), { config: M, samplerate: Y[L], channelCount: N, codec: "mp4a.40." + S, manifestCodec: Q };
          }
          function d(v, I) {
            return v[I] === 255 && (v[I + 1] & 246) === 240;
          }
          function A(v, I) {
            return v[I + 1] & 1 ? 7 : 9;
          }
          function B(v, I) {
            return (v[I + 3] & 3) << 11 | v[I + 4] << 3 | (v[I + 5] & 224) >>> 5;
          }
          function K(v, I) {
            return !!(I + 1 < v.length && d(v, I));
          }
          function O(v, I) {
            if (I + 1 < v.length && d(v, I)) {
              var b = A(v, I), T = b;
              I + 5 < v.length && (T = B(v, I));
              var S = I + T;
              if (S === v.length || S + 1 < v.length && d(v, S))
                return !0;
            }
            return !1;
          }
          function z(v, I, b, T, S) {
            if (!v.samplerate) {
              var L = y(I, b, T, S);
              v.config = L.config, v.samplerate = L.samplerate, v.channelCount = L.channelCount, v.codec = L.codec, v.manifestCodec = L.manifestCodec, p.b.log("parsed codec:" + v.codec + ",rate:" + L.samplerate + ",nb channel:" + L.channelCount);
            }
          }
          function X(v) {
            return 1024 * 9e4 / v;
          }
          function H(v, I, b, T, S) {
            var L, D, N, M = v.length;
            if (L = A(v, I), D = B(v, I), D -= L, D > 0 && I + L + D <= M)
              return N = b + T * S, { headerLength: L, frameLength: D, stamp: N };
          }
          function V(v, I, b, T, S) {
            var L = X(v.samplerate), D = H(I, b, T, S, L);
            if (D) {
              var N = D.stamp, M = D.headerLength, W = D.frameLength, Q = {
                unit: I.subarray(b + M, b + M + W),
                pts: N,
                dts: N
              };
              return v.samples.push(Q), v.len += W, { sample: Q, length: W + M };
            }
          }
          var G = a(3);
          function Z(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var ae = function() {
            function v(I, b, T) {
              Z(this, v), this.observer = I, this.config = T, this.remuxer = b;
            }
            return v.prototype.resetInitSegment = function(b, T, S, L) {
              this._audioTrack = { container: "audio/adts", type: "audio", id: 0, sequenceNumber: 0, isAAC: !0, samples: [], len: 0, manifestCodec: T, duration: L, inputTimeScale: 9e4 };
            }, v.prototype.resetTimeStamp = function() {
            }, v.probe = function(b) {
              if (!b)
                return !1;
              for (var T = G.a.getID3Data(b, 0) || [], S = T.length, L = b.length; S < L; S++)
                if (O(b, S))
                  return p.b.log("ADTS sync word found !"), !0;
              return !1;
            }, v.prototype.append = function(b, T, S, L) {
              for (var D = this._audioTrack, N = G.a.getID3Data(b, 0) || [], M = G.a.getTimeStamp(N), W = M ? 90 * M : T * 9e4, Q = 0, Y = W, ie = b.length, re = N.length, pe = [{ pts: Y, dts: Y, data: N }]; re < ie - 1; )
                if (K(b, re) && re + 5 < ie) {
                  z(D, this.observer, b, re, D.manifestCodec);
                  var ue = V(D, b, re, W, Q);
                  if (ue)
                    re += ue.length, Y = ue.sample.pts, Q++;
                  else {
                    p.b.log("Unable to parse AAC frame");
                    break;
                  }
                } else G.a.isHeader(b, re) ? (N = G.a.getID3Data(b, re), pe.push({ pts: Y, dts: Y, data: N }), re += N.length) : re++;
              this.remuxer.remux(D, { samples: [] }, { samples: pe, inputTimeScale: 9e4 }, { samples: [] }, T, S, L);
            }, v.prototype.destroy = function() {
            }, v;
          }(), se = ae;
          function be(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var me = Math.pow(2, 32) - 1, Ae = function() {
            function v(I, b) {
              be(this, v), this.observer = I, this.remuxer = b;
            }
            return v.prototype.resetTimeStamp = function(b) {
              this.initPTS = b;
            }, v.prototype.resetInitSegment = function(b, T, S, L) {
              if (b && b.byteLength) {
                var D = this.initData = v.parseInitSegment(b);
                T == null && (T = "mp4a.40.5"), S == null && (S = "avc1.42e01e");
                var N = {};
                D.audio && D.video ? N.audiovideo = { container: "video/mp4", codec: T + "," + S, initSegment: L ? b : null } : (D.audio && (N.audio = { container: "audio/mp4", codec: T, initSegment: L ? b : null }), D.video && (N.video = { container: "video/mp4", codec: S, initSegment: L ? b : null })), this.observer.trigger(c.a.FRAG_PARSING_INIT_SEGMENT, { tracks: N });
              } else
                T && (this.audioCodec = T), S && (this.videoCodec = S);
            }, v.probe = function(b) {
              return v.findBox({ data: b, start: 0, end: Math.min(b.length, 16384) }, ["moof"]).length > 0;
            }, v.bin2str = function(b) {
              return String.fromCharCode.apply(null, b);
            }, v.readUint32 = function(b, T) {
              b.data && (T += b.start, b = b.data);
              var S = b[T] << 24 | b[T + 1] << 16 | b[T + 2] << 8 | b[T + 3];
              return S < 0 ? 4294967296 + S : S;
            }, v.writeUint32 = function(b, T, S) {
              b.data && (T += b.start, b = b.data), b[T] = S >> 24, b[T + 1] = S >> 16 & 255, b[T + 2] = S >> 8 & 255, b[T + 3] = S & 255;
            }, v.findBox = function(b, T) {
              var S = [], L, D, N, M, W, Q, Y;
              if (b.data ? (Q = b.start, M = b.end, b = b.data) : (Q = 0, M = b.byteLength), !T.length)
                return null;
              for (L = Q; L < M; )
                D = v.readUint32(b, L), N = v.bin2str(b.subarray(L + 4, L + 8)), Y = D > 1 ? L + D : M, N === T[0] && (T.length === 1 ? S.push({ data: b, start: L + 8, end: Y }) : (W = v.findBox({ data: b, start: L + 8, end: Y }, T.slice(1)), W.length && (S = S.concat(W)))), L = Y;
              return S;
            }, v.parseInitSegment = function(b) {
              var T = [], S = v.findBox(b, ["moov", "trak"]);
              return S.forEach(function(L) {
                var D = v.findBox(L, ["tkhd"])[0];
                if (D) {
                  var N = D.data[D.start], M = N === 0 ? 12 : 20, W = v.readUint32(D, M), Q = v.findBox(L, ["mdia", "mdhd"])[0];
                  if (Q) {
                    N = Q.data[Q.start], M = N === 0 ? 12 : 20;
                    var Y = v.readUint32(Q, M), ie = v.findBox(L, ["mdia", "hdlr"])[0];
                    if (ie) {
                      var re = v.bin2str(ie.data.subarray(ie.start + 8, ie.start + 12)), pe = { soun: "audio", vide: "video" }[re];
                      if (pe) {
                        var ue = v.findBox(L, ["mdia", "minf", "stbl", "stsd"]);
                        if (ue.length) {
                          ue = ue[0];
                          var ce = v.bin2str(ue.data.subarray(ue.start + 12, ue.start + 16));
                          p.b.log("MP4Demuxer:" + pe + ":" + ce + " found");
                        }
                        T[W] = { timescale: Y, type: pe }, T[pe] = { timescale: Y, id: W };
                      }
                    }
                  }
                }
              }), T;
            }, v.getStartDTS = function(b, T) {
              var S, L, D;
              return S = v.findBox(T, ["moof", "traf"]), L = [].concat.apply([], S.map(function(N) {
                return v.findBox(N, ["tfhd"]).map(function(M) {
                  var W, Q, Y;
                  return W = v.readUint32(M, 4), Q = b[W].timescale || 9e4, Y = v.findBox(N, ["tfdt"]).map(function(ie) {
                    var re, pe;
                    return re = ie.data[ie.start], pe = v.readUint32(ie, 4), re === 1 && (pe *= Math.pow(2, 32), pe += v.readUint32(ie, 8)), pe;
                  })[0], Y / Q;
                });
              })), D = Math.min.apply(null, L), isFinite(D) ? D : 0;
            }, v.offsetStartDTS = function(b, T, S) {
              v.findBox(T, ["moof", "traf"]).map(function(L) {
                return v.findBox(L, ["tfhd"]).map(function(D) {
                  var N = v.readUint32(D, 4), M = b[N].timescale || 9e4;
                  v.findBox(L, ["tfdt"]).map(function(W) {
                    var Q = W.data[W.start], Y = v.readUint32(W, 4);
                    if (Q === 0)
                      v.writeUint32(W, 4, Y - S * M);
                    else {
                      Y *= Math.pow(2, 32), Y += v.readUint32(W, 8), Y -= S * M, Y = Math.max(Y, 0);
                      var ie = Math.floor(Y / (me + 1)), re = Math.floor(Y % (me + 1));
                      v.writeUint32(W, 4, ie), v.writeUint32(W, 8, re);
                    }
                  });
                });
              });
            }, v.prototype.append = function(b, T, S, L) {
              var D = this.initData;
              D || (this.resetInitSegment(b, this.audioCodec, this.videoCodec), D = this.initData);
              var N = void 0, M = this.initPTS;
              if (M === void 0) {
                var W = v.getStartDTS(D, b);
                this.initPTS = M = W - T, this.observer.trigger(c.a.INIT_PTS_FOUND, { initPTS: M });
              }
              v.offsetStartDTS(D, b, M), N = v.getStartDTS(D, b), this.remuxer.remux(D.audio, D.video, null, null, N, S, L, b);
            }, v.prototype.destroy = function() {
            }, v;
          }(), Be = Ae, Ue = {
            BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
            SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
            SamplesCoefficients: [
              // MPEG 2.5
              [
                0,
                // Reserved
                72,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ],
              // Reserved
              [
                0,
                // Reserved
                0,
                // Layer3
                0,
                // Layer2
                0
                // Layer1
              ],
              // MPEG 2
              [
                0,
                // Reserved
                72,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ],
              // MPEG 1
              [
                0,
                // Reserved
                144,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ]
            ],
            BytesInSlot: [
              0,
              // Reserved
              1,
              // Layer3
              1,
              // Layer2
              4
              // Layer1
            ],
            appendFrame: function(I, b, T, S, L) {
              if (!(T + 24 > b.length)) {
                var D = this.parseHeader(b, T);
                if (D && T + D.frameLength <= b.length) {
                  var N = D.samplesPerFrame * 9e4 / D.sampleRate, M = S + L * N, W = { unit: b.subarray(T, T + D.frameLength), pts: M, dts: M };
                  return I.config = [], I.channelCount = D.channelCount, I.samplerate = D.sampleRate, I.samples.push(W), I.len += D.frameLength, { sample: W, length: D.frameLength };
                }
              }
            },
            parseHeader: function(I, b) {
              var T = I[b + 1] >> 3 & 3, S = I[b + 1] >> 1 & 3, L = I[b + 2] >> 4 & 15, D = I[b + 2] >> 2 & 3, N = I[b + 2] >> 1 & 1;
              if (T !== 1 && L !== 0 && L !== 15 && D !== 3) {
                var M = T === 3 ? 3 - S : S === 3 ? 3 : 4, W = Ue.BitratesMap[M * 14 + L - 1] * 1e3, Q = T === 3 ? 0 : T === 2 ? 1 : 2, Y = Ue.SamplingRateMap[Q * 3 + D], ie = I[b + 3] >> 6 === 3 ? 1 : 2, re = Ue.SamplesCoefficients[T][S], pe = Ue.BytesInSlot[S], ue = re * 8 * pe, ce = parseInt(re * W / Y + N, 10) * pe;
                return { sampleRate: Y, channelCount: ie, frameLength: ce, samplesPerFrame: ue };
              }
            },
            isHeaderPattern: function(I, b) {
              return I[b] === 255 && (I[b + 1] & 224) === 224 && (I[b + 1] & 6) !== 0;
            },
            isHeader: function(I, b) {
              return !!(b + 1 < I.length && this.isHeaderPattern(I, b));
            },
            probe: function(I, b) {
              if (b + 1 < I.length && this.isHeaderPattern(I, b)) {
                var T = 4, S = this.parseHeader(I, b), L = T;
                S && S.frameLength && (L = S.frameLength);
                var D = b + L;
                if (D === I.length || D + 1 < I.length && this.isHeaderPattern(I, D))
                  return !0;
              }
              return !1;
            }
          }, lt = Ue;
          function xt(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var ut = function() {
            function v(I) {
              xt(this, v), this.data = I, this.bytesAvailable = I.byteLength, this.word = 0, this.bitsAvailable = 0;
            }
            return v.prototype.loadWord = function() {
              var b = this.data, T = this.bytesAvailable, S = b.byteLength - T, L = new Uint8Array(4), D = Math.min(4, T);
              if (D === 0)
                throw new Error("no bytes available");
              L.set(b.subarray(S, S + D)), this.word = new DataView(L.buffer).getUint32(0), this.bitsAvailable = D * 8, this.bytesAvailable -= D;
            }, v.prototype.skipBits = function(b) {
              var T;
              this.bitsAvailable > b ? (this.word <<= b, this.bitsAvailable -= b) : (b -= this.bitsAvailable, T = b >> 3, b -= T >> 3, this.bytesAvailable -= T, this.loadWord(), this.word <<= b, this.bitsAvailable -= b);
            }, v.prototype.readBits = function(b) {
              var T = Math.min(this.bitsAvailable, b), S = this.word >>> 32 - T;
              return b > 32 && p.b.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= T, this.bitsAvailable > 0 ? this.word <<= T : this.bytesAvailable > 0 && this.loadWord(), T = b - T, T > 0 && this.bitsAvailable ? S << T | this.readBits(T) : S;
            }, v.prototype.skipLZ = function() {
              var b;
              for (b = 0; b < this.bitsAvailable; ++b)
                if (this.word & 2147483648 >>> b)
                  return this.word <<= b, this.bitsAvailable -= b, b;
              return this.loadWord(), b + this.skipLZ();
            }, v.prototype.skipUEG = function() {
              this.skipBits(1 + this.skipLZ());
            }, v.prototype.skipEG = function() {
              this.skipBits(1 + this.skipLZ());
            }, v.prototype.readUEG = function() {
              var b = this.skipLZ();
              return this.readBits(b + 1) - 1;
            }, v.prototype.readEG = function() {
              var b = this.readUEG();
              return 1 & b ? 1 + b >>> 1 : -1 * (b >>> 1);
            }, v.prototype.readBoolean = function() {
              return this.readBits(1) === 1;
            }, v.prototype.readUByte = function() {
              return this.readBits(8);
            }, v.prototype.readUShort = function() {
              return this.readBits(16);
            }, v.prototype.readUInt = function() {
              return this.readBits(32);
            }, v.prototype.skipScalingList = function(b) {
              var T = 8, S = 8, L, D;
              for (L = 0; L < b; L++)
                S !== 0 && (D = this.readEG(), S = (T + D + 256) % 256), T = S === 0 ? T : S;
            }, v.prototype.readSPS = function() {
              var b = 0, T = 0, S = 0, L = 0, D, N, M, W, Q, Y, ie, re = this.readUByte.bind(this), pe = this.readBits.bind(this), ue = this.readUEG.bind(this), ce = this.readBoolean.bind(this), ee = this.skipBits.bind(this), Ie = this.skipEG.bind(this), Ye = this.skipUEG.bind(this), Je = this.skipScalingList.bind(this);
              if (re(), D = re(), pe(5), ee(3), re(), Ye(), D === 100 || D === 110 || D === 122 || D === 244 || D === 44 || D === 83 || D === 86 || D === 118 || D === 128) {
                var Fe = ue();
                if (Fe === 3 && ee(1), Ye(), Ye(), ee(1), ce())
                  for (Y = Fe !== 3 ? 8 : 12, ie = 0; ie < Y; ie++)
                    ce() && (ie < 6 ? Je(16) : Je(64));
              }
              Ye();
              var He = ue();
              if (He === 0)
                ue();
              else if (He === 1)
                for (ee(1), Ie(), Ie(), N = ue(), ie = 0; ie < N; ie++)
                  Ie();
              Ye(), ee(1), M = ue(), W = ue(), Q = pe(1), Q === 0 && ee(1), ee(1), ce() && (b = ue(), T = ue(), S = ue(), L = ue());
              var Te = [1, 1];
              if (ce() && ce()) {
                var rt = re();
                switch (rt) {
                  case 1:
                    Te = [1, 1];
                    break;
                  case 2:
                    Te = [12, 11];
                    break;
                  case 3:
                    Te = [10, 11];
                    break;
                  case 4:
                    Te = [16, 11];
                    break;
                  case 5:
                    Te = [40, 33];
                    break;
                  case 6:
                    Te = [24, 11];
                    break;
                  case 7:
                    Te = [20, 11];
                    break;
                  case 8:
                    Te = [32, 11];
                    break;
                  case 9:
                    Te = [80, 33];
                    break;
                  case 10:
                    Te = [18, 11];
                    break;
                  case 11:
                    Te = [15, 11];
                    break;
                  case 12:
                    Te = [64, 33];
                    break;
                  case 13:
                    Te = [160, 99];
                    break;
                  case 14:
                    Te = [4, 3];
                    break;
                  case 15:
                    Te = [3, 2];
                    break;
                  case 16:
                    Te = [2, 1];
                    break;
                  case 255: {
                    Te = [re() << 8 | re(), re() << 8 | re()];
                    break;
                  }
                }
              }
              return {
                width: Math.ceil((M + 1) * 16 - b * 2 - T * 2),
                height: (2 - Q) * (W + 1) * 16 - (Q ? 2 : 4) * (S + L),
                pixelRatio: Te
              };
            }, v.prototype.readSliceType = function() {
              return this.readUByte(), this.readUEG(), this.readUEG();
            }, v;
          }(), qt = ut;
          function tt(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var Et = function() {
            function v(I, b, T, S) {
              tt(this, v), this.decryptdata = T, this.discardEPB = S, this.decrypter = new m.a(I, b);
            }
            return v.prototype.decryptBuffer = function(b, T) {
              this.decrypter.decrypt(b, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, T);
            }, v.prototype.decryptAacSample = function(b, T, S, L) {
              var D = b[T].unit, N = D.subarray(16, D.length - D.length % 16), M = N.buffer.slice(N.byteOffset, N.byteOffset + N.length), W = this;
              this.decryptBuffer(M, function(Q) {
                Q = new Uint8Array(Q), D.set(Q, 16), L || W.decryptAacSamples(b, T + 1, S);
              });
            }, v.prototype.decryptAacSamples = function(b, T, S) {
              for (; ; T++) {
                if (T >= b.length) {
                  S();
                  return;
                }
                if (!(b[T].unit.length < 32)) {
                  var L = this.decrypter.isSync();
                  if (this.decryptAacSample(b, T, S, L), !L)
                    return;
                }
              }
            }, v.prototype.getAvcEncryptedData = function(b) {
              for (var T = Math.floor((b.length - 48) / 160) * 16 + 16, S = new Int8Array(T), L = 0, D = 32; D <= b.length - 16; D += 160, L += 16)
                S.set(b.subarray(D, D + 16), L);
              return S;
            }, v.prototype.getAvcDecryptedUnit = function(b, T) {
              T = new Uint8Array(T);
              for (var S = 0, L = 32; L <= b.length - 16; L += 160, S += 16)
                b.set(T.subarray(S, S + 16), L);
              return b;
            }, v.prototype.decryptAvcSample = function(b, T, S, L, D, N) {
              var M = this.discardEPB(D.data), W = this.getAvcEncryptedData(M), Q = this;
              this.decryptBuffer(W.buffer, function(Y) {
                D.data = Q.getAvcDecryptedUnit(M, Y), N || Q.decryptAvcSamples(b, T, S + 1, L);
              });
            }, v.prototype.decryptAvcSamples = function(b, T, S, L) {
              for (; ; T++, S = 0) {
                if (T >= b.length) {
                  L();
                  return;
                }
                for (var D = b[T].units; !(S >= D.length); S++) {
                  var N = D[S];
                  if (!(N.length <= 48 || N.type !== 1 && N.type !== 5)) {
                    var M = this.decrypter.isSync();
                    if (this.decryptAvcSample(b, T, S, L, N, M), !M)
                      return;
                  }
                }
              }
            }, v;
          }(), Vt = Et;
          function vt(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var at = {
            video: 0,
            audio: 1,
            id3: 2,
            text: 3
          }, kt = function() {
            function v(I, b, T, S) {
              vt(this, v), this.observer = I, this.config = T, this.typeSupported = S, this.remuxer = b, this.sampleAes = null;
            }
            return v.prototype.setDecryptData = function(b) {
              b != null && b.key != null && b.method === "SAMPLE-AES" ? this.sampleAes = new Vt(this.observer, this.config, b, this.discardEPB) : this.sampleAes = null;
            }, v.probe = function(b) {
              var T = v._syncOffset(b);
              return T < 0 ? !1 : (T && p.b.warn("MPEG2-TS detected but first sync word found @ offset " + T + ", junk ahead ?"), !0);
            }, v._syncOffset = function(b) {
              for (var T = Math.min(1e3, b.length - 564), S = 0; S < T; ) {
                if (b[S] === 71 && b[S + 188] === 71 && b[S + 2 * 188] === 71)
                  return S;
                S++;
              }
              return -1;
            }, v.createTrack = function(b, T) {
              return {
                container: b === "video" || b === "audio" ? "video/mp2t" : void 0,
                type: b,
                id: at[b],
                pid: -1,
                inputTimeScale: 9e4,
                sequenceNumber: 0,
                samples: [],
                len: 0,
                dropped: b === "video" ? 0 : void 0,
                isAAC: b === "audio" ? !0 : void 0,
                duration: b === "audio" ? T : void 0
              };
            }, v.prototype.resetInitSegment = function(b, T, S, L) {
              this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = v.createTrack("video", L), this._audioTrack = v.createTrack("audio", L), this._id3Track = v.createTrack("id3", L), this._txtTrack = v.createTrack("text", L), this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = T, this.videoCodec = S, this._duration = L;
            }, v.prototype.resetTimeStamp = function() {
            }, v.prototype.append = function(b, T, S, L) {
              var D, N = b.length, M, W, Q, Y, ie, re = !1;
              this.contiguous = S;
              var pe = this.pmtParsed, ue = this._avcTrack, ce = this._audioTrack, ee = this._id3Track, Ie = ue.pid, Ye = ce.pid, Je = ee.pid, Fe = this._pmtId, He = ue.pesData, Te = ce.pesData, rt = ee.pesData, Rt = this._parsePAT, Qe = this._parsePMT, gt = this._parsePES, Ct = this._parseAVCPES.bind(this), ir = this._parseAACPES.bind(this), Dt = this._parseMPEGPES.bind(this), br = this._parseID3PES.bind(this), zt = v._syncOffset(b);
              for (N -= (N + zt) % 188, D = zt; D < N; D += 188)
                if (b[D] === 71) {
                  if (M = !!(b[D + 1] & 64), W = ((b[D + 1] & 31) << 8) + b[D + 2], Q = (b[D + 3] & 48) >> 4, Q > 1) {
                    if (Y = D + 5 + b[D + 4], Y === D + 188)
                      continue;
                  } else
                    Y = D + 4;
                  switch (W) {
                    case Ie:
                      M && (He && (ie = gt(He)) && Ct(ie, !1), He = { data: [], size: 0 }), He && (He.data.push(b.subarray(Y, D + 188)), He.size += D + 188 - Y);
                      break;
                    case Ye:
                      M && (Te && (ie = gt(Te)) && (ce.isAAC ? ir(ie) : Dt(ie)), Te = { data: [], size: 0 }), Te && (Te.data.push(b.subarray(Y, D + 188)), Te.size += D + 188 - Y);
                      break;
                    case Je:
                      M && (rt && (ie = gt(rt)) && br(ie), rt = { data: [], size: 0 }), rt && (rt.data.push(b.subarray(Y, D + 188)), rt.size += D + 188 - Y);
                      break;
                    case 0:
                      M && (Y += b[Y] + 1), Fe = this._pmtId = Rt(b, Y);
                      break;
                    case Fe:
                      M && (Y += b[Y] + 1);
                      var nr = Qe(b, Y, this.typeSupported.mpeg === !0 || this.typeSupported.mp3 === !0, this.sampleAes != null);
                      Ie = nr.avc, Ie > 0 && (ue.pid = Ie), Ye = nr.audio, Ye > 0 && (ce.pid = Ye, ce.isAAC = nr.isAAC), Je = nr.id3, Je > 0 && (ee.pid = Je), re && !pe && (p.b.log("reparse from beginning"), re = !1, D = zt - 188), pe = this.pmtParsed = !0;
                      break;
                    case 17:
                    case 8191:
                      break;
                    default:
                      re = !0;
                      break;
                  }
                } else
                  this.observer.trigger(c.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: !1, reason: "TS packet did not start with 0x47" });
              He && (ie = gt(He)) ? (Ct(ie, !0), ue.pesData = null) : ue.pesData = He, Te && (ie = gt(Te)) ? (ce.isAAC ? ir(ie) : Dt(ie), ce.pesData = null) : (Te && Te.size && p.b.log("last AAC PES packet truncated,might overlap between fragments"), ce.pesData = Te), rt && (ie = gt(rt)) ? (br(ie), ee.pesData = null) : ee.pesData = rt, this.sampleAes == null ? this.remuxer.remux(ce, ue, ee, this._txtTrack, T, S, L) : this.decryptAndRemux(ce, ue, ee, this._txtTrack, T, S, L);
            }, v.prototype.decryptAndRemux = function(b, T, S, L, D, N, M) {
              if (b.samples && b.isAAC) {
                var W = this;
                this.sampleAes.decryptAacSamples(b.samples, 0, function() {
                  W.decryptAndRemuxAvc(b, T, S, L, D, N, M);
                });
              } else
                this.decryptAndRemuxAvc(b, T, S, L, D, N, M);
            }, v.prototype.decryptAndRemuxAvc = function(b, T, S, L, D, N, M) {
              if (T.samples) {
                var W = this;
                this.sampleAes.decryptAvcSamples(T.samples, 0, 0, function() {
                  W.remuxer.remux(b, T, S, L, D, N, M);
                });
              } else
                this.remuxer.remux(b, T, S, L, D, N, M);
            }, v.prototype.destroy = function() {
              this._initPTS = this._initDTS = void 0, this._duration = 0;
            }, v.prototype._parsePAT = function(b, T) {
              return (b[T + 10] & 31) << 8 | b[T + 11];
            }, v.prototype._parsePMT = function(b, T, S, L) {
              var D, N, M, W, Q = { audio: -1, avc: -1, id3: -1, isAAC: !0 };
              for (D = (b[T + 1] & 15) << 8 | b[T + 2], N = T + 3 + D - 4, M = (b[T + 10] & 15) << 8 | b[T + 11], T += 12 + M; T < N; ) {
                switch (W = (b[T + 1] & 31) << 8 | b[T + 2], b[T]) {
                  case 207:
                    if (!L) {
                      p.b.log("unkown stream type:" + b[T]);
                      break;
                    }
                  case 15:
                    Q.audio === -1 && (Q.audio = W);
                    break;
                  case 21:
                    Q.id3 === -1 && (Q.id3 = W);
                    break;
                  case 219:
                    if (!L) {
                      p.b.log("unkown stream type:" + b[T]);
                      break;
                    }
                  case 27:
                    Q.avc === -1 && (Q.avc = W);
                    break;
                  case 3:
                  case 4:
                    S ? Q.audio === -1 && (Q.audio = W, Q.isAAC = !1) : p.b.log("MPEG audio found, not supported in this browser for now");
                    break;
                  case 36:
                    p.b.warn("HEVC stream type found, not supported for now");
                    break;
                  default:
                    p.b.log("unkown stream type:" + b[T]);
                    break;
                }
                T += ((b[T + 3] & 15) << 8 | b[T + 4]) + 5;
              }
              return Q;
            }, v.prototype._parsePES = function(b) {
              var T = 0, S, L, D, N, M, W, Q, Y, ie, re = b.data;
              if (!b || b.size === 0)
                return null;
              for (; re[0].length < 19 && re.length > 1; ) {
                var pe = new Uint8Array(re[0].length + re[1].length);
                pe.set(re[0]), pe.set(re[1], re[0].length), re[0] = pe, re.splice(1, 1);
              }
              if (S = re[0], D = (S[0] << 16) + (S[1] << 8) + S[2], D === 1) {
                if (N = (S[4] << 8) + S[5], N && N > b.size - 6)
                  return null;
                L = S[7], L & 192 && (Q = (S[9] & 14) * 536870912 + // 1 << 29
                (S[10] & 255) * 4194304 + // 1 << 22
                (S[11] & 254) * 16384 + // 1 << 14
                (S[12] & 255) * 128 + // 1 << 7
                (S[13] & 254) / 2, Q > 4294967295 && (Q -= 8589934592), L & 64 ? (Y = (S[14] & 14) * 536870912 + // 1 << 29
                (S[15] & 255) * 4194304 + // 1 << 22
                (S[16] & 254) * 16384 + // 1 << 14
                (S[17] & 255) * 128 + // 1 << 7
                (S[18] & 254) / 2, Y > 4294967295 && (Y -= 8589934592), Q - Y > 60 * 9e4 && (p.b.warn(Math.round((Q - Y) / 9e4) + "s delta between PTS and DTS, align them"), Q = Y)) : Y = Q), M = S[8], ie = M + 9, b.size -= ie, W = new Uint8Array(b.size);
                for (var ue = 0, ce = re.length; ue < ce; ue++) {
                  S = re[ue];
                  var ee = S.byteLength;
                  if (ie)
                    if (ie > ee) {
                      ie -= ee;
                      continue;
                    } else
                      S = S.subarray(ie), ee -= ie, ie = 0;
                  W.set(S, T), T += ee;
                }
                return N && (N -= M + 3), { data: W, pts: Q, dts: Y, len: N };
              } else
                return null;
            }, v.prototype.pushAccesUnit = function(b, T) {
              if (b.units.length && b.frame) {
                var S = T.samples, L = S.length;
                !this.config.forceKeyFrameOnDiscontinuity || b.key === !0 || T.sps && (L || this.contiguous) ? (b.id = L, S.push(b)) : T.dropped++;
              }
              b.debug.length && p.b.log(b.pts + "/" + b.dts + ":" + b.debug);
            }, v.prototype._parseAVCPES = function(b, T) {
              var S = this, L = this._avcTrack, D = this._parseAVCNALu(b.data), N, M = this.avcSample, W, Q = !1, Y, ie = this.pushAccesUnit.bind(this), re = function(ue, ce, ee, Ie) {
                return { key: ue, pts: ce, dts: ee, units: [], debug: Ie };
              };
              b.data = null, M && D.length && !L.audFound && (ie(M, L), M = this.avcSample = re(!1, b.pts, b.dts, "")), D.forEach(function(pe) {
                switch (pe.type) {
                  case 1:
                    W = !0, M || (M = S.avcSample = re(!0, b.pts, b.dts, "")), M.frame = !0;
                    var ue = pe.data;
                    if (Q && ue.length > 4) {
                      var ce = new qt(ue).readSliceType();
                      (ce === 2 || ce === 4 || ce === 7 || ce === 9) && (M.key = !0);
                    }
                    break;
                  case 5:
                    W = !0, M || (M = S.avcSample = re(!0, b.pts, b.dts, "")), M.key = !0, M.frame = !0;
                    break;
                  case 6:
                    W = !0, N = new qt(S.discardEPB(pe.data)), N.readUByte();
                    for (var ee = 0, Ie = 0, Ye = !1, Je = 0; !Ye && N.bytesAvailable > 1; ) {
                      ee = 0;
                      do
                        Je = N.readUByte(), ee += Je;
                      while (Je === 255);
                      Ie = 0;
                      do
                        Je = N.readUByte(), Ie += Je;
                      while (Je === 255);
                      if (ee === 4 && N.bytesAvailable !== 0) {
                        Ye = !0;
                        var Fe = N.readUByte();
                        if (Fe === 181) {
                          var He = N.readUShort();
                          if (He === 49) {
                            var Te = N.readUInt();
                            if (Te === 1195456820) {
                              var rt = N.readUByte();
                              if (rt === 3) {
                                var Rt = N.readUByte(), Qe = N.readUByte(), gt = 31 & Rt, Ct = [Rt, Qe];
                                for (Y = 0; Y < gt; Y++)
                                  Ct.push(N.readUByte()), Ct.push(N.readUByte()), Ct.push(N.readUByte());
                                S._insertSampleInOrder(S._txtTrack.samples, { type: 3, pts: b.pts, bytes: Ct });
                              }
                            }
                          }
                        }
                      } else if (Ie < N.bytesAvailable)
                        for (Y = 0; Y < Ie; Y++)
                          N.readUByte();
                    }
                    break;
                  case 7:
                    if (W = !0, Q = !0, !L.sps) {
                      N = new qt(pe.data);
                      var ir = N.readSPS();
                      L.width = ir.width, L.height = ir.height, L.pixelRatio = ir.pixelRatio, L.sps = [pe.data], L.duration = S._duration;
                      var Dt = pe.data.subarray(1, 4), br = "avc1.";
                      for (Y = 0; Y < 3; Y++) {
                        var zt = Dt[Y].toString(16);
                        zt.length < 2 && (zt = "0" + zt), br += zt;
                      }
                      L.codec = br;
                    }
                    break;
                  case 8:
                    W = !0, L.pps || (L.pps = [pe.data]);
                    break;
                  case 9:
                    W = !1, L.audFound = !0, M && ie(M, L), M = S.avcSample = re(!1, b.pts, b.dts, "");
                    break;
                  case 12:
                    W = !1;
                    break;
                  default:
                    W = !1, M && (M.debug += "unknown NAL " + pe.type + " ");
                    break;
                }
                if (M && W) {
                  var nr = M.units;
                  nr.push(pe);
                }
              }), T && M && (ie(M, L), this.avcSample = null);
            }, v.prototype._insertSampleInOrder = function(b, T) {
              var S = b.length;
              if (S > 0) {
                if (T.pts >= b[S - 1].pts)
                  b.push(T);
                else
                  for (var L = S - 1; L >= 0; L--)
                    if (T.pts < b[L].pts) {
                      b.splice(L, 0, T);
                      break;
                    }
              } else
                b.push(T);
            }, v.prototype._getLastNalUnit = function() {
              var b = this.avcSample, T = void 0;
              if (!b || b.units.length === 0) {
                var S = this._avcTrack, L = S.samples;
                b = L[L.length - 1];
              }
              if (b) {
                var D = b.units;
                T = D[D.length - 1];
              }
              return T;
            }, v.prototype._parseAVCNALu = function(b) {
              var T = 0, S = b.byteLength, L, D, N = this._avcTrack, M = N.naluState || 0, W = M, Q = [], Y, ie, re = -1, pe;
              for (M === -1 && (re = 0, pe = b[0] & 31, M = 0, T = 1); T < S; ) {
                if (L = b[T++], !M) {
                  M = L ? 0 : 1;
                  continue;
                }
                if (M === 1) {
                  M = L ? 0 : 2;
                  continue;
                }
                if (!L)
                  M = 3;
                else if (L === 1) {
                  if (re >= 0)
                    Y = { data: b.subarray(re, T - M - 1), type: pe }, Q.push(Y);
                  else {
                    var ue = this._getLastNalUnit();
                    if (ue && (W && T <= 4 - W && ue.state && (ue.data = ue.data.subarray(0, ue.data.byteLength - W)), D = T - M - 1, D > 0)) {
                      var ce = new Uint8Array(ue.data.byteLength + D);
                      ce.set(ue.data, 0), ce.set(b.subarray(0, D), ue.data.byteLength), ue.data = ce;
                    }
                  }
                  T < S ? (ie = b[T] & 31, re = T, pe = ie, M = 0) : M = -1;
                } else
                  M = 0;
              }
              if (re >= 0 && M >= 0 && (Y = { data: b.subarray(re, S), type: pe, state: M }, Q.push(Y)), Q.length === 0) {
                var ee = this._getLastNalUnit();
                if (ee) {
                  var Ie = new Uint8Array(ee.data.byteLength + b.byteLength);
                  Ie.set(ee.data, 0), Ie.set(b, ee.data.byteLength), ee.data = Ie;
                }
              }
              return N.naluState = M, Q;
            }, v.prototype.discardEPB = function(b) {
              for (var T = b.byteLength, S = [], L = 1, D, N; L < T - 2; )
                b[L] === 0 && b[L + 1] === 0 && b[L + 2] === 3 ? (S.push(L + 2), L += 2) : L++;
              if (S.length === 0)
                return b;
              D = T - S.length, N = new Uint8Array(D);
              var M = 0;
              for (L = 0; L < D; M++, L++)
                M === S[0] && (M++, S.shift()), N[L] = b[M];
              return N;
            }, v.prototype._parseAACPES = function(b) {
              var T = this._audioTrack, S = b.data, L = b.pts, D = 0, N = this.aacOverFlow, M = this.aacLastPTS, W, Q, Y, ie, re;
              if (N) {
                var pe = new Uint8Array(N.byteLength + S.byteLength);
                pe.set(N, 0), pe.set(S, N.byteLength), S = pe;
              }
              for (Y = D, re = S.length; Y < re - 1 && !K(S, Y); Y++)
                ;
              if (Y) {
                var ue, ce;
                if (Y < re - 1 ? (ue = "AAC PES did not start with ADTS header,offset:" + Y, ce = !1) : (ue = "no ADTS header found in AAC PES", ce = !0), p.b.warn("parsing error:" + ue), this.observer.trigger(c.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: ce, reason: ue }), ce)
                  return;
              }
              if (z(T, this.observer, S, Y, this.audioCodec), Q = 0, W = X(T.samplerate), N && M) {
                var ee = M + W;
                Math.abs(ee - L) > 1 && (p.b.log("AAC: align PTS for overlapping frames by " + Math.round((ee - L) / 90)), L = ee);
              }
              for (; Y < re; )
                if (K(S, Y) && Y + 5 < re) {
                  var Ie = V(T, S, Y, L, Q);
                  if (Ie)
                    Y += Ie.length, ie = Ie.sample.pts, Q++;
                  else
                    break;
                } else
                  Y++;
              Y < re ? N = S.subarray(Y, re) : N = null, this.aacOverFlow = N, this.aacLastPTS = ie;
            }, v.prototype._parseMPEGPES = function(b) {
              for (var T = b.data, S = T.length, L = 0, D = 0, N = b.pts; D < S; )
                if (lt.isHeader(T, D)) {
                  var M = lt.appendFrame(this._audioTrack, T, D, N, L);
                  if (M)
                    D += M.length, L++;
                  else
                    break;
                } else
                  D++;
            }, v.prototype._parseID3PES = function(b) {
              this._id3Track.samples.push(b);
            }, v;
          }(), Ge = kt;
          function Pr(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var ot = function() {
            function v(I, b, T) {
              Pr(this, v), this.observer = I, this.config = T, this.remuxer = b;
            }
            return v.prototype.resetInitSegment = function(b, T, S, L) {
              this._audioTrack = { container: "audio/mpeg", type: "audio", id: -1, sequenceNumber: 0, isAAC: !1, samples: [], len: 0, manifestCodec: T, duration: L, inputTimeScale: 9e4 };
            }, v.prototype.resetTimeStamp = function() {
            }, v.probe = function(b) {
              var T, S, L = G.a.getID3Data(b, 0);
              if (L && G.a.getTimeStamp(L) !== void 0) {
                for (T = L.length, S = Math.min(b.length - 1, T + 100); T < S; T++)
                  if (lt.probe(b, T))
                    return p.b.log("MPEG Audio sync word found !"), !0;
              }
              return !1;
            }, v.prototype.append = function(b, T, S, L) {
              for (var D = G.a.getID3Data(b, 0), N = G.a.getTimeStamp(D), M = N ? 90 * N : T * 9e4, W = D.length, Q = b.length, Y = 0, ie = 0, re = this._audioTrack, pe = [{ pts: M, dts: M, data: D }]; W < Q; )
                if (lt.isHeader(b, W)) {
                  var ue = lt.appendFrame(re, b, W, M, Y);
                  if (ue)
                    W += ue.length, ie = ue.sample.pts, Y++;
                  else
                    break;
                } else G.a.isHeader(b, W) ? (D = G.a.getID3Data(b, W), pe.push({ pts: ie, dts: ie, data: D }), W += D.length) : W++;
              this.remuxer.remux(re, { samples: [] }, { samples: pe, inputTimeScale: 9e4 }, { samples: [] }, T, S, L);
            }, v.prototype.destroy = function() {
            }, v;
          }(), tn = ot;
          function dr(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var fr = function() {
            function v() {
              dr(this, v);
            }
            return v.getSilentFrame = function(b, T) {
              switch (b) {
                case "mp4a.40.2":
                  if (T === 1)
                    return new Uint8Array([0, 200, 0, 128, 35, 128]);
                  if (T === 2)
                    return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                  if (T === 3)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                  if (T === 4)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                  if (T === 5)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                  if (T === 6)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                  break;
                default:
                  if (T === 1)
                    return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  if (T === 2)
                    return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  if (T === 3)
                    return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  break;
              }
              return null;
            }, v;
          }(), jt = fr;
          function pr(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var hr = Math.pow(2, 32) - 1, Br = function() {
            function v() {
              pr(this, v);
            }
            return v.init = function() {
              v.types = {
                avc1: [],
                // codingname
                avcC: [],
                btrt: [],
                dinf: [],
                dref: [],
                esds: [],
                ftyp: [],
                hdlr: [],
                mdat: [],
                mdhd: [],
                mdia: [],
                mfhd: [],
                minf: [],
                moof: [],
                moov: [],
                mp4a: [],
                ".mp3": [],
                mvex: [],
                mvhd: [],
                pasp: [],
                sdtp: [],
                stbl: [],
                stco: [],
                stsc: [],
                stsd: [],
                stsz: [],
                stts: [],
                tfdt: [],
                tfhd: [],
                traf: [],
                trak: [],
                trun: [],
                trex: [],
                tkhd: [],
                vmhd: [],
                smhd: []
              };
              var b;
              for (b in v.types)
                v.types.hasOwnProperty(b) && (v.types[b] = [b.charCodeAt(0), b.charCodeAt(1), b.charCodeAt(2), b.charCodeAt(3)]);
              var T = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // pre_defined
                118,
                105,
                100,
                101,
                // handler_type: 'vide'
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                86,
                105,
                100,
                101,
                111,
                72,
                97,
                110,
                100,
                108,
                101,
                114,
                0
                // name: 'VideoHandler'
              ]), S = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // pre_defined
                115,
                111,
                117,
                110,
                // handler_type: 'soun'
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                83,
                111,
                117,
                110,
                100,
                72,
                97,
                110,
                100,
                108,
                101,
                114,
                0
                // name: 'SoundHandler'
              ]);
              v.HDLR_TYPES = {
                video: T,
                audio: S
              };
              var L = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                1,
                // entry_count
                0,
                0,
                0,
                12,
                // entry_size
                117,
                114,
                108,
                32,
                // 'url' type
                0,
                // version 0
                0,
                0,
                1
                // entry_flags
              ]), D = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0
                // entry_count
              ]);
              v.STTS = v.STSC = v.STCO = D, v.STSZ = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // sample_size
                0,
                0,
                0,
                0
              ]), v.VMHD = new Uint8Array([
                0,
                // version
                0,
                0,
                1,
                // flags
                0,
                0,
                // graphicsmode
                0,
                0,
                0,
                0,
                0,
                0
                // opcolor
              ]), v.SMHD = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                // balance
                0,
                0
                // reserved
              ]), v.STSD = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                1
              ]);
              var N = new Uint8Array([105, 115, 111, 109]), M = new Uint8Array([97, 118, 99, 49]), W = new Uint8Array([0, 0, 0, 1]);
              v.FTYP = v.box(v.types.ftyp, N, W, N, M), v.DINF = v.box(v.types.dinf, v.box(v.types.dref, L));
            }, v.box = function(b) {
              for (var T = Array.prototype.slice.call(arguments, 1), S = 8, L = T.length, D = L, N; L--; )
                S += T[L].byteLength;
              for (N = new Uint8Array(S), N[0] = S >> 24 & 255, N[1] = S >> 16 & 255, N[2] = S >> 8 & 255, N[3] = S & 255, N.set(b, 4), L = 0, S = 8; L < D; L++)
                N.set(T[L], S), S += T[L].byteLength;
              return N;
            }, v.hdlr = function(b) {
              return v.box(v.types.hdlr, v.HDLR_TYPES[b]);
            }, v.mdat = function(b) {
              return v.box(v.types.mdat, b);
            }, v.mdhd = function(b, T) {
              T *= b;
              var S = Math.floor(T / (hr + 1)), L = Math.floor(T % (hr + 1));
              return v.box(v.types.mdhd, new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                b >> 24 & 255,
                b >> 16 & 255,
                b >> 8 & 255,
                b & 255,
                // timescale
                S >> 24,
                S >> 16 & 255,
                S >> 8 & 255,
                S & 255,
                L >> 24,
                L >> 16 & 255,
                L >> 8 & 255,
                L & 255,
                85,
                196,
                // 'und' language (undetermined)
                0,
                0
              ]));
            }, v.mdia = function(b) {
              return v.box(v.types.mdia, v.mdhd(b.timescale, b.duration), v.hdlr(b.type), v.minf(b));
            }, v.mfhd = function(b) {
              return v.box(
                v.types.mfhd,
                new Uint8Array([
                  0,
                  0,
                  0,
                  0,
                  // flags
                  b >> 24,
                  b >> 16 & 255,
                  b >> 8 & 255,
                  b & 255
                ])
                // sequence_number
              );
            }, v.minf = function(b) {
              return b.type === "audio" ? v.box(v.types.minf, v.box(v.types.smhd, v.SMHD), v.DINF, v.stbl(b)) : v.box(v.types.minf, v.box(v.types.vmhd, v.VMHD), v.DINF, v.stbl(b));
            }, v.moof = function(b, T, S) {
              return v.box(v.types.moof, v.mfhd(b), v.traf(S, T));
            }, v.moov = function(b) {
              for (var T = b.length, S = []; T--; )
                S[T] = v.trak(b[T]);
              return v.box.apply(null, [v.types.moov, v.mvhd(b[0].timescale, b[0].duration)].concat(S).concat(v.mvex(b)));
            }, v.mvex = function(b) {
              for (var T = b.length, S = []; T--; )
                S[T] = v.trex(b[T]);
              return v.box.apply(null, [v.types.mvex].concat(S));
            }, v.mvhd = function(b, T) {
              T *= b;
              var S = Math.floor(T / (hr + 1)), L = Math.floor(T % (hr + 1)), D = new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                b >> 24 & 255,
                b >> 16 & 255,
                b >> 8 & 255,
                b & 255,
                // timescale
                S >> 24,
                S >> 16 & 255,
                S >> 8 & 255,
                S & 255,
                L >> 24,
                L >> 16 & 255,
                L >> 8 & 255,
                L & 255,
                0,
                1,
                0,
                0,
                // 1.0 rate
                1,
                0,
                // 1.0 volume
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                // transformation: unity matrix
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // pre_defined
                255,
                255,
                255,
                255
                // next_track_ID
              ]);
              return v.box(v.types.mvhd, D);
            }, v.sdtp = function(b) {
              var T = b.samples || [], S = new Uint8Array(4 + T.length), L, D;
              for (D = 0; D < T.length; D++)
                L = T[D].flags, S[D + 4] = L.dependsOn << 4 | L.isDependedOn << 2 | L.hasRedundancy;
              return v.box(v.types.sdtp, S);
            }, v.stbl = function(b) {
              return v.box(v.types.stbl, v.stsd(b), v.box(v.types.stts, v.STTS), v.box(v.types.stsc, v.STSC), v.box(v.types.stsz, v.STSZ), v.box(v.types.stco, v.STCO));
            }, v.avc1 = function(b) {
              var T = [], S = [], L, D, N;
              for (L = 0; L < b.sps.length; L++)
                D = b.sps[L], N = D.byteLength, T.push(N >>> 8 & 255), T.push(N & 255), T = T.concat(Array.prototype.slice.call(D));
              for (L = 0; L < b.pps.length; L++)
                D = b.pps[L], N = D.byteLength, S.push(N >>> 8 & 255), S.push(N & 255), S = S.concat(Array.prototype.slice.call(D));
              var M = v.box(v.types.avcC, new Uint8Array([
                1,
                // version
                T[3],
                // profile
                T[4],
                // profile compat
                T[5],
                // level
                255,
                // lengthSizeMinusOne, hard-coded to 4 bytes
                224 | b.sps.length
                // 3bit reserved (111) + numOfSequenceParameterSets
              ].concat(T).concat([
                b.pps.length
                // numOfPictureParameterSets
              ]).concat(S))), W = b.width, Q = b.height, Y = b.pixelRatio[0], ie = b.pixelRatio[1];
              return v.box(
                v.types.avc1,
                new Uint8Array([
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  1,
                  // data_reference_index
                  0,
                  0,
                  // pre_defined
                  0,
                  0,
                  // reserved
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  // pre_defined
                  W >> 8 & 255,
                  W & 255,
                  // width
                  Q >> 8 & 255,
                  Q & 255,
                  // height
                  0,
                  72,
                  0,
                  0,
                  // horizresolution
                  0,
                  72,
                  0,
                  0,
                  // vertresolution
                  0,
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  1,
                  // frame_count
                  18,
                  100,
                  97,
                  105,
                  108,
                  //dailymotion/hls.js
                  121,
                  109,
                  111,
                  116,
                  105,
                  111,
                  110,
                  47,
                  104,
                  108,
                  115,
                  46,
                  106,
                  115,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  // compressorname
                  0,
                  24,
                  // depth = 24
                  17,
                  17
                ]),
                // pre_defined = -1
                M,
                v.box(v.types.btrt, new Uint8Array([
                  0,
                  28,
                  156,
                  128,
                  // bufferSizeDB
                  0,
                  45,
                  198,
                  192,
                  // maxBitrate
                  0,
                  45,
                  198,
                  192
                ])),
                // avgBitrate
                v.box(v.types.pasp, new Uint8Array([
                  Y >> 24,
                  // hSpacing
                  Y >> 16 & 255,
                  Y >> 8 & 255,
                  Y & 255,
                  ie >> 24,
                  // vSpacing
                  ie >> 16 & 255,
                  ie >> 8 & 255,
                  ie & 255
                ]))
              );
            }, v.esds = function(b) {
              var T = b.config.length;
              return new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                3,
                // descriptor_type
                23 + T,
                // length
                0,
                1,
                //es_id
                0,
                // stream_priority
                4,
                // descriptor_type
                15 + T,
                // length
                64,
                //codec : mpeg4_audio
                21,
                // stream_type
                0,
                0,
                0,
                // buffer_size
                0,
                0,
                0,
                0,
                // maxBitrate
                0,
                0,
                0,
                0,
                // avgBitrate
                5
                // descriptor_type
              ].concat([T]).concat(b.config).concat([6, 1, 2]));
            }, v.mp4a = function(b) {
              var T = b.samplerate;
              return v.box(v.types.mp4a, new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                b.channelCount,
                // channelcount
                0,
                16,
                // sampleSize:16bits
                0,
                0,
                0,
                0,
                // reserved2
                T >> 8 & 255,
                T & 255,
                //
                0,
                0
              ]), v.box(v.types.esds, v.esds(b)));
            }, v.mp3 = function(b) {
              var T = b.samplerate;
              return v.box(v.types[".mp3"], new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                b.channelCount,
                // channelcount
                0,
                16,
                // sampleSize:16bits
                0,
                0,
                0,
                0,
                // reserved2
                T >> 8 & 255,
                T & 255,
                //
                0,
                0
              ]));
            }, v.stsd = function(b) {
              return b.type === "audio" ? !b.isAAC && b.codec === "mp3" ? v.box(v.types.stsd, v.STSD, v.mp3(b)) : v.box(v.types.stsd, v.STSD, v.mp4a(b)) : v.box(v.types.stsd, v.STSD, v.avc1(b));
            }, v.tkhd = function(b) {
              var T = b.id, S = b.duration * b.timescale, L = b.width, D = b.height, N = Math.floor(S / (hr + 1)), M = Math.floor(S % (hr + 1));
              return v.box(v.types.tkhd, new Uint8Array([
                1,
                // version 1
                0,
                0,
                7,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                T >> 24 & 255,
                T >> 16 & 255,
                T >> 8 & 255,
                T & 255,
                // track_ID
                0,
                0,
                0,
                0,
                // reserved
                N >> 24,
                N >> 16 & 255,
                N >> 8 & 255,
                N & 255,
                M >> 24,
                M >> 16 & 255,
                M >> 8 & 255,
                M & 255,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                // layer
                0,
                0,
                // alternate_group
                0,
                0,
                // non-audio track volume
                0,
                0,
                // reserved
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                // transformation: unity matrix
                L >> 8 & 255,
                L & 255,
                0,
                0,
                // width
                D >> 8 & 255,
                D & 255,
                0,
                0
                // height
              ]));
            }, v.traf = function(b, T) {
              var S = v.sdtp(b), L = b.id, D = Math.floor(T / (hr + 1)), N = Math.floor(T % (hr + 1));
              return v.box(
                v.types.traf,
                v.box(
                  v.types.tfhd,
                  new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    L >> 24,
                    L >> 16 & 255,
                    L >> 8 & 255,
                    L & 255
                  ])
                  // track_ID
                ),
                v.box(v.types.tfdt, new Uint8Array([
                  1,
                  // version 1
                  0,
                  0,
                  0,
                  // flags
                  D >> 24,
                  D >> 16 & 255,
                  D >> 8 & 255,
                  D & 255,
                  N >> 24,
                  N >> 16 & 255,
                  N >> 8 & 255,
                  N & 255
                ])),
                v.trun(b, S.length + 16 + // tfhd
                20 + // tfdt
                8 + // traf header
                16 + // mfhd
                8 + // moof header
                8),
                // mdat header
                S
              );
            }, v.trak = function(b) {
              return b.duration = b.duration || 4294967295, v.box(v.types.trak, v.tkhd(b), v.mdia(b));
            }, v.trex = function(b) {
              var T = b.id;
              return v.box(v.types.trex, new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                T >> 24,
                T >> 16 & 255,
                T >> 8 & 255,
                T & 255,
                // track_ID
                0,
                0,
                0,
                1,
                // default_sample_description_index
                0,
                0,
                0,
                0,
                // default_sample_duration
                0,
                0,
                0,
                0,
                // default_sample_size
                0,
                1,
                0,
                1
                // default_sample_flags
              ]));
            }, v.trun = function(b, T) {
              var S = b.samples || [], L = S.length, D = 12 + 16 * L, N = new Uint8Array(D), M, W, Q, Y, ie, re;
              for (T += 8 + D, N.set([
                0,
                // version 0
                0,
                15,
                1,
                // flags
                L >>> 24 & 255,
                L >>> 16 & 255,
                L >>> 8 & 255,
                L & 255,
                // sample_count
                T >>> 24 & 255,
                T >>> 16 & 255,
                T >>> 8 & 255,
                T & 255
                // data_offset
              ], 0), M = 0; M < L; M++)
                W = S[M], Q = W.duration, Y = W.size, ie = W.flags, re = W.cts, N.set([
                  Q >>> 24 & 255,
                  Q >>> 16 & 255,
                  Q >>> 8 & 255,
                  Q & 255,
                  // sample_duration
                  Y >>> 24 & 255,
                  Y >>> 16 & 255,
                  Y >>> 8 & 255,
                  Y & 255,
                  // sample_size
                  ie.isLeading << 2 | ie.dependsOn,
                  ie.isDependedOn << 6 | ie.hasRedundancy << 4 | ie.paddingValue << 1 | ie.isNonSync,
                  ie.degradPrio & 61440,
                  ie.degradPrio & 15,
                  // sample_flags
                  re >>> 24 & 255,
                  re >>> 16 & 255,
                  re >>> 8 & 255,
                  re & 255
                  // sample_composition_time_offset
                ], 12 + 16 * M);
              return v.box(v.types.trun, N);
            }, v.initSegment = function(b) {
              v.types || v.init();
              var T = v.moov(b), S;
              return S = new Uint8Array(v.FTYP.byteLength + T.byteLength), S.set(v.FTYP), S.set(T, v.FTYP.byteLength), S;
            }, v;
          }(), kr = Br;
          function ct(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var Tt = 10 * 1e3, Cn = function() {
            function v(I, b, T, S) {
              ct(this, v), this.observer = I, this.config = b, this.typeSupported = T;
              var L = navigator.userAgent;
              this.isSafari = S && S.indexOf("Apple") > -1 && L && !L.match("CriOS"), this.ISGenerated = !1;
            }
            return v.prototype.destroy = function() {
            }, v.prototype.resetTimeStamp = function(b) {
              this._initPTS = this._initDTS = b;
            }, v.prototype.resetInitSegment = function() {
              this.ISGenerated = !1;
            }, v.prototype.remux = function(b, T, S, L, D, N, M) {
              if (this.ISGenerated || this.generateIS(b, T, D), this.ISGenerated) {
                var W = b.samples.length, Q = T.samples.length, Y = D, ie = D;
                if (W && Q) {
                  var re = (b.samples[0].dts - T.samples[0].dts) / T.inputTimeScale;
                  Y += Math.max(0, re), ie += Math.max(0, -re);
                }
                if (W) {
                  b.timescale || (p.b.warn("regenerate InitSegment as audio detected"), this.generateIS(b, T, D));
                  var pe = this.remuxAudio(b, Y, N, M);
                  if (Q) {
                    var ue = void 0;
                    pe && (ue = pe.endPTS - pe.startPTS), T.timescale || (p.b.warn("regenerate InitSegment as video detected"), this.generateIS(b, T, D)), this.remuxVideo(T, ie, N, ue, M);
                  }
                } else {
                  var ce = void 0;
                  Q && (ce = this.remuxVideo(T, ie, N, M)), ce && b.codec && this.remuxEmptyAudio(b, Y, N, ce);
                }
              }
              S.samples.length && this.remuxID3(S, D), L.samples.length && this.remuxText(L, D), this.observer.trigger(c.a.FRAG_PARSED);
            }, v.prototype.generateIS = function(b, T, S) {
              var L = this.observer, D = b.samples, N = T.samples, M = this.typeSupported, W = "audio/mp4", Q = {}, Y = { tracks: Q }, ie = this._initPTS === void 0, re, pe;
              if (ie && (re = pe = 1 / 0), b.config && D.length && (b.timescale = b.samplerate, p.b.log("audio sampling rate : " + b.samplerate), b.isAAC || (M.mpeg ? (W = "audio/mpeg", b.codec = "") : M.mp3 && (b.codec = "mp3")), Q.audio = {
                container: W,
                codec: b.codec,
                initSegment: !b.isAAC && M.mpeg ? new Uint8Array() : kr.initSegment([b]),
                metadata: {
                  channelCount: b.channelCount
                }
              }, ie && (re = pe = D[0].pts - b.inputTimeScale * S)), T.sps && T.pps && N.length) {
                var ue = T.inputTimeScale;
                T.timescale = ue, Q.video = {
                  container: "video/mp4",
                  codec: T.codec,
                  initSegment: kr.initSegment([T]),
                  metadata: {
                    width: T.width,
                    height: T.height
                  }
                }, ie && (re = Math.min(re, N[0].pts - ue * S), pe = Math.min(pe, N[0].dts - ue * S), this.observer.trigger(c.a.INIT_PTS_FOUND, { initPTS: re }));
              }
              Object.keys(Q).length ? (L.trigger(c.a.FRAG_PARSING_INIT_SEGMENT, Y), this.ISGenerated = !0, ie && (this._initPTS = re, this._initDTS = pe)) : L.trigger(c.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: !1, reason: "no audio/video samples found" });
            }, v.prototype.remuxVideo = function(b, T, S, L, D) {
              var N = 8, M = b.timescale, W, Q, Y, ie, re, pe, ue, ce = b.samples, ee = [], Ie = ce.length, Ye = this._PTSNormalize, Je = this._initDTS, Fe = this.nextAvcDts, He = this.isSafari;
              He && (S |= ce.length && Fe && (D && Math.abs(T - Fe / M) < 0.1 || Math.abs(ce[0].pts - Fe - Je) < M / 5)), S || (Fe = T * M), ce.forEach(function(gr) {
                gr.pts = Ye(gr.pts - Je, Fe), gr.dts = Ye(gr.dts - Je, Fe);
              }), ce.sort(function(gr, nn) {
                var zl = gr.dts - nn.dts, Xl = gr.pts - nn.pts;
                return zl || Xl || gr.id - nn.id;
              });
              var Te = ce.reduce(function(gr, nn) {
                return Math.max(Math.min(gr, nn.pts - nn.dts), -18e3);
              }, 0);
              if (Te < 0) {
                p.b.warn("PTS < DTS detected in video samples, shifting DTS by " + Math.round(Te / 90) + " ms to overcome this issue");
                for (var rt = 0; rt < ce.length; rt++)
                  ce[rt].dts += Te;
              }
              var Rt = ce[0];
              re = Math.max(Rt.dts, 0), ie = Math.max(Rt.pts, 0);
              var Qe = Math.round((re - Fe) / 90);
              S && Qe && (Qe > 1 ? p.b.log("AVC:" + Qe + " ms hole between fragments detected,filling it") : Qe < -1 && p.b.log("AVC:" + -Qe + " ms overlapping between fragments detected"), re = Fe, ce[0].dts = re, ie = Math.max(ie - Qe, Fe), ce[0].pts = ie, p.b.log("Video/PTS/DTS adjusted: " + Math.round(ie / 90) + "/" + Math.round(re / 90) + ",delta:" + Qe + " ms")), Rt = ce[ce.length - 1], ue = Math.max(Rt.dts, 0), pe = Math.max(Rt.pts, 0, ue), He && (W = Math.round((ue - re) / (ce.length - 1)));
              for (var gt = 0, Ct = 0, ir = 0; ir < Ie; ir++) {
                for (var Dt = ce[ir], br = Dt.units, zt = br.length, nr = 0, _i = 0; _i < zt; _i++)
                  nr += br[_i].data.length;
                Ct += nr, gt += zt, Dt.length = nr, He ? Dt.dts = re + ir * W : Dt.dts = Math.max(Dt.dts, re), Dt.pts = Math.max(Dt.pts, Dt.dts);
              }
              var wi = Ct + 4 * gt + 8;
              try {
                Q = new Uint8Array(wi);
              } catch {
                this.observer.trigger(c.a.ERROR, { type: h.b.MUX_ERROR, details: h.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: wi, reason: "fail allocating video mdat " + wi });
                return;
              }
              var Sn = new DataView(Q.buffer);
              Sn.setUint32(0, wi), Q.set(kr.types.mdat, 4);
              for (var Xt = 0; Xt < Ie; Xt++) {
                for (var At = ce[Xt], Ir = At.units, Ti = 0, Hr = void 0, Ln = 0, cs = Ir.length; Ln < cs; Ln++) {
                  var kn = Ir[Ln], Dn = kn.data, Zr = kn.data.byteLength;
                  Sn.setUint32(N, Zr), N += 4, Q.set(Dn, N), N += Zr, Ti += 4 + Zr;
                }
                if (He)
                  Hr = Math.max(0, W * Math.round((At.pts - At.dts) / W));
                else {
                  if (Xt < Ie - 1)
                    W = ce[Xt + 1].dts - At.dts;
                  else {
                    var rn = this.config, Ci = At.dts - ce[Xt > 0 ? Xt - 1 : Xt].dts;
                    if (rn.stretchShortVideoTrack) {
                      var ds = rn.maxBufferHole, Wr = rn.maxSeekHole, Qu = Math.floor(Math.min(ds, Wr) * M), Ws = (L ? ie + L * M : this.nextAudioPts) - At.pts;
                      Ws > Qu ? (W = Ws - Ci, W < 0 && (W = Ci), p.b.log("It is approximately " + Ws / 90 + " ms to the next segment; using duration " + W / 90 + " ms for the last video frame.")) : W = Ci;
                    } else
                      W = Ci;
                  }
                  Hr = Math.round(At.pts - At.dts);
                }
                ee.push({
                  size: Ti,
                  // constant duration
                  duration: W,
                  cts: Hr,
                  flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: At.key ? 2 : 1,
                    isNonSync: At.key ? 0 : 1
                  }
                });
              }
              this.nextAvcDts = ue + W;
              var ec = b.dropped;
              if (b.len = 0, b.nbNalu = 0, b.dropped = 0, ee.length && navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                var Gl = ee[0].flags;
                Gl.dependsOn = 2, Gl.isNonSync = 0;
              }
              b.samples = ee, Y = kr.moof(b.sequenceNumber++, re, b), b.samples = [];
              var ql = {
                data1: Y,
                data2: Q,
                startPTS: ie / M,
                endPTS: (pe + W) / M,
                startDTS: re / M,
                endDTS: this.nextAvcDts / M,
                type: "video",
                nb: ee.length,
                dropped: ec
              };
              return this.observer.trigger(c.a.FRAG_PARSING_DATA, ql), ql;
            }, v.prototype.remuxAudio = function(b, T, S, L) {
              var D = b.inputTimeScale, N = b.timescale, M = D / N, W = b.isAAC ? 1024 : 1152, Q = W * M, Y = this._PTSNormalize, ie = this._initDTS, re = !b.isAAC && this.typeSupported.mpeg, pe, ue, ce, ee, Ie, Ye, Je, Fe = b.samples, He = [], Te = this.nextAudioPts;
              if (S |= Fe.length && Te && (L && Math.abs(T - Te / D) < 0.1 || Math.abs(Fe[0].pts - Te - ie) < 20 * Q), Fe.forEach(function(Wr) {
                Wr.pts = Wr.dts = Y(Wr.pts - ie, T * D);
              }), Fe = Fe.filter(function(Wr) {
                return Wr.pts >= 0;
              }), Fe.length !== 0) {
                if (S || (L ? Te = T * D : Te = Fe[0].pts), b.isAAC)
                  for (var rt = this.config.maxAudioFramesDrift, Rt = 0, Qe = Te; Rt < Fe.length; ) {
                    var gt = Fe[Rt], Ct, ir = gt.pts;
                    Ct = ir - Qe;
                    var Dt = Math.abs(1e3 * Ct / D);
                    if (Ct <= -rt * Q)
                      p.b.warn("Dropping 1 audio frame @ " + (Qe / D).toFixed(3) + "s due to " + Math.round(Dt) + " ms overlap."), Fe.splice(Rt, 1), b.len -= gt.unit.length;
                    else if (Ct >= rt * Q && Dt < Tt && Qe) {
                      var br = Math.round(Ct / Q);
                      p.b.warn("Injecting " + br + " audio frame @ " + (Qe / D).toFixed(3) + "s due to " + Math.round(1e3 * Ct / D) + " ms gap.");
                      for (var zt = 0; zt < br; zt++) {
                        var nr = Math.max(Qe, 0);
                        ce = jt.getSilentFrame(b.manifestCodec || b.codec, b.channelCount), ce || (p.b.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), ce = gt.unit.subarray()), Fe.splice(Rt, 0, { unit: ce, pts: nr, dts: nr }), b.len += ce.length, Qe += Q, Rt++;
                      }
                      gt.pts = gt.dts = Qe, Qe += Q, Rt++;
                    } else
                      gt.pts = gt.dts = Qe, Qe += Q, Rt++;
                  }
                for (var _i = 0, wi = Fe.length; _i < wi; _i++) {
                  var Sn = Fe[_i], Xt = Sn.unit, At = Sn.pts;
                  if (Je !== void 0)
                    ue.duration = Math.round((At - Je) / M);
                  else {
                    var Ir = Math.round(1e3 * (At - Te) / D), Ti = 0;
                    if (S && b.isAAC && Ir) {
                      if (Ir > 0 && Ir < Tt)
                        Ti = Math.round((At - Te) / Q), p.b.log(Ir + " ms hole between AAC samples detected,filling it"), Ti > 0 && (ce = jt.getSilentFrame(b.manifestCodec || b.codec, b.channelCount), ce || (ce = Xt.subarray()), b.len += Ti * ce.length);
                      else if (Ir < -12) {
                        p.b.log("drop overlapping AAC sample, expected/parsed/delta:" + (Te / D).toFixed(3) + "s/" + (At / D).toFixed(3) + "s/" + -Ir + "ms"), b.len -= Xt.byteLength;
                        continue;
                      }
                      At = Te;
                    }
                    if (Ye = At, b.len > 0) {
                      var Hr = re ? b.len : b.len + 8;
                      pe = re ? 0 : 8;
                      try {
                        ee = new Uint8Array(Hr);
                      } catch {
                        this.observer.trigger(c.a.ERROR, { type: h.b.MUX_ERROR, details: h.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: Hr, reason: "fail allocating audio mdat " + Hr });
                        return;
                      }
                      if (!re) {
                        var Ln = new DataView(ee.buffer);
                        Ln.setUint32(0, Hr), ee.set(kr.types.mdat, 4);
                      }
                    } else
                      return;
                    for (var cs = 0; cs < Ti; cs++)
                      ce = jt.getSilentFrame(b.manifestCodec || b.codec, b.channelCount), ce || (p.b.log("Unable to get silent frame for given audio codec; duplicating this frame instead."), ce = Xt.subarray()), ee.set(ce, pe), pe += ce.byteLength, ue = {
                        size: ce.byteLength,
                        cts: 0,
                        duration: 1024,
                        flags: {
                          isLeading: 0,
                          isDependedOn: 0,
                          hasRedundancy: 0,
                          degradPrio: 0,
                          dependsOn: 1
                        }
                      }, He.push(ue);
                  }
                  ee.set(Xt, pe);
                  var kn = Xt.byteLength;
                  pe += kn, ue = {
                    size: kn,
                    cts: 0,
                    duration: 0,
                    flags: {
                      isLeading: 0,
                      isDependedOn: 0,
                      hasRedundancy: 0,
                      degradPrio: 0,
                      dependsOn: 1
                    }
                  }, He.push(ue), Je = At;
                }
                var Dn = 0, Zr = He.length;
                if (Zr >= 2 && (Dn = He[Zr - 2].duration, ue.duration = Dn), Zr) {
                  this.nextAudioPts = Te = Je + M * Dn, b.len = 0, b.samples = He, re ? Ie = new Uint8Array() : Ie = kr.moof(b.sequenceNumber++, Ye / M, b), b.samples = [];
                  var rn = Ye / D, Ci = Te / D, ds = {
                    data1: Ie,
                    data2: ee,
                    startPTS: rn,
                    endPTS: Ci,
                    startDTS: rn,
                    endDTS: Ci,
                    type: "audio",
                    nb: Zr
                  };
                  return this.observer.trigger(c.a.FRAG_PARSING_DATA, ds), ds;
                }
                return null;
              }
            }, v.prototype.remuxEmptyAudio = function(b, T, S, L) {
              var D = b.inputTimeScale, N = b.samplerate ? b.samplerate : D, M = D / N, W = this.nextAudioPts, Q = (W !== void 0 ? W : L.startDTS * D) + this._initDTS, Y = L.endDTS * D + this._initDTS, ie = 1024, re = M * ie, pe = Math.ceil((Y - Q) / re), ue = jt.getSilentFrame(b.manifestCodec || b.codec, b.channelCount);
              if (p.b.warn("remux empty Audio"), !ue) {
                p.b.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!");
                return;
              }
              for (var ce = [], ee = 0; ee < pe; ee++) {
                var Ie = Q + ee * re;
                ce.push({ unit: ue, pts: Ie, dts: Ie }), b.len += ue.length;
              }
              b.samples = ce, this.remuxAudio(b, T, S);
            }, v.prototype.remuxID3 = function(b, T) {
              var S = b.samples.length, L, D = b.inputTimeScale, N = this._initPTS, M = this._initDTS;
              if (S) {
                for (var W = 0; W < S; W++)
                  L = b.samples[W], L.pts = (L.pts - N) / D, L.dts = (L.dts - M) / D;
                this.observer.trigger(c.a.FRAG_PARSING_METADATA, {
                  samples: b.samples
                });
              }
              b.samples = [];
            }, v.prototype.remuxText = function(b, T) {
              b.samples.sort(function(W, Q) {
                return W.pts - Q.pts;
              });
              var S = b.samples.length, L, D = b.inputTimeScale, N = this._initPTS;
              if (S) {
                for (var M = 0; M < S; M++)
                  L = b.samples[M], L.pts = (L.pts - N) / D;
                this.observer.trigger(c.a.FRAG_PARSING_USERDATA, {
                  samples: b.samples
                });
              }
              b.samples = [];
            }, v.prototype._PTSNormalize = function(b, T) {
              var S;
              if (T === void 0)
                return b;
              for (T < b ? S = -8589934592 : S = 8589934592; Math.abs(b - T) > 4294967296; )
                b += S;
              return b;
            }, v;
          }(), rr = Cn;
          function Wu(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var Yu = function() {
            function v(I) {
              Wu(this, v), this.observer = I;
            }
            return v.prototype.destroy = function() {
            }, v.prototype.resetTimeStamp = function() {
            }, v.prototype.resetInitSegment = function() {
            }, v.prototype.remux = function(b, T, S, L, D, N, M, W) {
              var Q = this.observer, Y = "";
              b && (Y += "audio"), T && (Y += "video"), Q.trigger(c.a.FRAG_PARSING_DATA, {
                data1: W,
                startPTS: D,
                startDTS: D,
                type: Y,
                nb: 1,
                dropped: 0
              }), Q.trigger(c.a.FRAG_PARSED);
            }, v;
          }(), Hs = Yu;
          function Ju(v, I) {
            if (!(v instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var Zs = function() {
            function v(I, b, T, S) {
              Ju(this, v), this.observer = I, this.typeSupported = b, this.config = T, this.vendor = S;
            }
            return v.prototype.destroy = function() {
              var b = this.demuxer;
              b && b.destroy();
            }, v.prototype.push = function(b, T, S, L, D, N, M, W, Q, Y, ie, re) {
              if (b.byteLength > 0 && T != null && T.key != null && T.method === "AES-128") {
                var pe = this.decrypter;
                pe == null && (pe = this.decrypter = new m.a(this.observer, this.config));
                var ue = this, ce;
                try {
                  ce = performance.now();
                } catch {
                  ce = Date.now();
                }
                pe.decrypt(b, T.key.buffer, T.iv.buffer, function(ee) {
                  var Ie;
                  try {
                    Ie = performance.now();
                  } catch {
                    Ie = Date.now();
                  }
                  ue.observer.trigger(c.a.FRAG_DECRYPTED, { stats: { tstart: ce, tdecrypt: Ie } }), ue.pushDecrypted(new Uint8Array(ee), T, new Uint8Array(S), L, D, N, M, W, Q, Y, ie, re);
                });
              } else
                this.pushDecrypted(new Uint8Array(b), T, new Uint8Array(S), L, D, N, M, W, Q, Y, ie, re);
            }, v.prototype.pushDecrypted = function(b, T, S, L, D, N, M, W, Q, Y, ie, re) {
              var pe = this.demuxer;
              if (!pe || // in case of continuity change, we might switch from content type (AAC container to TS container for example)
              // so let's check that current demuxer is still valid
              M && !this.probe(b)) {
                for (var ue = this.observer, ce = this.typeSupported, ee = this.config, Ie = [{ demux: Ge, remux: rr }, { demux: Be, remux: Hs }, { demux: se, remux: rr }, { demux: tn, remux: rr }], Ye = 0, Je = Ie.length; Ye < Je; Ye++) {
                  var Fe = Ie[Ye], He = Fe.demux.probe;
                  if (He(b)) {
                    var Te = this.remuxer = new Fe.remux(ue, ee, ce, this.vendor);
                    pe = new Fe.demux(ue, Te, ee, ce), this.probe = He;
                    break;
                  }
                }
                if (!pe) {
                  ue.trigger(c.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: !0, reason: "no demux matching with content found" });
                  return;
                }
                this.demuxer = pe;
              }
              var rt = this.remuxer;
              (M || W) && (pe.resetInitSegment(S, L, D, Y), rt.resetInitSegment()), M && (pe.resetTimeStamp(re), rt.resetTimeStamp(re)), typeof pe.setDecryptData == "function" && pe.setDecryptData(T), pe.append(b, N, Q, ie);
            }, v;
          }();
          i.a = Zs;
        },
        /* 8 */
        /***/
        function(r, i, a) {
          Object.defineProperty(i, "__esModule", { value: !0 });
          var c = {};
          a.d(c, "newCue", function() {
            return gy;
          });
          var h = a(6), m = /* @__PURE__ */ a.n(h), p = a(1), y = a(2), d = a(0), A = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          };
          function B(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var K = function() {
            function g(l) {
              B(this, g), this.hls = l, this.onEvent = this.onEvent.bind(this);
              for (var o = arguments.length, s = Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
                s[u - 1] = arguments[u];
              this.handledEvents = s, this.useGenericHandler = !0, this.registerListeners();
            }
            return g.prototype.destroy = function() {
              this.unregisterListeners();
            }, g.prototype.isEventHandler = function() {
              return A(this.handledEvents) === "object" && this.handledEvents.length && typeof this.onEvent == "function";
            }, g.prototype.registerListeners = function() {
              this.isEventHandler() && this.handledEvents.forEach(function(o) {
                if (o === "hlsEventGeneric")
                  throw new Error("Forbidden event name: " + o);
                this.hls.on(o, this.onEvent);
              }, this);
            }, g.prototype.unregisterListeners = function() {
              this.isEventHandler() && this.handledEvents.forEach(function(o) {
                this.hls.off(o, this.onEvent);
              }, this);
            }, g.prototype.onEvent = function(o, s) {
              this.onEventGeneric(o, s);
            }, g.prototype.onEventGeneric = function(o, s) {
              var u = function(E, w) {
                var R = "on" + E.replace("hls", "");
                if (typeof this[R] != "function")
                  throw new Error("Event " + E + " has no generic handler in this " + this.constructor.name + " class (tried " + R + ")");
                return this[R].bind(this, w);
              };
              try {
                u.call(this, o, s).call();
              } catch (f) {
                d.b.error("internal error happened while processing " + o + ":" + f.message), this.hls.trigger(p.a.ERROR, { type: y.b.OTHER_ERROR, details: y.a.INTERNAL_EXCEPTION, fatal: !1, event: o, err: f });
              }
            }, g;
          }(), O = K;
          function z(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var X = /^(\d+)x(\d+)$/, H = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g, V = function() {
            function g(l) {
              z(this, g), typeof l == "string" && (l = g.parseAttrList(l));
              for (var o in l)
                l.hasOwnProperty(o) && (this[o] = l[o]);
            }
            return g.prototype.decimalInteger = function(o) {
              var s = parseInt(this[o], 10);
              return s > Number.MAX_SAFE_INTEGER ? 1 / 0 : s;
            }, g.prototype.hexadecimalInteger = function(o) {
              if (this[o]) {
                var s = (this[o] || "0x").slice(2);
                s = (s.length & 1 ? "0" : "") + s;
                for (var u = new Uint8Array(s.length / 2), f = 0; f < s.length / 2; f++)
                  u[f] = parseInt(s.slice(f * 2, f * 2 + 2), 16);
                return u;
              } else
                return null;
            }, g.prototype.hexadecimalIntegerAsNumber = function(o) {
              var s = parseInt(this[o], 16);
              return s > Number.MAX_SAFE_INTEGER ? 1 / 0 : s;
            }, g.prototype.decimalFloatingPoint = function(o) {
              return parseFloat(this[o]);
            }, g.prototype.enumeratedString = function(o) {
              return this[o];
            }, g.prototype.decimalResolution = function(o) {
              var s = X.exec(this[o]);
              if (s !== null)
                return {
                  width: parseInt(s[1], 10),
                  height: parseInt(s[2], 10)
                };
            }, g.parseAttrList = function(o) {
              var s, u = {};
              for (H.lastIndex = 0; (s = H.exec(o)) !== null; ) {
                var f = s[2], E = '"';
                f.indexOf(E) === 0 && f.lastIndexOf(E) === f.length - 1 && (f = f.slice(1, -1)), u[s[1]] = f;
              }
              return u;
            }, g;
          }(), G = V, Z = {
            audio: {
              a3ds: !0,
              "ac-3": !0,
              "ac-4": !0,
              alac: !0,
              alaw: !0,
              dra1: !0,
              "dts+": !0,
              "dts-": !0,
              dtsc: !0,
              dtse: !0,
              dtsh: !0,
              "ec-3": !0,
              enca: !0,
              g719: !0,
              g726: !0,
              m4ae: !0,
              mha1: !0,
              mha2: !0,
              mhm1: !0,
              mhm2: !0,
              mlpa: !0,
              mp4a: !0,
              "raw ": !0,
              Opus: !0,
              samr: !0,
              sawb: !0,
              sawp: !0,
              sevc: !0,
              sqcp: !0,
              ssmv: !0,
              twos: !0,
              ulaw: !0
            },
            video: {
              avc1: !0,
              avc2: !0,
              avc3: !0,
              avc4: !0,
              avcp: !0,
              drac: !0,
              dvav: !0,
              dvhe: !0,
              encv: !0,
              hev1: !0,
              hvc1: !0,
              mjp2: !0,
              mp4v: !0,
              mvc1: !0,
              mvc2: !0,
              mvc3: !0,
              mvc4: !0,
              resv: !0,
              rv60: !0,
              s263: !0,
              svc1: !0,
              svc2: !0,
              "vc-1": !0,
              vp08: !0,
              vp09: !0
            }
          };
          function ae(g, l) {
            var o = Z[l];
            return !!o && o[g.slice(0, 4)] === !0;
          }
          function se(g, l) {
            return MediaSource.isTypeSupported((l || "video") + '/mp4;codecs="' + g + '"');
          }
          var be = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function me(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Ae(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          function Be(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ue = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g, lt = /#EXT-X-MEDIA:(.*)/g, xt = new RegExp([
            /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
            // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
            /|(?!#)(\S+)/.source,
            // segment URI, group 3 => the URI (note newline is not eaten)
            /|#EXT-X-BYTERANGE:*(.+)/.source,
            // next segment's byterange, group 4 => range spec (x@y)
            /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
            // next segment's program date/time group 5 => the datetime spec
            /|#.*/.source
            // All other non-segment oriented tags will match with all groups empty
          ].join(""), "g"), ut = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/, qt = function() {
            function g() {
              Be(this, g), this.method = null, this.key = null, this.iv = null, this._uri = null;
            }
            return be(g, [{
              key: "uri",
              get: function() {
                return !this._uri && this.reluri && (this._uri = m.a.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: !0 })), this._uri;
              }
            }]), g;
          }(), tt = function() {
            function g() {
              Be(this, g), this._url = null, this._byteRange = null, this._decryptdata = null, this.tagList = [];
            }
            return g.prototype.createInitializationVector = function(o) {
              for (var s = new Uint8Array(16), u = 12; u < 16; u++)
                s[u] = o >> 8 * (15 - u) & 255;
              return s;
            }, g.prototype.fragmentDecryptdataFromLevelkey = function(o, s) {
              var u = o;
              return o && o.method && o.uri && !o.iv && (u = new qt(), u.method = o.method, u.baseuri = o.baseuri, u.reluri = o.reluri, u.iv = this.createInitializationVector(s)), u;
            }, g.prototype.cloneObj = function(o) {
              return JSON.parse(JSON.stringify(o));
            }, be(g, [{
              key: "url",
              get: function() {
                return !this._url && this.relurl && (this._url = m.a.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url;
              },
              set: function(o) {
                this._url = o;
              }
            }, {
              key: "programDateTime",
              get: function() {
                return !this._programDateTime && this.rawProgramDateTime && (this._programDateTime = new Date(Date.parse(this.rawProgramDateTime))), this._programDateTime;
              }
            }, {
              key: "byteRange",
              get: function() {
                if (!this._byteRange) {
                  var o = this._byteRange = [];
                  if (this.rawByteRange) {
                    var s = this.rawByteRange.split("@", 2);
                    if (s.length === 1) {
                      var u = this.lastByteRangeEndOffset;
                      o[0] = u || 0;
                    } else
                      o[0] = parseInt(s[1]);
                    o[1] = parseInt(s[0]) + o[0];
                  }
                }
                return this._byteRange;
              }
            }, {
              key: "byteRangeStartOffset",
              get: function() {
                return this.byteRange[0];
              }
            }, {
              key: "byteRangeEndOffset",
              get: function() {
                return this.byteRange[1];
              }
            }, {
              key: "decryptdata",
              get: function() {
                return this._decryptdata || (this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn)), this._decryptdata;
              }
            }]), g;
          }();
          function Et(g, l) {
            if (!g)
              return null;
            for (var o = null, s = 0; s < g.length; s++) {
              var u = g[s];
              u.id === l && (o = u);
            }
            return o;
          }
          var Vt = function(g) {
            Ae(l, g);
            function l(o) {
              Be(this, l);
              var s = me(this, g.call(this, o, p.a.MANIFEST_LOADING, p.a.LEVEL_LOADING, p.a.AUDIO_TRACK_LOADING, p.a.SUBTITLE_TRACK_LOADING));
              return s.loaders = {}, s;
            }
            return l.prototype.destroy = function() {
              for (var s in this.loaders) {
                var u = this.loaders[s];
                u && u.destroy();
              }
              this.loaders = {}, O.prototype.destroy.call(this);
            }, l.prototype.onManifestLoading = function(s) {
              this.load(s.url, { type: "manifest" });
            }, l.prototype.onLevelLoading = function(s) {
              this.load(s.url, { type: "level", level: s.level, id: s.id });
            }, l.prototype.onAudioTrackLoading = function(s) {
              this.load(s.url, { type: "audioTrack", id: s.id });
            }, l.prototype.onSubtitleTrackLoading = function(s) {
              this.load(s.url, { type: "subtitleTrack", id: s.id });
            }, l.prototype.load = function(s, u) {
              var f = this.loaders[u.type];
              if (f !== void 0) {
                var E = f.context;
                if (E && E.url === s) {
                  d.b.trace("playlist request ongoing");
                  return;
                } else
                  d.b.warn("abort previous loader for type:" + u.type), f.abort();
              }
              var w = this.hls.config, R = void 0, C = void 0, k = void 0, P = void 0;
              u.type === "manifest" ? (R = w.manifestLoadingMaxRetry, C = w.manifestLoadingTimeOut, k = w.manifestLoadingRetryDelay, P = w.manifestLoadingMaxRetryTimeout) : u.type === "level" ? (R = 0, C = w.levelLoadingTimeOut) : (R = w.levelLoadingMaxRetry, C = w.levelLoadingTimeOut, k = w.levelLoadingRetryDelay, P = w.levelLoadingMaxRetryTimeout, d.b.log("loading playlist for " + u.type + " " + (u.level || u.id))), f = this.loaders[u.type] = u.loader = typeof w.pLoader < "u" ? new w.pLoader(w) : new w.loader(w), u.url = s, u.responseType = "";
              var U = void 0, F = void 0;
              U = { timeout: C, maxRetry: R, retryDelay: k, maxRetryDelay: P }, F = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }, f.load(u, U, F);
            }, l.prototype.resolve = function(s, u) {
              return m.a.buildAbsoluteURL(u, s, { alwaysNormalize: !0 });
            }, l.prototype.parseMasterPlaylist = function(s, u) {
              var f = [], E = void 0;
              Ue.lastIndex = 0;
              function w(P, U) {
                ["video", "audio"].forEach(function(F) {
                  var te = P.filter(function(xe) {
                    return ae(xe, F);
                  });
                  if (te.length) {
                    var he = te.filter(function(xe) {
                      return xe.lastIndexOf("avc1", 0) === 0 || xe.lastIndexOf("mp4a", 0) === 0;
                    });
                    U[F + "Codec"] = he.length > 0 ? he[0] : te[0], P = P.filter(function(xe) {
                      return te.indexOf(xe) === -1;
                    });
                  }
                }), U.unknownCodecs = P;
              }
              for (; (E = Ue.exec(s)) != null; ) {
                var R = {}, C = R.attrs = new G(E[1]);
                R.url = this.resolve(E[2], u);
                var k = C.decimalResolution("RESOLUTION");
                k && (R.width = k.width, R.height = k.height), R.bitrate = C.decimalInteger("AVERAGE-BANDWIDTH") || C.decimalInteger("BANDWIDTH"), R.name = C.NAME, w([].concat((C.CODECS || "").split(/[ ,]+/)), R), R.videoCodec && R.videoCodec.indexOf("avc1") !== -1 && (R.videoCodec = this.avc1toavcoti(R.videoCodec)), f.push(R);
              }
              return f;
            }, l.prototype.parseMasterPlaylistMedia = function(s, u, f) {
              var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], w = void 0, R = [], C = 0;
              for (lt.lastIndex = 0; (w = lt.exec(s)) !== null; ) {
                var k = {}, P = new G(w[1]);
                if (P.TYPE === f) {
                  if (k.groupId = P["GROUP-ID"], k.name = P.NAME, k.type = f, k.default = P.DEFAULT === "YES", k.autoselect = P.AUTOSELECT === "YES", k.forced = P.FORCED === "YES", P.URI && (k.url = this.resolve(P.URI, u)), k.lang = P.LANGUAGE, k.name || (k.name = k.lang), E.length) {
                    var U = Et(E, k.groupId);
                    k.audioCodec = U ? U.codec : E[0].codec;
                  }
                  k.id = C++, R.push(k);
                }
              }
              return R;
            }, l.prototype.avc1toavcoti = function(s) {
              var u, f = s.split(".");
              return f.length > 2 ? (u = f.shift() + ".", u += parseInt(f.shift()).toString(16), u += ("000" + parseInt(f.shift()).toString(16)).substr(-4)) : u = s, u;
            }, l.prototype.parseLevelPlaylist = function(s, u, f, E) {
              var w = 0, R = 0, C = { type: null, version: null, url: u, fragments: [], live: !0, startSN: 0 }, k = new qt(), P = 0, U = null, F = new tt(), te, he;
              for (xt.lastIndex = 0; (te = xt.exec(s)) !== null; ) {
                var xe = te[1];
                if (xe) {
                  F.duration = parseFloat(xe);
                  var ge = (" " + te[2]).slice(1);
                  F.title = ge || null, F.tagList.push(ge ? ["INF", xe, ge] : ["INF", xe]);
                } else if (te[3]) {
                  if (!isNaN(F.duration)) {
                    var Ce = w++;
                    F.type = E, F.start = R, F.levelkey = k, F.sn = Ce, F.level = f, F.cc = P, F.baseurl = u, F.relurl = (" " + te[3]).slice(1), C.fragments.push(F), U = F, R += F.duration, F = new tt();
                  }
                } else if (te[4]) {
                  if (F.rawByteRange = (" " + te[4]).slice(1), U) {
                    var Se = U.byteRangeEndOffset;
                    Se && (F.lastByteRangeEndOffset = Se);
                  }
                } else if (te[5])
                  F.rawProgramDateTime = (" " + te[5]).slice(1), F.tagList.push(["PROGRAM-DATE-TIME", F.rawProgramDateTime]), C.programDateTime === void 0 && (C.programDateTime = new Date(new Date(Date.parse(te[5])) - 1e3 * R));
                else {
                  for (te = te[0].match(ut), he = 1; he < te.length && te[he] === void 0; he++)
                    ;
                  var Pe = (" " + te[he + 1]).slice(1), Xe = (" " + te[he + 2]).slice(1);
                  switch (te[he]) {
                    case "#":
                      F.tagList.push(Xe ? [Pe, Xe] : [Pe]);
                      break;
                    case "PLAYLIST-TYPE":
                      C.type = Pe.toUpperCase();
                      break;
                    case "MEDIA-SEQUENCE":
                      w = C.startSN = parseInt(Pe);
                      break;
                    case "TARGETDURATION":
                      C.targetduration = parseFloat(Pe);
                      break;
                    case "VERSION":
                      C.version = parseInt(Pe);
                      break;
                    case "EXTM3U":
                      break;
                    case "ENDLIST":
                      C.live = !1;
                      break;
                    case "DIS":
                      P++, F.tagList.push(["DIS"]);
                      break;
                    case "DISCONTINUITY-SEQ":
                      P = parseInt(Pe);
                      break;
                    case "KEY":
                      var dt = Pe, _e = new G(dt), Pt = _e.enumeratedString("METHOD"), it = _e.URI, sn = _e.hexadecimalInteger("IV");
                      Pt && (k = new qt(), it && ["AES-128", "SAMPLE-AES"].indexOf(Pt) >= 0 && (k.method = Pt, k.baseuri = u, k.reluri = it, k.key = null, k.iv = sn));
                      break;
                    case "START":
                      var ze = Pe, Me = new G(ze), Ft = Me.decimalFloatingPoint("TIME-OFFSET");
                      isNaN(Ft) || (C.startTimeOffset = Ft);
                      break;
                    case "MAP":
                      var Wl = new G(Pe);
                      F.relurl = Wl.URI, F.rawByteRange = Wl.BYTERANGE, F.baseurl = u, F.level = f, F.type = E, F.sn = "initSegment", C.initSegment = F, F = new tt();
                      break;
                    default:
                      d.b.warn("line parsed but not handled: " + te);
                      break;
                  }
                }
              }
              return F = U, F && !F.relurl && (C.fragments.pop(), R -= F.duration), C.totalduration = R, C.averagetargetduration = R / C.fragments.length, C.endSN = w - 1, C.startCC = C.fragments[0] ? C.fragments[0].cc : 0, C.endCC = P, C;
            }, l.prototype.loadsuccess = function(s, u, f) {
              var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = s.data, R = s.url, C = f.type, k = f.id, P = f.level, U = this.hls;
              if (this.loaders[C] = void 0, (R === void 0 || R.indexOf("data:") === 0) && (R = f.url), u.tload = performance.now(), w.indexOf("#EXTM3U") === 0)
                if (w.indexOf("#EXTINF:") > 0) {
                  var F = C !== "audioTrack" && C !== "subtitleTrack", te = isNaN(P) ? isNaN(k) ? 0 : k : P, he = this.parseLevelPlaylist(w, R, te, C === "audioTrack" ? "audio" : C === "subtitleTrack" ? "subtitle" : "main");
                  he.tload = u.tload, C === "manifest" && U.trigger(p.a.MANIFEST_LOADED, { levels: [{ url: R, details: he }], audioTracks: [], url: R, stats: u, networkDetails: E }), u.tparsed = performance.now(), he.targetduration ? F ? U.trigger(p.a.LEVEL_LOADED, { details: he, level: P || 0, id: k || 0, stats: u, networkDetails: E }) : C === "audioTrack" ? U.trigger(p.a.AUDIO_TRACK_LOADED, { details: he, id: k, stats: u, networkDetails: E }) : C === "subtitleTrack" && U.trigger(p.a.SUBTITLE_TRACK_LOADED, { details: he, id: k, stats: u, networkDetails: E }) : U.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: y.a.MANIFEST_PARSING_ERROR, fatal: !0, url: R, reason: "invalid targetduration", networkDetails: E });
                } else {
                  var xe = this.parseMasterPlaylist(w, R);
                  if (xe.length) {
                    var ge = xe.map(function(Xe) {
                      return { id: Xe.attrs.AUDIO, codec: Xe.audioCodec };
                    }), Ce = this.parseMasterPlaylistMedia(w, R, "AUDIO", ge), Se = this.parseMasterPlaylistMedia(w, R, "SUBTITLES");
                    if (Ce.length) {
                      var Pe = !1;
                      Ce.forEach(function(Xe) {
                        Xe.url || (Pe = !0);
                      }), Pe === !1 && xe[0].audioCodec && !xe[0].attrs.AUDIO && (d.b.log("audio codec signaled in quality level, but no embedded audio track signaled, create one"), Ce.unshift({ type: "main", name: "main" }));
                    }
                    U.trigger(p.a.MANIFEST_LOADED, { levels: xe, audioTracks: Ce, subtitles: Se, url: R, stats: u, networkDetails: E });
                  } else
                    U.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: y.a.MANIFEST_PARSING_ERROR, fatal: !0, url: R, reason: "no level found in manifest", networkDetails: E });
                }
              else
                U.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: y.a.MANIFEST_PARSING_ERROR, fatal: !0, url: R, reason: "no EXTM3U delimiter", networkDetails: E });
            }, l.prototype.loaderror = function(s, u) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, E, w, R = u.loader;
              switch (u.type) {
                case "manifest":
                  E = y.a.MANIFEST_LOAD_ERROR, w = !0;
                  break;
                case "level":
                  E = y.a.LEVEL_LOAD_ERROR, w = !1;
                  break;
                case "audioTrack":
                  E = y.a.AUDIO_TRACK_LOAD_ERROR, w = !1;
                  break;
              }
              R && (R.abort(), this.loaders[u.type] = void 0), this.hls.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: E, fatal: w, url: R.url, loader: R, response: s, context: u, networkDetails: f });
            }, l.prototype.loadtimeout = function(s, u) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, E, w, R = u.loader;
              switch (u.type) {
                case "manifest":
                  E = y.a.MANIFEST_LOAD_TIMEOUT, w = !0;
                  break;
                case "level":
                  E = y.a.LEVEL_LOAD_TIMEOUT, w = !1;
                  break;
                case "audioTrack":
                  E = y.a.AUDIO_TRACK_LOAD_TIMEOUT, w = !1;
                  break;
              }
              R && (R.abort(), this.loaders[u.type] = void 0), this.hls.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: E, fatal: w, url: R.url, loader: R, context: u, networkDetails: f });
            }, l;
          }(O), vt = Vt;
          function at(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function kt(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Ge(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var Pr = function(g) {
            Ge(l, g);
            function l(o) {
              at(this, l);
              var s = kt(this, g.call(this, o, p.a.FRAG_LOADING));
              return s.loaders = {}, s;
            }
            return l.prototype.destroy = function() {
              var s = this.loaders;
              for (var u in s) {
                var f = s[u];
                f && f.destroy();
              }
              this.loaders = {}, O.prototype.destroy.call(this);
            }, l.prototype.onFragLoading = function(s) {
              var u = s.frag, f = u.type, E = this.loaders[f], w = this.hls.config;
              u.loaded = 0, E && (d.b.warn("abort previous fragment loader for type:" + f), E.abort()), E = this.loaders[f] = u.loader = typeof w.fLoader < "u" ? new w.fLoader(w) : new w.loader(w);
              var R = void 0, C = void 0, k = void 0;
              R = { url: u.url, frag: u, responseType: "arraybuffer", progressData: !1 };
              var P = u.byteRangeStartOffset, U = u.byteRangeEndOffset;
              !isNaN(P) && !isNaN(U) && (R.rangeStart = P, R.rangeEnd = U), C = { timeout: w.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: w.fragLoadingMaxRetryTimeout }, k = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) }, E.load(R, C, k);
            }, l.prototype.loadsuccess = function(s, u, f) {
              var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = s.data, R = f.frag;
              R.loader = void 0, this.loaders[R.type] = void 0, this.hls.trigger(p.a.FRAG_LOADED, { payload: w, frag: R, stats: u, networkDetails: E });
            }, l.prototype.loaderror = function(s, u) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, E = u.loader;
              E && E.abort(), this.loaders[u.type] = void 0, this.hls.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: y.a.FRAG_LOAD_ERROR, fatal: !1, frag: u.frag, response: s, networkDetails: f });
            }, l.prototype.loadtimeout = function(s, u) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, E = u.loader;
              E && E.abort(), this.loaders[u.type] = void 0, this.hls.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: y.a.FRAG_LOAD_TIMEOUT, fatal: !1, frag: u.frag, networkDetails: f });
            }, l.prototype.loadprogress = function(s, u, f) {
              var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = u.frag;
              w.loaded = s.loaded, this.hls.trigger(p.a.FRAG_LOAD_PROGRESS, { frag: w, stats: s, networkDetails: E });
            }, l;
          }(O), ot = Pr;
          function tn(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function dr(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function fr(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var jt = function(g) {
            fr(l, g);
            function l(o) {
              tn(this, l);
              var s = dr(this, g.call(this, o, p.a.KEY_LOADING));
              return s.loaders = {}, s.decryptkey = null, s.decrypturl = null, s;
            }
            return l.prototype.destroy = function() {
              for (var s in this.loaders) {
                var u = this.loaders[s];
                u && u.destroy();
              }
              this.loaders = {}, O.prototype.destroy.call(this);
            }, l.prototype.onKeyLoading = function(s) {
              var u = s.frag, f = u.type, E = this.loaders[f], w = u.decryptdata, R = w.uri;
              if (R !== this.decrypturl || this.decryptkey === null) {
                var C = this.hls.config;
                E && (d.b.warn("abort previous key loader for type:" + f), E.abort()), u.loader = this.loaders[f] = new C.loader(C), this.decrypturl = R, this.decryptkey = null;
                var k = void 0, P = void 0, U = void 0;
                k = { url: R, frag: u, responseType: "arraybuffer" }, P = { timeout: C.fragLoadingTimeOut, maxRetry: C.fragLoadingMaxRetry, retryDelay: C.fragLoadingRetryDelay, maxRetryDelay: C.fragLoadingMaxRetryTimeout }, U = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }, u.loader.load(k, P, U);
              } else this.decryptkey && (w.key = this.decryptkey, this.hls.trigger(p.a.KEY_LOADED, { frag: u }));
            }, l.prototype.loadsuccess = function(s, u, f) {
              var E = f.frag;
              this.decryptkey = E.decryptdata.key = new Uint8Array(s.data), E.loader = void 0, this.loaders[E.type] = void 0, this.hls.trigger(p.a.KEY_LOADED, { frag: E });
            }, l.prototype.loaderror = function(s, u) {
              var f = u.frag, E = f.loader;
              E && E.abort(), this.loaders[u.type] = void 0, this.hls.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: y.a.KEY_LOAD_ERROR, fatal: !1, frag: f, response: s });
            }, l.prototype.loadtimeout = function(s, u) {
              var f = u.frag, E = f.loader;
              E && E.abort(), this.loaders[u.type] = void 0, this.hls.trigger(p.a.ERROR, { type: y.b.NETWORK_ERROR, details: y.a.KEY_LOAD_TIMEOUT, fatal: !1, frag: f });
            }, l;
          }(O), pr = jt, hr = {
            /**
             * Searches for an item in an array which matches a certain condition.
             * This requires the condition to only match one item in the array,
             * and for the array to be ordered.
             *
             * @param {Array} list The array to search.
             * @param {Function} comparisonFunction
             *      Called and provided a candidate item as the first argument.
             *      Should return:
             *          > -1 if the item should be located at a lower index than the provided item.
             *          > 1 if the item should be located at a higher index than the provided item.
             *          > 0 if the item is the item you're looking for.
             *
             * @return {*} The object if it is found or null otherwise.
             */
            search: function(l, o) {
              for (var s = 0, u = l.length - 1, f = null, E = null; s <= u; ) {
                f = (s + u) / 2 | 0, E = l[f];
                var w = o(E);
                if (w > 0)
                  s = f + 1;
                else if (w < 0)
                  u = f - 1;
                else
                  return E;
              }
              return null;
            }
          }, Br = hr, kr = {
            isBuffered: function(l, o) {
              try {
                if (l) {
                  for (var s = l.buffered, u = 0; u < s.length; u++)
                    if (o >= s.start(u) && o <= s.end(u))
                      return !0;
                }
              } catch {
              }
              return !1;
            },
            bufferInfo: function(l, o, s) {
              try {
                if (l) {
                  var u = l.buffered, f = [], E;
                  for (E = 0; E < u.length; E++)
                    f.push({ start: u.start(E), end: u.end(E) });
                  return this.bufferedInfo(f, o, s);
                }
              } catch {
              }
              return { len: 0, start: o, end: o, nextStart: void 0 };
            },
            bufferedInfo: function(l, o, s) {
              var u = [], f, E, w, R, C;
              for (l.sort(function(te, he) {
                var xe = te.start - he.start;
                return xe || he.end - te.end;
              }), C = 0; C < l.length; C++) {
                var k = u.length;
                if (k) {
                  var P = u[k - 1].end;
                  l[C].start - P < s ? l[C].end > P && (u[k - 1].end = l[C].end) : u.push(l[C]);
                } else
                  u.push(l[C]);
              }
              for (C = 0, f = 0, E = w = o; C < u.length; C++) {
                var U = u[C].start, F = u[C].end;
                if (o + s >= U && o < F)
                  E = U, w = F, f = w - o;
                else if (o + s < U) {
                  R = U;
                  break;
                }
              }
              return { len: f, start: E, end: w, nextStart: R };
            }
          }, ct = kr, Tt = a(7), Cn = a(5), rr = /* @__PURE__ */ a.n(Cn), Wu = a(9), Yu = /* @__PURE__ */ a.n(Wu);
          function Hs() {
            if (typeof window < "u")
              return window.MediaSource || window.WebKitMediaSource;
          }
          function Ju(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var Zs = Hs(), v = function() {
            function g(l, o) {
              Ju(this, g), this.hls = l, this.id = o;
              var s = this.observer = new rr.a(), u = l.config;
              s.trigger = function(k) {
                for (var P = arguments.length, U = Array(P > 1 ? P - 1 : 0), F = 1; F < P; F++)
                  U[F - 1] = arguments[F];
                s.emit.apply(s, [k, k].concat(U));
              }, s.off = function(k) {
                for (var P = arguments.length, U = Array(P > 1 ? P - 1 : 0), F = 1; F < P; F++)
                  U[F - 1] = arguments[F];
                s.removeListener.apply(s, [k].concat(U));
              };
              var f = function(C, k) {
                k = k || {}, k.frag = this.frag, k.id = this.id, l.trigger(C, k);
              }.bind(this);
              s.on(p.a.FRAG_DECRYPTED, f), s.on(p.a.FRAG_PARSING_INIT_SEGMENT, f), s.on(p.a.FRAG_PARSING_DATA, f), s.on(p.a.FRAG_PARSED, f), s.on(p.a.ERROR, f), s.on(p.a.FRAG_PARSING_METADATA, f), s.on(p.a.FRAG_PARSING_USERDATA, f), s.on(p.a.INIT_PTS_FOUND, f);
              var E = {
                mp4: Zs.isTypeSupported("video/mp4"),
                mpeg: Zs.isTypeSupported("audio/mpeg"),
                mp3: Zs.isTypeSupported('audio/mp4; codecs="mp3"')
              }, w = navigator.vendor;
              if (u.enableWorker && typeof Worker < "u") {
                d.b.log("demuxing in webworker");
                var R = void 0;
                try {
                  R = this.w = Yu()(
                    /*require.resolve*/
                    10
                  ), this.onwmsg = this.onWorkerMessage.bind(this), R.addEventListener("message", this.onwmsg), R.onerror = function(C) {
                    l.trigger(p.a.ERROR, { type: y.b.OTHER_ERROR, details: y.a.INTERNAL_EXCEPTION, fatal: !0, event: "demuxerWorker", err: { message: C.message + " (" + C.filename + ":" + C.lineno + ")" } });
                  }, R.postMessage({ cmd: "init", typeSupported: E, vendor: w, id: o, config: JSON.stringify(u) });
                } catch {
                  d.b.error("error while initializing DemuxerWorker, fallback on DemuxerInline"), R && URL.revokeObjectURL(R.objectURL), this.demuxer = new Tt.a(s, E, u, w), this.w = void 0;
                }
              } else
                this.demuxer = new Tt.a(s, E, u, w);
            }
            return g.prototype.destroy = function() {
              var o = this.w;
              if (o)
                o.removeEventListener("message", this.onwmsg), o.terminate(), this.w = null;
              else {
                var s = this.demuxer;
                s && (s.destroy(), this.demuxer = null);
              }
              var u = this.observer;
              u && (u.removeAllListeners(), this.observer = null);
            }, g.prototype.push = function(o, s, u, f, E, w, R, C) {
              var k = this.w, P = isNaN(E.startDTS) ? E.start : E.startDTS, U = E.decryptdata, F = this.frag, te = !(F && E.cc === F.cc), he = !(F && E.level === F.level), xe = F && E.sn === F.sn + 1, ge = !he && xe;
              if (te && d.b.log(this.id + ":discontinuity detected"), he && d.b.log(this.id + ":switch detected"), this.frag = E, k)
                k.postMessage({ cmd: "demux", data: o, decryptdata: U, initSegment: s, audioCodec: u, videoCodec: f, timeOffset: P, discontinuity: te, trackSwitch: he, contiguous: ge, duration: w, accurateTimeOffset: R, defaultInitPTS: C }, o instanceof ArrayBuffer ? [o] : []);
              else {
                var Ce = this.demuxer;
                Ce && Ce.push(o, U, s, u, f, P, te, he, ge, w, R, C);
              }
            }, g.prototype.onWorkerMessage = function(o) {
              var s = o.data, u = this.hls;
              switch (s.event) {
                case "init":
                  URL.revokeObjectURL(this.w.objectURL);
                  break;
                case p.a.FRAG_PARSING_DATA:
                  s.data.data1 = new Uint8Array(s.data1), s.data2 && (s.data.data2 = new Uint8Array(s.data2));
                default:
                  s.data = s.data || {}, s.data.frag = this.frag, s.data.id = this.id, u.trigger(s.event, s.data);
                  break;
              }
            }, g;
          }(), I = v;
          function b(g, l, o) {
            var s = g[l], u = g[o], f = u.startPTS;
            isNaN(f) ? o > l ? u.start = s.start + s.duration : u.start = Math.max(s.start - u.duration, 0) : o > l ? (s.duration = f - s.start, s.duration < 0 && d.b.warn("negative duration computed for frag " + s.sn + ",level " + s.level + ", there should be some duration drift between playlist and fragment!")) : (u.duration = s.start - f, u.duration < 0 && d.b.warn("negative duration computed for frag " + u.sn + ",level " + u.level + ", there should be some duration drift between playlist and fragment!"));
          }
          function T(g, l, o, s, u, f) {
            var E = o;
            if (!isNaN(l.startPTS)) {
              var w = Math.abs(l.startPTS - o);
              isNaN(l.deltaPTS) ? l.deltaPTS = w : l.deltaPTS = Math.max(w, l.deltaPTS), E = Math.max(o, l.startPTS), o = Math.min(o, l.startPTS), s = Math.max(s, l.endPTS), u = Math.min(u, l.startDTS), f = Math.max(f, l.endDTS);
            }
            var R = o - l.start;
            l.start = l.startPTS = o, l.maxStartPTS = E, l.endPTS = s, l.startDTS = u, l.endDTS = f, l.duration = s - o;
            var C = l.sn;
            if (!g || C < g.startSN || C > g.endSN)
              return 0;
            var k, P, U;
            for (k = C - g.startSN, P = g.fragments, P[k] = l, U = k; U > 0; U--)
              b(P, U, U - 1);
            for (U = k; U < P.length - 1; U++)
              b(P, U, U + 1);
            return g.PTSKnown = !0, R;
          }
          function S(g, l) {
            var o = Math.max(g.startSN, l.startSN) - l.startSN, s = Math.min(g.endSN, l.endSN) - l.startSN, u = l.startSN - g.startSN, f = g.fragments, E = l.fragments, w = 0, R;
            if (s < o) {
              l.PTSKnown = !1;
              return;
            }
            for (var C = o; C <= s; C++) {
              var k = f[u + C], P = E[C];
              P && k && (w = k.cc - P.cc, isNaN(k.startPTS) || (P.start = P.startPTS = k.startPTS, P.endPTS = k.endPTS, P.duration = k.duration, P.backtracked = k.backtracked, P.dropped = k.dropped, R = P));
            }
            if (w)
              for (d.b.log("discontinuity sliding from playlist, take drift into account"), C = 0; C < E.length; C++)
                E[C].cc += w;
            if (R)
              T(l, R, R.startPTS, R.endPTS, R.startDTS, R.endDTS);
            else if (u >= 0 && u < f.length) {
              var U = f[u].start;
              for (C = 0; C < E.length; C++)
                E[C].start += U;
            }
            l.PTSKnown = g.PTSKnown;
          }
          var L = {
            toString: function(l) {
              for (var o = "", s = l.length, u = 0; u < s; u++)
                o += "[" + l.start(u).toFixed(3) + "," + l.end(u).toFixed(3) + "]";
              return o;
            }
          }, D = L;
          function N(g, l) {
            for (var o = null, s = 0; s < g.length; s += 1) {
              var u = g[s];
              if (u && u.cc === l) {
                o = u;
                break;
              }
            }
            return o;
          }
          function M(g, l) {
            return Br.search(g, function(o) {
              return o.cc < l ? 1 : o.cc > l ? -1 : 0;
            });
          }
          function W(g, l, o) {
            var s = !1;
            return l && l.details && o && (o.endCC > o.startCC || g && g.cc < o.startCC) && (s = !0), s;
          }
          function Q(g, l) {
            var o = g.fragments, s = l.fragments;
            if (!s.length || !o.length) {
              d.b.log("No fragments to align");
              return;
            }
            var u = N(o, s[0].cc);
            if (!u || u && !u.startPTS) {
              d.b.log("No frag in previous level to align on");
              return;
            }
            return u;
          }
          function Y(g, l) {
            l.fragments.forEach(function(o) {
              if (o) {
                var s = o.start + g;
                o.start = o.startPTS = s, o.endPTS = s + o.duration;
              }
            }), l.PTSKnown = !0;
          }
          function ie(g, l, o) {
            if (W(g, l, o)) {
              var s = Q(l.details, o);
              s && (d.b.log("Adjusting PTS using last level due to CC increase within current level"), Y(s.start, o));
            }
            if (o.PTSKnown === !1 && l && l.details) {
              var u = l.details.programDateTime, f = o.programDateTime, E = (f - u) / 1e3 + l.details.fragments[0].start;
              isNaN(E) || (d.b.log("adjusting PTS using programDateTime delta, sliding:" + E.toFixed(3)), Y(E, o));
            }
          }
          var re = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function pe(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function ue(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function ce(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var ee = {
            STOPPED: "STOPPED",
            IDLE: "IDLE",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING",
            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
            WAITING_LEVEL: "WAITING_LEVEL",
            PARSING: "PARSING",
            PARSED: "PARSED",
            BUFFER_FLUSHING: "BUFFER_FLUSHING",
            ENDED: "ENDED",
            ERROR: "ERROR"
          }, Ie = function(g) {
            ce(l, g);
            function l(o) {
              pe(this, l);
              var s = ue(this, g.call(this, o, p.a.MEDIA_ATTACHED, p.a.MEDIA_DETACHING, p.a.MANIFEST_LOADING, p.a.MANIFEST_PARSED, p.a.LEVEL_LOADED, p.a.KEY_LOADED, p.a.FRAG_LOADED, p.a.FRAG_LOAD_EMERGENCY_ABORTED, p.a.FRAG_PARSING_INIT_SEGMENT, p.a.FRAG_PARSING_DATA, p.a.FRAG_PARSED, p.a.ERROR, p.a.AUDIO_TRACK_SWITCHING, p.a.AUDIO_TRACK_SWITCHED, p.a.BUFFER_CREATED, p.a.BUFFER_APPENDED, p.a.BUFFER_FLUSHED));
              return s.config = o.config, s.audioCodecSwap = !1, s.ticks = 0, s._state = ee.STOPPED, s.ontick = s.tick.bind(s), s;
            }
            return l.prototype.destroy = function() {
              this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), O.prototype.destroy.call(this), this.state = ee.STOPPED;
            }, l.prototype.startLoad = function(s) {
              if (this.levels) {
                var u = this.lastCurrentTime, f = this.hls;
                if (this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
                  var E = f.startLevel;
                  E === -1 && (E = 0, this.bitrateTest = !0), this.level = f.nextLoadLevel = E, this.loadedmetadata = !1;
                }
                u > 0 && s === -1 && (d.b.log("override startPosition with lastCurrentTime @" + u.toFixed(3)), s = u), this.state = ee.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = s, this.tick();
              } else
                this.forceStartLoad = !0, this.state = ee.STOPPED;
            }, l.prototype.stopLoad = function() {
              var s = this.fragCurrent;
              s && (s.loader && s.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = ee.STOPPED, this.forceStartLoad = !1;
            }, l.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, l.prototype.doTick = function() {
              switch (this.state) {
                case ee.ERROR:
                  break;
                case ee.BUFFER_FLUSHING:
                  this.fragLoadError = 0;
                  break;
                case ee.IDLE:
                  this._doTickIdle();
                  break;
                case ee.WAITING_LEVEL:
                  var s = this.levels[this.level];
                  s && s.details && (this.state = ee.IDLE);
                  break;
                case ee.FRAG_LOADING_WAITING_RETRY:
                  var u = performance.now(), f = this.retryDate;
                  (!f || u >= f || this.media && this.media.seeking) && (d.b.log("mediaController: retryDate reached, switch back to IDLE state"), this.state = ee.IDLE);
                  break;
              }
              this._checkBuffer(), this._checkFragmentChanged();
            }, l.prototype._doTickIdle = function() {
              var s = this.hls, u = s.config, f = this.media;
              if (!(this.levelLastLoaded === void 0 || !f && (this.startFragRequested || !u.startFragPrefetch))) {
                var E = void 0;
                this.loadedmetadata ? E = f.currentTime : E = this.nextLoadPosition;
                var w = s.nextLoadLevel, R = this.levels[w];
                if (R) {
                  var C = R.bitrate, k = void 0;
                  C ? k = Math.max(8 * u.maxBufferSize / C, u.maxBufferLength) : k = u.maxBufferLength, k = Math.min(k, u.maxMaxBufferLength);
                  var P = ct.bufferInfo(this.mediaBuffer ? this.mediaBuffer : f, E, u.maxBufferHole), U = P.len;
                  if (!(U >= k)) {
                    d.b.trace("buffer length of " + U.toFixed(3) + " is below max of " + k.toFixed(3) + ". checking for more payload ..."), this.level = s.nextLoadLevel = w;
                    var F = R.details;
                    if (F === void 0 || F.live === !0 && this.levelLastLoaded !== w) {
                      this.state = ee.WAITING_LEVEL;
                      return;
                    }
                    var te = this.fragPrevious;
                    if (!F.live && te && !te.backtracked && te.sn === F.endSN && !P.nextStart) {
                      var he = Math.min(f.duration, te.start + te.duration);
                      if (he - Math.max(P.end, te.start) <= Math.max(0.2, te.duration)) {
                        var xe = {};
                        this.altAudio && (xe.type = "video"), this.hls.trigger(p.a.BUFFER_EOS, xe), this.state = ee.ENDED;
                        return;
                      }
                    }
                    this._fetchPayloadOrEos(E, P, F);
                  }
                }
              }
            }, l.prototype._fetchPayloadOrEos = function(s, u, f) {
              var E = this.fragPrevious, w = this.level, R = f.fragments, C = R.length;
              if (C !== 0) {
                var k = R[0].start, P = R[C - 1].start + R[C - 1].duration, U = u.end, F = void 0;
                if (f.initSegment && !f.initSegment.data)
                  F = f.initSegment;
                else if (f.live) {
                  var te = this.config.initialLiveManifestSize;
                  if (C < te) {
                    d.b.warn("Can not start playback of a level, reason: not enough fragments " + C + " < " + te);
                    return;
                  }
                  if (F = this._ensureFragmentAtLivePoint(f, U, k, P, E, R, C), F === null)
                    return;
                } else
                  U < k && (F = R[0]);
                F || (F = this._findFragment(k, E, C, R, U, P, f)), F && this._loadFragmentOrKey(F, w, f, s, U);
              }
            }, l.prototype._ensureFragmentAtLivePoint = function(s, u, f, E, w, R, C) {
              var k = this.hls.config, P = this.media, U = void 0, F = k.liveMaxLatencyDuration !== void 0 ? k.liveMaxLatencyDuration : k.liveMaxLatencyDurationCount * s.targetduration;
              if (u < Math.max(f - k.maxFragLookUpTolerance, E - F)) {
                var te = this.liveSyncPosition = this.computeLivePosition(f, s);
                d.b.log("buffer end: " + u.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + te.toFixed(3)), u = te, P && P.readyState && P.duration > te && (P.currentTime = te), this.nextLoadPosition = te;
              }
              if (s.PTSKnown && u > E && P && P.readyState)
                return null;
              if (this.startFragRequested && !s.PTSKnown) {
                if (w) {
                  var he = w.sn + 1;
                  if (he >= s.startSN && he <= s.endSN) {
                    var xe = R[he - s.startSN];
                    w.cc === xe.cc && (U = xe, d.b.log("live playlist, switching playlist, load frag with next SN: " + U.sn));
                  }
                  U || (U = Br.search(R, function(ge) {
                    return w.cc - ge.cc;
                  }), U && d.b.log("live playlist, switching playlist, load frag with same CC: " + U.sn));
                }
                U || (U = R[Math.min(C - 1, Math.round(C / 2))], d.b.log("live playlist, switching playlist, unknown, load middle frag : " + U.sn));
              }
              return U;
            }, l.prototype._findFragment = function(s, u, f, E, w, R, C) {
              var k = this.hls.config, P = void 0, U = void 0, F = k.maxFragLookUpTolerance, te = u ? E[u.sn - E[0].sn + 1] : void 0, he = function(dt) {
                var _e = Math.min(F, dt.duration + (dt.deltaPTS ? dt.deltaPTS : 0));
                return dt.start + dt.duration - _e <= w ? 1 : dt.start - _e > w && dt.start ? -1 : 0;
              };
              if (w < R ? (w > R - F && (F = 0), te && !he(te) ? U = te : U = Br.search(E, he)) : U = E[f - 1], U) {
                P = U;
                var xe = P.sn - C.startSN, ge = u && P.level === u.level, Ce = E[xe - 1], Se = E[xe + 1];
                if (u && P.sn === u.sn)
                  if (ge && !P.backtracked)
                    if (P.sn < C.endSN) {
                      var Pe = u.deltaPTS;
                      Pe && Pe > k.maxBufferHole && u.dropped && xe ? (P = Ce, d.b.warn("SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this"), u.loadCounter--) : (P = Se, d.b.log("SN just loaded, load next one: " + P.sn));
                    } else
                      P = null;
                  else P.backtracked && (Se && Se.backtracked ? (d.b.warn("Already backtracked from fragment " + Se.sn + ", will not backtrack to fragment " + P.sn + ". Loading fragment " + Se.sn), P = Se) : (d.b.warn("Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe"), P.dropped = 0, Ce ? (Ce.loadCounter && Ce.loadCounter--, P = Ce, P.backtracked = !0) : xe && (P = null)));
              }
              return P;
            }, l.prototype._loadFragmentOrKey = function(s, u, f, E, w) {
              var R = this.hls, C = R.config;
              if (s.decryptdata && s.decryptdata.uri != null && s.decryptdata.key == null)
                d.b.log("Loading key for " + s.sn + " of [" + f.startSN + " ," + f.endSN + "],level " + u), this.state = ee.KEY_LOADING, R.trigger(p.a.KEY_LOADING, { frag: s });
              else {
                if (d.b.log("Loading " + s.sn + " of [" + f.startSN + " ," + f.endSN + "],level " + u + ", currentTime:" + E.toFixed(3) + ",bufferEnd:" + w.toFixed(3)), this.fragLoadIdx !== void 0 ? this.fragLoadIdx++ : this.fragLoadIdx = 0, s.loadCounter) {
                  s.loadCounter++;
                  var k = C.fragLoadingLoopThreshold;
                  if (s.loadCounter > k && Math.abs(this.fragLoadIdx - s.loadIdx) < k) {
                    R.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.FRAG_LOOP_LOADING_ERROR, fatal: !1, frag: s });
                    return;
                  }
                } else
                  s.loadCounter = 1;
                s.loadIdx = this.fragLoadIdx, s.autoLevel = R.autoLevelEnabled, s.bitrateTest = this.bitrateTest, this.fragCurrent = s, this.startFragRequested = !0, !isNaN(s.sn) && !s.bitrateTest && (this.nextLoadPosition = s.start + s.duration), R.trigger(p.a.FRAG_LOADING, { frag: s }), this.demuxer || (this.demuxer = new I(R, "main")), this.state = ee.FRAG_LOADING;
                return;
              }
            }, l.prototype.getBufferedFrag = function(s) {
              return Br.search(this._bufferedFrags, function(u) {
                return s < u.startPTS ? -1 : s > u.endPTS ? 1 : 0;
              });
            }, l.prototype.followingBufferedFrag = function(s) {
              return s ? this.getBufferedFrag(s.endPTS + 0.5) : null;
            }, l.prototype._checkFragmentChanged = function() {
              var s, u, f = this.media;
              if (f && f.readyState && f.seeking === !1 && (u = f.currentTime, u > f.playbackRate * this.lastCurrentTime && (this.lastCurrentTime = u), ct.isBuffered(f, u) ? s = this.getBufferedFrag(u) : ct.isBuffered(f, u + 0.1) && (s = this.getBufferedFrag(u + 0.1)), s)) {
                var E = s;
                if (E !== this.fragPlaying) {
                  this.hls.trigger(p.a.FRAG_CHANGED, { frag: E });
                  var w = E.level;
                  (!this.fragPlaying || this.fragPlaying.level !== w) && this.hls.trigger(p.a.LEVEL_SWITCHED, { level: w }), this.fragPlaying = E;
                }
              }
            }, l.prototype.immediateLevelSwitch = function() {
              if (d.b.log("immediateLevelSwitch"), !this.immediateSwitch) {
                this.immediateSwitch = !0;
                var s = this.media, u = void 0;
                s ? (u = s.paused, s.pause()) : u = !0, this.previouslyPaused = u;
              }
              var f = this.fragCurrent;
              f && f.loader && f.loader.abort(), this.fragCurrent = null, this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }, l.prototype.immediateLevelSwitchEnd = function() {
              var s = this.media;
              s && s.buffered.length && (this.immediateSwitch = !1, ct.isBuffered(s, s.currentTime) && (s.currentTime -= 1e-4), this.previouslyPaused || s.play());
            }, l.prototype.nextLevelSwitch = function() {
              var s = this.media;
              if (s && s.readyState) {
                var u = void 0, f = void 0, E = void 0;
                if (this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), f = this.getBufferedFrag(s.currentTime), f && f.startPTS > 1 && this.flushMainBuffer(0, f.startPTS - 1), s.paused)
                  u = 0;
                else {
                  var w = this.hls.nextLoadLevel, R = this.levels[w], C = this.fragLastKbps;
                  C && this.fragCurrent ? u = this.fragCurrent.duration * R.bitrate / (1e3 * C) + 1 : u = 0;
                }
                if (E = this.getBufferedFrag(s.currentTime + u), E && (E = this.followingBufferedFrag(E), E)) {
                  var k = this.fragCurrent;
                  k && k.loader && k.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(E.maxStartPTS, Number.POSITIVE_INFINITY);
                }
              }
            }, l.prototype.flushMainBuffer = function(s, u) {
              this.state = ee.BUFFER_FLUSHING;
              var f = { startOffset: s, endOffset: u };
              this.altAudio && (f.type = "video"), this.hls.trigger(p.a.BUFFER_FLUSHING, f);
            }, l.prototype.onMediaAttached = function(s) {
              var u = this.media = this.mediaBuffer = s.media;
              this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), u.addEventListener("seeking", this.onvseeking), u.addEventListener("seeked", this.onvseeked), u.addEventListener("ended", this.onvended);
              var f = this.config;
              this.levels && f.autoStartLoad && this.hls.startLoad(f.startPosition);
            }, l.prototype.onMediaDetaching = function() {
              var s = this.media;
              s && s.ended && (d.b.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
              var u = this.levels;
              u && u.forEach(function(f) {
                f.details && f.details.fragments.forEach(function(E) {
                  E.loadCounter = void 0, E.backtracked = void 0;
                });
              }), s && (s.removeEventListener("seeking", this.onvseeking), s.removeEventListener("seeked", this.onvseeked), s.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad();
            }, l.prototype.onMediaSeeking = function() {
              var s = this.media, u = s ? s.currentTime : void 0, f = this.config;
              isNaN(u) || d.b.log("media seeking to " + u.toFixed(3));
              var E = this.mediaBuffer ? this.mediaBuffer : s, w = ct.bufferInfo(E, u, this.config.maxBufferHole);
              if (this.state === ee.FRAG_LOADING) {
                var R = this.fragCurrent;
                if (w.len === 0 && R) {
                  var C = f.maxFragLookUpTolerance, k = R.start - C, P = R.start + R.duration + C;
                  u < k || u > P ? (R.loader && (d.b.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), R.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = ee.IDLE) : d.b.log("seeking outside of buffer but within currently loaded fragment range");
                }
              } else this.state === ee.ENDED && (w.len === 0 && (this.fragPrevious = 0), this.state = ee.IDLE);
              s && (this.lastCurrentTime = u), this.state !== ee.FRAG_LOADING && this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * f.fragLoadingLoopThreshold), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = u), this.tick();
            }, l.prototype.onMediaSeeked = function() {
              var s = this.media, u = s ? s.currentTime : void 0;
              isNaN(u) || d.b.log("media seeked to " + u.toFixed(3)), this.tick();
            }, l.prototype.onMediaEnded = function() {
              d.b.log("media ended"), this.startPosition = this.lastCurrentTime = 0;
            }, l.prototype.onManifestLoading = function() {
              d.b.log("trigger BUFFER_RESET"), this.hls.trigger(p.a.BUFFER_RESET), this._bufferedFrags = [], this.stalled = !1, this.startPosition = this.lastCurrentTime = 0;
            }, l.prototype.onManifestParsed = function(s) {
              var u = !1, f = !1, E;
              s.levels.forEach(function(R) {
                E = R.audioCodec, E && (E.indexOf("mp4a.40.2") !== -1 && (u = !0), E.indexOf("mp4a.40.5") !== -1 && (f = !0));
              }), this.audioCodecSwitch = u && f, this.audioCodecSwitch && d.b.log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = s.levels, this.startFragRequested = !1;
              var w = this.config;
              (w.autoStartLoad || this.forceStartLoad) && this.hls.startLoad(w.startPosition);
            }, l.prototype.onLevelLoaded = function(s) {
              var u = s.details, f = s.level, E = this.levels[this.levelLastLoaded], w = this.levels[f], R = u.totalduration, C = 0;
              if (d.b.log("level " + f + " loaded [" + u.startSN + "," + u.endSN + "],duration:" + R), u.live) {
                var k = w.details;
                k && u.fragments.length > 0 ? (S(k, u), C = u.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(C, k), u.PTSKnown && !isNaN(C) ? d.b.log("live playlist sliding:" + C.toFixed(3)) : (d.b.log("live playlist - outdated PTS, unknown sliding"), ie(this.fragPrevious, E, u))) : (d.b.log("live playlist - first load, unknown sliding"), u.PTSKnown = !1, ie(this.fragPrevious, E, u));
              } else
                u.PTSKnown = !1;
              if (w.details = u, this.levelLastLoaded = f, this.hls.trigger(p.a.LEVEL_UPDATED, { details: u, level: f }), this.startFragRequested === !1) {
                if (this.startPosition === -1 || this.lastCurrentTime === -1) {
                  var P = u.startTimeOffset;
                  isNaN(P) ? u.live ? (this.startPosition = this.computeLivePosition(C, u), d.b.log("configure startPosition to " + this.startPosition)) : this.startPosition = 0 : (P < 0 && (d.b.log("negative start time offset " + P + ", count from end of last fragment"), P = C + R + P), d.b.log("start time offset found in playlist, adjust startPosition to " + P), this.startPosition = P), this.lastCurrentTime = this.startPosition;
                }
                this.nextLoadPosition = this.startPosition;
              }
              this.state === ee.WAITING_LEVEL && (this.state = ee.IDLE), this.tick();
            }, l.prototype.onKeyLoaded = function() {
              this.state === ee.KEY_LOADING && (this.state = ee.IDLE, this.tick());
            }, l.prototype.onFragLoaded = function(s) {
              var u = this.fragCurrent, f = s.frag;
              if (this.state === ee.FRAG_LOADING && u && f.type === "main" && f.level === u.level && f.sn === u.sn) {
                var E = s.stats, w = this.levels[u.level], R = w.details;
                if (d.b.log("Loaded  " + u.sn + " of [" + R.startSN + " ," + R.endSN + "],level " + u.level), this.bitrateTest = !1, this.stats = E, f.bitrateTest === !0 && this.hls.nextLoadLevel)
                  this.state = ee.IDLE, this.startFragRequested = !1, E.tparsed = E.tbuffered = performance.now(), this.hls.trigger(p.a.FRAG_BUFFERED, { stats: E, frag: u, id: "main" }), this.tick();
                else if (f.sn === "initSegment")
                  this.state = ee.IDLE, E.tparsed = E.tbuffered = performance.now(), R.initSegment.data = s.payload, this.hls.trigger(p.a.FRAG_BUFFERED, { stats: E, frag: u, id: "main" }), this.tick();
                else {
                  this.state = ee.PARSING;
                  var C = R.totalduration, k = u.level, P = u.sn, U = this.config.defaultAudioCodec || w.audioCodec;
                  this.audioCodecSwap && (d.b.log("swapping playlist audio codec"), U === void 0 && (U = this.lastAudioCodec), U && (U.indexOf("mp4a.40.5") !== -1 ? U = "mp4a.40.2" : U = "mp4a.40.5")), this.pendingBuffering = !0, this.appended = !1, d.b.log("Parsing " + P + " of [" + R.startSN + " ," + R.endSN + "],level " + k + ", cc " + u.cc);
                  var F = this.demuxer;
                  F || (F = this.demuxer = new I(this.hls, "main"));
                  var te = this.media, he = te && te.seeking, xe = !he && (R.PTSKnown || !R.live), ge = R.initSegment ? R.initSegment.data : [];
                  F.push(s.payload, ge, U, w.videoCodec, u, C, xe, void 0);
                }
              }
              this.fragLoadError = 0;
            }, l.prototype.onFragParsingInitSegment = function(s) {
              var u = this.fragCurrent, f = s.frag;
              if (u && s.id === "main" && f.sn === u.sn && f.level === u.level && this.state === ee.PARSING) {
                var E = s.tracks, w, R;
                if (E.audio && this.altAudio && delete E.audio, R = E.audio, R) {
                  var C = this.levels[this.level].audioCodec, k = navigator.userAgent.toLowerCase();
                  C && this.audioCodecSwap && (d.b.log("swapping playlist audio codec"), C.indexOf("mp4a.40.5") !== -1 ? C = "mp4a.40.2" : C = "mp4a.40.5"), this.audioCodecSwitch && R.metadata.channelCount !== 1 && // don't force HE-AAC if firefox
                  k.indexOf("firefox") === -1 && (C = "mp4a.40.5"), k.indexOf("android") !== -1 && R.container !== "audio/mpeg" && (C = "mp4a.40.2", d.b.log("Android: force audio codec to " + C)), R.levelCodec = C, R.id = s.id;
                }
                R = E.video, R && (R.levelCodec = this.levels[this.level].videoCodec, R.id = s.id), this.hls.trigger(p.a.BUFFER_CODECS, E);
                for (w in E) {
                  R = E[w], d.b.log("main track:" + w + ",container:" + R.container + ",codecs[level/parsed]=[" + R.levelCodec + "/" + R.codec + "]");
                  var P = R.initSegment;
                  P && (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(p.a.BUFFER_APPENDING, { type: w, data: P, parent: "main", content: "initSegment" }));
                }
                this.tick();
              }
            }, l.prototype.onFragParsingData = function(s) {
              var u = this, f = this.fragCurrent, E = s.frag;
              if (f && s.id === "main" && E.sn === f.sn && E.level === f.level && !(s.type === "audio" && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
              this.state === ee.PARSING) {
                var w = this.levels[this.level], R = f;
                if (isNaN(s.endPTS) && (s.endPTS = s.startPTS + f.duration, s.endDTS = s.startDTS + f.duration), d.b.log("Parsed " + s.type + ",PTS:[" + s.startPTS.toFixed(3) + "," + s.endPTS.toFixed(3) + "],DTS:[" + s.startDTS.toFixed(3) + "/" + s.endDTS.toFixed(3) + "],nb:" + s.nb + ",dropped:" + (s.dropped || 0)), s.type === "video")
                  if (R.dropped = s.dropped, R.dropped)
                    if (R.backtracked)
                      d.b.warn("Already backtracked on this fragment, appending with the gap");
                    else {
                      var C = w.details;
                      if (C && R.sn === C.startSN)
                        d.b.warn("missing video frame(s) on first frag, appending with gap");
                      else {
                        d.b.warn("missing video frame(s), backtracking fragment"), R.backtracked = !0, this.nextLoadPosition = s.startPTS, this.state = ee.IDLE, this.fragPrevious = R, this.tick();
                        return;
                      }
                    }
                  else
                    R.backtracked = !1;
                var k = T(w.details, R, s.startPTS, s.endPTS, s.startDTS, s.endDTS), P = this.hls;
                P.trigger(p.a.LEVEL_PTS_UPDATED, { details: w.details, level: this.level, drift: k, type: s.type, start: s.startPTS, end: s.endPTS }), [s.data1, s.data2].forEach(function(U) {
                  U && U.length && u.state === ee.PARSING && (u.appended = !0, u.pendingBuffering = !0, P.trigger(p.a.BUFFER_APPENDING, { type: s.type, data: U, parent: "main", content: "data" }));
                }), this.tick();
              }
            }, l.prototype.onFragParsed = function(s) {
              var u = this.fragCurrent, f = s.frag;
              u && s.id === "main" && f.sn === u.sn && f.level === u.level && this.state === ee.PARSING && (this.stats.tparsed = performance.now(), this.state = ee.PARSED, this._checkAppendedParsed());
            }, l.prototype.onAudioTrackSwitching = function(s) {
              var u = !!s.url, f = s.id;
              if (!u) {
                if (this.mediaBuffer !== this.media) {
                  d.b.log("switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                  var E = this.fragCurrent;
                  E.loader && (d.b.log("switching to main audio track, cancel main fragment load"), E.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = ee.IDLE;
                }
                var w = this.hls;
                w.trigger(p.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), w.trigger(p.a.AUDIO_TRACK_SWITCHED, { id: f }), this.altAudio = !1;
              }
            }, l.prototype.onAudioTrackSwitched = function(s) {
              var u = s.id, f = !!this.hls.audioTracks[u].url;
              if (f) {
                var E = this.videoBuffer;
                E && this.mediaBuffer !== E && (d.b.log("switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = E);
              }
              this.altAudio = f, this.tick();
            }, l.prototype.onBufferCreated = function(s) {
              var u = s.tracks, f = void 0, E = void 0, w = !1;
              for (var R in u) {
                var C = u[R];
                C.id === "main" ? (E = R, f = C, R === "video" && (this.videoBuffer = u[R].buffer)) : w = !0;
              }
              w && f ? (d.b.log("alternate track found, use " + E + ".buffered to schedule main fragment loading"), this.mediaBuffer = f.buffer) : this.mediaBuffer = this.media;
            }, l.prototype.onBufferAppended = function(s) {
              if (s.parent === "main") {
                var u = this.state;
                (u === ee.PARSING || u === ee.PARSED) && (this.pendingBuffering = s.pending > 0, this._checkAppendedParsed());
              }
            }, l.prototype._checkAppendedParsed = function() {
              if (this.state === ee.PARSED && (!this.appended || !this.pendingBuffering)) {
                var s = this.fragCurrent;
                if (s) {
                  var u = this.mediaBuffer ? this.mediaBuffer : this.media;
                  d.b.log("main buffered : " + D.toString(u.buffered));
                  var f = this._bufferedFrags.filter(function(w) {
                    return ct.isBuffered(u, (w.startPTS + w.endPTS) / 2);
                  });
                  f.push(s), this._bufferedFrags = f.sort(function(w, R) {
                    return w.startPTS - R.startPTS;
                  }), this.fragPrevious = s;
                  var E = this.stats;
                  E.tbuffered = performance.now(), this.fragLastKbps = Math.round(8 * E.total / (E.tbuffered - E.tfirst)), this.hls.trigger(p.a.FRAG_BUFFERED, { stats: E, frag: s, id: "main" }), this.state = ee.IDLE;
                }
                this.tick();
              }
            }, l.prototype.onError = function(s) {
              var u = s.frag || this.fragCurrent;
              if (!(u && u.type !== "main")) {
                var f = !!this.media && ct.isBuffered(this.media, this.media.currentTime) && ct.isBuffered(this.media, this.media.currentTime + 0.5);
                switch (s.details) {
                  case y.a.FRAG_LOAD_ERROR:
                  case y.a.FRAG_LOAD_TIMEOUT:
                  case y.a.KEY_LOAD_ERROR:
                  case y.a.KEY_LOAD_TIMEOUT:
                    if (!s.fatal)
                      if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
                        var E = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
                        u.loadCounter = 0, d.b.warn("mediaController: frag loading failed, retry in " + E + " ms"), this.retryDate = performance.now() + E, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = ee.FRAG_LOADING_WAITING_RETRY;
                      } else
                        d.b.error("mediaController: " + s.details + " reaches max retry, redispatch as fatal ..."), s.fatal = !0, this.state = ee.ERROR;
                    break;
                  case y.a.FRAG_LOOP_LOADING_ERROR:
                    s.fatal || (f ? (this._reduceMaxBufferLength(u.duration), this.state = ee.IDLE) : (!u.autoLevel || u.level === 0) && (s.fatal = !0, this.state = ee.ERROR));
                    break;
                  case y.a.LEVEL_LOAD_ERROR:
                  case y.a.LEVEL_LOAD_TIMEOUT:
                    this.state !== ee.ERROR && (s.fatal ? (this.state = ee.ERROR, d.b.warn("streamController: " + s.details + ",switch to " + this.state + " state ...")) : !s.levelRetry && this.state === ee.WAITING_LEVEL && (this.state = ee.IDLE));
                    break;
                  case y.a.BUFFER_FULL_ERROR:
                    s.parent === "main" && (this.state === ee.PARSING || this.state === ee.PARSED) && (f ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = ee.IDLE) : (d.b.warn("buffer full error also media.currentTime is not buffered, flush everything"), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY)));
                    break;
                }
              }
            }, l.prototype._reduceMaxBufferLength = function(s) {
              var u = this.config;
              u.maxMaxBufferLength >= s && (u.maxMaxBufferLength /= 2, d.b.warn("main:reduce max buffer length to " + u.maxMaxBufferLength + "s"), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * u.fragLoadingLoopThreshold));
            }, l.prototype._checkBuffer = function() {
              var s = this.media, u = this.config;
              if (s && s.readyState) {
                var f = s.currentTime, E = this.mediaBuffer ? this.mediaBuffer : s, w = E.buffered;
                if (!this.loadedmetadata && w.length) {
                  this.loadedmetadata = !0;
                  var R = s.seeking ? f : this.startPosition, C = ct.isBuffered(E, R), k = w.start(0), P = !C && Math.abs(R - k) < u.maxSeekHole;
                  (f !== R || P) && (d.b.log("target start position:" + R), P && (R = k, d.b.log("target start position not buffered, seek to buffered.start(0) " + R)), d.b.log("adjust currentTime from " + f + " to " + R), s.currentTime = R);
                } else if (this.immediateSwitch)
                  this.immediateLevelSwitchEnd();
                else {
                  var U = ct.bufferInfo(s, f, 0), F = !(s.paused || // not playing when media is paused
                  s.ended || // not playing when media is ended
                  s.buffered.length === 0), te = 0.5, he = f !== this.lastCurrentTime;
                  if (he)
                    this.stallReported && (d.b.warn("playback not stuck anymore @" + f + ", after " + Math.round(performance.now() - this.stalled) + "ms"), this.stallReported = !1), this.stalled = void 0, this.nudgeRetry = 0;
                  else if (F) {
                    var xe = performance.now(), ge = this.hls;
                    if (!this.stalled)
                      this.stalled = xe, this.stallReported = !1;
                    else {
                      var Ce = xe - this.stalled, Se = U.len, Pe = this.nudgeRetry || 0;
                      if (Se <= te && Ce > u.lowBufferWatchdogPeriod * 1e3) {
                        this.stallReported || (this.stallReported = !0, d.b.warn("playback stalling in low buffer @" + f), ge.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: Se }));
                        var Xe = U.nextStart, dt = Xe - f;
                        if (Xe && dt < u.maxSeekHole && dt > 0) {
                          this.nudgeRetry = ++Pe;
                          var _e = Pe * u.nudgeOffset;
                          d.b.log("adjust currentTime from " + s.currentTime + " to next buffered @ " + Xe + " + nudge " + _e), s.currentTime = Xe + _e, this.stalled = void 0, ge.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.BUFFER_SEEK_OVER_HOLE, fatal: !1, hole: Xe + _e - f });
                        }
                      } else if (Se > te && Ce > u.highBufferWatchdogPeriod * 1e3)
                        if (this.stallReported || (this.stallReported = !0, d.b.warn("playback stalling in high buffer @" + f), ge.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: Se })), this.stalled = void 0, this.nudgeRetry = ++Pe, Pe < u.nudgeMaxRetry) {
                          var Pt = s.currentTime, it = Pt + Pe * u.nudgeOffset;
                          d.b.log("adjust currentTime from " + Pt + " to " + it), s.currentTime = it, ge.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.BUFFER_NUDGE_ON_STALL, fatal: !1 });
                        } else
                          d.b.error("still stuck in high buffer @" + f + " after " + u.nudgeMaxRetry + ", raise fatal error"), ge.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.BUFFER_STALLED_ERROR, fatal: !0 });
                    }
                  }
                }
              }
            }, l.prototype.onFragLoadEmergencyAborted = function() {
              this.state = ee.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick();
            }, l.prototype.onBufferFlushed = function() {
              var s = this.mediaBuffer ? this.mediaBuffer : this.media;
              this._bufferedFrags = this._bufferedFrags.filter(function(u) {
                return ct.isBuffered(s, (u.startPTS + u.endPTS) / 2);
              }), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.state = ee.IDLE, this.fragPrevious = null;
            }, l.prototype.swapAudioCodec = function() {
              this.audioCodecSwap = !this.audioCodecSwap;
            }, l.prototype.computeLivePosition = function(s, u) {
              var f = this.config.liveSyncDuration !== void 0 ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * u.targetduration;
              return s + Math.max(0, u.totalduration - f);
            }, re(l, [{
              key: "state",
              set: function(s) {
                if (this.state !== s) {
                  var u = this.state;
                  this._state = s, d.b.log("main stream:" + u + "->" + s), this.hls.trigger(p.a.STREAM_STATE_TRANSITION, { previousState: u, nextState: s });
                }
              },
              get: function() {
                return this._state;
              }
            }, {
              key: "currentLevel",
              get: function() {
                var s = this.media;
                if (s) {
                  var u = this.getBufferedFrag(s.currentTime);
                  if (u)
                    return u.level;
                }
                return -1;
              }
            }, {
              key: "nextBufferedFrag",
              get: function() {
                var s = this.media;
                return s ? this.followingBufferedFrag(this.getBufferedFrag(s.currentTime)) : null;
              }
            }, {
              key: "nextLevel",
              get: function() {
                var s = this.nextBufferedFrag;
                return s ? s.level : -1;
              }
            }, {
              key: "liveSyncPosition",
              get: function() {
                return this._liveSyncPosition;
              },
              set: function(s) {
                this._liveSyncPosition = s;
              }
            }]), l;
          }(O), Ye = Ie, Je = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function Fe(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function He(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Te(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var rt = function(g) {
            Te(l, g);
            function l(o) {
              Fe(this, l);
              var s = He(this, g.call(this, o, p.a.MANIFEST_LOADED, p.a.LEVEL_LOADED, p.a.FRAG_LOADED, p.a.ERROR));
              return s.canload = !1, s.currentLevelIndex = null, s.manualLevelIndex = -1, s.timer = null, s;
            }
            return l.prototype.destroy = function() {
              this.cleanTimer(), this.manualLevelIndex = -1;
            }, l.prototype.cleanTimer = function() {
              this.timer !== null && (clearTimeout(this.timer), this.timer = null);
            }, l.prototype.startLoad = function() {
              var s = this._levels;
              this.canload = !0, this.levelRetryCount = 0, s && s.forEach(function(u) {
                u.loadError = 0;
                var f = u.details;
                f && f.live && (u.details = void 0);
              }), this.timer !== null && this.loadLevel();
            }, l.prototype.stopLoad = function() {
              this.canload = !1;
            }, l.prototype.onManifestLoaded = function(s) {
              var u = [], f = void 0, E = {}, w = null, R = !1, C = !1, k = /chrome|firefox/.test(navigator.userAgent.toLowerCase()), P = [];
              if (s.levels.forEach(function(F) {
                F.loadError = 0, F.fragmentError = !1, R = R || !!F.videoCodec, C = C || !!F.audioCodec || !!(F.attrs && F.attrs.AUDIO), k === !0 && F.audioCodec && F.audioCodec.indexOf("mp4a.40.34") !== -1 && (F.audioCodec = void 0), w = E[F.bitrate], w === void 0 ? (F.url = [F.url], F.urlId = 0, E[F.bitrate] = F, u.push(F)) : w.url.push(F.url);
              }), R === !0 && C === !0 && (u = u.filter(function(F) {
                var te = F.videoCodec;
                return !!te;
              })), u = u.filter(function(F) {
                var te = F.audioCodec, he = F.videoCodec;
                return (!te || se(te)) && (!he || se(he));
              }), s.audioTracks && (P = s.audioTracks.filter(function(F) {
                return !F.audioCodec || se(F.audioCodec, "audio");
              })), u.length > 0) {
                f = u[0].bitrate, u.sort(function(F, te) {
                  return F.bitrate - te.bitrate;
                }), this._levels = u;
                for (var U = 0; U < u.length; U++)
                  if (u[U].bitrate === f) {
                    this._firstLevel = U, d.b.log("manifest loaded," + u.length + " level(s) found, first bitrate:" + f);
                    break;
                  }
                this.hls.trigger(p.a.MANIFEST_PARSED, {
                  levels: u,
                  audioTracks: P,
                  firstLevel: this._firstLevel,
                  stats: s.stats,
                  audio: C,
                  video: R,
                  altAudio: P.length > 0
                });
              } else
                this.hls.trigger(p.a.ERROR, {
                  type: y.b.MEDIA_ERROR,
                  details: y.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                  fatal: !0,
                  url: this.hls.url,
                  reason: "no level with compatible codecs found in manifest"
                });
            }, l.prototype.setLevelInternal = function(s) {
              var u = this._levels, f = this.hls;
              if (s >= 0 && s < u.length) {
                if (this.cleanTimer(), this.currentLevelIndex !== s) {
                  d.b.log("switching to level " + s), this.currentLevelIndex = s;
                  var E = u[s];
                  E.level = s, f.trigger(p.a.LEVEL_SWITCH, E), f.trigger(p.a.LEVEL_SWITCHING, E);
                }
                var w = u[s], R = w.details;
                if (!R || R.live === !0) {
                  var C = w.urlId;
                  f.trigger(p.a.LEVEL_LOADING, { url: w.url[C], level: s, id: C });
                }
              } else
                f.trigger(p.a.ERROR, {
                  type: y.b.OTHER_ERROR,
                  details: y.a.LEVEL_SWITCH_ERROR,
                  level: s,
                  fatal: !1,
                  reason: "invalid level idx"
                });
            }, l.prototype.onError = function(s) {
              if (s.fatal === !0) {
                s.type === y.b.NETWORK_ERROR && this.cleanTimer();
                return;
              }
              var u = !1, f = !1, E = void 0;
              switch (s.details) {
                case y.a.FRAG_LOAD_ERROR:
                case y.a.FRAG_LOAD_TIMEOUT:
                case y.a.FRAG_LOOP_LOADING_ERROR:
                case y.a.KEY_LOAD_ERROR:
                case y.a.KEY_LOAD_TIMEOUT:
                  E = s.frag.level, f = !0;
                  break;
                case y.a.LEVEL_LOAD_ERROR:
                case y.a.LEVEL_LOAD_TIMEOUT:
                  E = s.context.level, u = !0;
                  break;
                case y.a.REMUX_ALLOC_ERROR:
                  E = s.level, u = !0;
                  break;
              }
              E !== void 0 && this.recoverLevel(s, E, u, f);
            }, l.prototype.recoverLevel = function(s, u, f, E) {
              var w = this, R = this.hls.config, C = s.details, k = this._levels[u], P = void 0, U = void 0, F = void 0;
              if (k.loadError++, k.fragmentError = E, f === !0)
                if (this.levelRetryCount + 1 <= R.levelLoadingMaxRetry)
                  U = Math.min(Math.pow(2, this.levelRetryCount) * R.levelLoadingRetryDelay, R.levelLoadingMaxRetryTimeout), this.timer = setTimeout(function() {
                    return w.loadLevel();
                  }, U), s.levelRetry = !0, this.levelRetryCount++, d.b.warn("level controller, " + C + ", retry in " + U + " ms, current retry count is " + this.levelRetryCount);
                else {
                  d.b.error("level controller, cannot recover from " + C + " error"), this.currentLevelIndex = null, this.cleanTimer(), s.fatal = !0;
                  return;
                }
              (f === !0 || E === !0) && (P = k.url.length, P > 1 && k.loadError < P ? (d.b.warn("level controller, " + C + " for level " + u + ": switching to redundant stream id " + k.urlId), k.urlId = (k.urlId + 1) % P, k.details = void 0) : this.manualLevelIndex === -1 ? (F = u === 0 ? this._levels.length - 1 : u - 1, d.b.warn("level controller, " + C + ": switch to " + F), this.hls.nextAutoLevel = this.currentLevelIndex = F) : E === !0 && (d.b.warn("level controller, " + C + ": reload a fragment"), this.currentLevelIndex = null));
            }, l.prototype.onFragLoaded = function(s) {
              var u = s.frag;
              if (u !== void 0 && u.type === "main") {
                var f = this._levels[u.level];
                f !== void 0 && (f.fragmentError = !1, f.loadError = 0, this.levelRetryCount = 0);
              }
            }, l.prototype.onLevelLoaded = function(s) {
              var u = this, f = s.level;
              if (f === this.currentLevelIndex) {
                var E = this._levels[f];
                E.fragmentError === !1 && (E.loadError = 0, this.levelRetryCount = 0);
                var w = s.details;
                if (w.live) {
                  var R = 1e3 * (w.averagetargetduration ? w.averagetargetduration : w.targetduration), C = E.details;
                  C && w.endSN === C.endSN && (R /= 2, d.b.log("same live playlist, reload twice faster")), R -= performance.now() - s.stats.trequest, R = Math.max(1e3, Math.round(R)), d.b.log("live playlist, reload in " + R + " ms"), this.timer = setTimeout(function() {
                    return u.loadLevel();
                  }, R);
                } else
                  this.cleanTimer();
              }
            }, l.prototype.loadLevel = function() {
              var s = void 0, u = void 0;
              this.currentLevelIndex !== null && this.canload === !0 && (s = this._levels[this.currentLevelIndex], s !== void 0 && s.url.length > 0 && (u = s.urlId, this.hls.trigger(p.a.LEVEL_LOADING, { url: s.url[u], level: this.currentLevelIndex, id: u })));
            }, Je(l, [{
              key: "levels",
              get: function() {
                return this._levels;
              }
            }, {
              key: "level",
              get: function() {
                return this.currentLevelIndex;
              },
              set: function(s) {
                var u = this._levels;
                u && (s = Math.min(s, u.length - 1), (this.currentLevelIndex !== s || u[s].details === void 0) && this.setLevelInternal(s));
              }
            }, {
              key: "manualLevel",
              get: function() {
                return this.manualLevelIndex;
              },
              set: function(s) {
                this.manualLevelIndex = s, this._startLevel === void 0 && (this._startLevel = s), s !== -1 && (this.level = s);
              }
            }, {
              key: "firstLevel",
              get: function() {
                return this._firstLevel;
              },
              set: function(s) {
                this._firstLevel = s;
              }
            }, {
              key: "startLevel",
              get: function() {
                if (this._startLevel === void 0) {
                  var s = this.hls.config.startLevel;
                  return s !== void 0 ? s : this._firstLevel;
                } else
                  return this._startLevel;
              },
              set: function(s) {
                this._startLevel = s;
              }
            }, {
              key: "nextLoadLevel",
              get: function() {
                return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
              },
              set: function(s) {
                this.level = s, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = s);
              }
            }]), l;
          }(O), Rt = rt, Qe = a(3);
          function gt(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function Ct(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function ir(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var Dt = function(g) {
            ir(l, g);
            function l(o) {
              gt(this, l);
              var s = Ct(this, g.call(this, o, p.a.MEDIA_ATTACHED, p.a.MEDIA_DETACHING, p.a.FRAG_PARSING_METADATA));
              return s.id3Track = void 0, s.media = void 0, s;
            }
            return l.prototype.destroy = function() {
              O.prototype.destroy.call(this);
            }, l.prototype.onMediaAttached = function(s) {
              this.media = s.media, this.media;
            }, l.prototype.onMediaDetaching = function() {
              this.media = void 0;
            }, l.prototype.onFragParsingMetadata = function(s) {
              var u = s.frag, f = s.samples;
              this.id3Track || (this.id3Track = this.media.addTextTrack("metadata", "id3"), this.id3Track.mode = "hidden");
              for (var E = window.WebKitDataCue || window.VTTCue || window.TextTrackCue, w = 0; w < f.length; w++) {
                var R = Qe.a.getID3Frames(f[w].data);
                if (R) {
                  var C = f[w].pts, k = w < f.length - 1 ? f[w + 1].pts : u.endPTS;
                  C === k && (k += 1e-4);
                  for (var P = 0; P < R.length; P++) {
                    var U = R[P];
                    if (!Qe.a.isTimeStampFrame(U)) {
                      var F = new E(C, k, "");
                      F.value = U, this.id3Track.addCue(F);
                    }
                  }
                }
              }
            }, l;
          }(O), br = Dt;
          function zt() {
            var g = Hs(), l = window.SourceBuffer || window.WebKitSourceBuffer, o = g && typeof g.isTypeSupported == "function" && g.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'), s = !l || l.prototype && typeof l.prototype.appendBuffer == "function" && typeof l.prototype.remove == "function";
            return !!o && !!s;
          }
          function nr(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var _i = function() {
            function g(l) {
              nr(this, g), this.alpha_ = l ? Math.exp(Math.log(0.5) / l) : 0, this.estimate_ = 0, this.totalWeight_ = 0;
            }
            return g.prototype.sample = function(o, s) {
              var u = Math.pow(this.alpha_, o);
              this.estimate_ = s * (1 - u) + u * this.estimate_, this.totalWeight_ += o;
            }, g.prototype.getTotalWeight = function() {
              return this.totalWeight_;
            }, g.prototype.getEstimate = function() {
              if (this.alpha_) {
                var o = 1 - Math.pow(this.alpha_, this.totalWeight_);
                return this.estimate_ / o;
              } else
                return this.estimate_;
            }, g;
          }(), wi = _i;
          function Sn(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var Xt = function() {
            function g(l, o, s, u) {
              Sn(this, g), this.hls = l, this.defaultEstimate_ = u, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new wi(o), this.fast_ = new wi(s);
            }
            return g.prototype.sample = function(o, s) {
              o = Math.max(o, this.minDelayMs_);
              var u = 8e3 * s / o, f = o / 1e3;
              this.fast_.sample(f, u), this.slow_.sample(f, u);
            }, g.prototype.canEstimate = function() {
              var o = this.fast_;
              return o && o.getTotalWeight() >= this.minWeight_;
            }, g.prototype.getEstimate = function() {
              return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
            }, g.prototype.destroy = function() {
            }, g;
          }(), At = Xt, Ir = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function Ti(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function Hr(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Ln(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var cs = function(g) {
            Ln(l, g);
            function l(o) {
              Ti(this, l);
              var s = Hr(this, g.call(this, o, p.a.FRAG_LOADING, p.a.FRAG_LOADED, p.a.FRAG_BUFFERED, p.a.ERROR));
              return s.lastLoadedFragLevel = 0, s._nextAutoLevel = -1, s.hls = o, s.timer = null, s._bwEstimator = null, s.onCheck = s._abandonRulesCheck.bind(s), s;
            }
            return l.prototype.destroy = function() {
              this.clearTimer(), O.prototype.destroy.call(this);
            }, l.prototype.onFragLoading = function(s) {
              var u = s.frag;
              if (u.type === "main") {
                if (this.timer || (this.timer = setInterval(this.onCheck, 100)), !this._bwEstimator) {
                  var f = this.hls, E = s.frag.level, w = f.levels[E].details.live, R = f.config, C = void 0, k = void 0;
                  w ? (C = R.abrEwmaFastLive, k = R.abrEwmaSlowLive) : (C = R.abrEwmaFastVoD, k = R.abrEwmaSlowVoD), this._bwEstimator = new At(f, k, C, R.abrEwmaDefaultEstimate);
                }
                this.fragCurrent = u;
              }
            }, l.prototype._abandonRulesCheck = function() {
              var s = this.hls, u = s.media, f = this.fragCurrent, E = f.loader, w = s.minAutoLevel;
              if (!E || E.stats && E.stats.aborted) {
                d.b.warn("frag loader destroy or aborted, disarm abandonRules"), this.clearTimer(), this._nextAutoLevel = -1;
                return;
              }
              var R = E.stats;
              if (u && R && (!u.paused && u.playbackRate !== 0 || !u.readyState) && f.autoLevel && f.level) {
                var C = performance.now() - R.trequest, k = Math.abs(u.playbackRate);
                if (C > 500 * f.duration / k) {
                  var P = s.levels, U = Math.max(1, R.bw ? R.bw / 8 : R.loaded * 1e3 / C), F = P[f.level], te = F.realBitrate ? Math.max(F.realBitrate, F.bitrate) : F.bitrate, he = R.total ? R.total : Math.max(R.loaded, Math.round(f.duration * te / 8)), xe = u.currentTime, ge = (he - R.loaded) / U, Ce = (ct.bufferInfo(u, xe, s.config.maxBufferHole).end - xe) / k;
                  if (Ce < 2 * f.duration / k && ge > Ce) {
                    var Se = void 0, Pe = void 0;
                    for (Pe = f.level - 1; Pe > w; Pe--) {
                      var Xe = P[Pe].realBitrate ? Math.max(P[Pe].realBitrate, P[Pe].bitrate) : P[Pe].bitrate;
                      if (Se = f.duration * Xe / (8 * 0.8 * U), Se < Ce)
                        break;
                    }
                    Se < ge && (d.b.warn("loading too slow, abort fragment loading and switch to level " + Pe + ":fragLoadedDelay[" + Pe + "]<fragLoadedDelay[" + (f.level - 1) + "];bufferStarvationDelay:" + Se.toFixed(1) + "<" + ge.toFixed(1) + ":" + Ce.toFixed(1)), s.nextLoadLevel = Pe, this._bwEstimator.sample(C, R.loaded), E.abort(), this.clearTimer(), s.trigger(p.a.FRAG_LOAD_EMERGENCY_ABORTED, { frag: f, stats: R }));
                  }
                }
              }
            }, l.prototype.onFragLoaded = function(s) {
              var u = s.frag;
              if (u.type === "main" && !isNaN(u.sn)) {
                if (this.clearTimer(), this.lastLoadedFragLevel = u.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                  var f = this.hls.levels[u.level], E = (f.loaded ? f.loaded.bytes : 0) + s.stats.loaded, w = (f.loaded ? f.loaded.duration : 0) + s.frag.duration;
                  f.loaded = { bytes: E, duration: w }, f.realBitrate = Math.round(8 * E / w);
                }
                if (s.frag.bitrateTest) {
                  var R = s.stats;
                  R.tparsed = R.tbuffered = R.tload, this.onFragBuffered(s);
                }
              }
            }, l.prototype.onFragBuffered = function(s) {
              var u = s.stats, f = s.frag;
              if (u.aborted !== !0 && f.loadCounter === 1 && f.type === "main" && !isNaN(f.sn) && (!f.bitrateTest || u.tload === u.tbuffered)) {
                var E = u.tparsed - u.trequest;
                d.b.log("latency/loading/parsing/append/kbps:" + Math.round(u.tfirst - u.trequest) + "/" + Math.round(u.tload - u.tfirst) + "/" + Math.round(u.tparsed - u.tload) + "/" + Math.round(u.tbuffered - u.tparsed) + "/" + Math.round(8 * u.loaded / (u.tbuffered - u.trequest))), this._bwEstimator.sample(E, u.loaded), u.bwEstimate = this._bwEstimator.getEstimate(), f.bitrateTest ? this.bitrateTestDelay = E / 1e3 : this.bitrateTestDelay = 0;
              }
            }, l.prototype.onError = function(s) {
              switch (s.details) {
                case y.a.FRAG_LOAD_ERROR:
                case y.a.FRAG_LOAD_TIMEOUT:
                  this.clearTimer();
                  break;
              }
            }, l.prototype.clearTimer = function() {
              clearInterval(this.timer), this.timer = null;
            }, l.prototype._findBestLevel = function(s, u, f, E, w, R, C, k, P) {
              for (var U = w; U >= E; U--) {
                var F = P[U], te = F.details, he = te ? te.totalduration / te.fragments.length : u, xe = te ? te.live : !1, ge = void 0;
                U <= s ? ge = C * f : ge = k * f;
                var Ce = P[U].realBitrate ? Math.max(P[U].realBitrate, P[U].bitrate) : P[U].bitrate, Se = Ce * he / ge;
                if (d.b.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + U + "/" + Math.round(ge) + "/" + Ce + "/" + he + "/" + R + "/" + Se), ge > Ce && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
                (!Se || xe && !this.bitrateTestDelay || Se < R))
                  return U;
              }
              return -1;
            }, Ir(l, [{
              key: "nextAutoLevel",
              get: function() {
                var s = this._nextAutoLevel, u = this._bwEstimator;
                if (s !== -1 && (!u || !u.canEstimate()))
                  return s;
                var f = this._nextABRAutoLevel;
                return s !== -1 && (f = Math.min(s, f)), f;
              },
              set: function(s) {
                this._nextAutoLevel = s;
              }
            }, {
              key: "_nextABRAutoLevel",
              get: function() {
                var s = this.hls, u = s.maxAutoLevel, f = s.levels, E = s.config, w = s.minAutoLevel, R = s.media, C = this.lastLoadedFragLevel, k = this.fragCurrent ? this.fragCurrent.duration : 0, P = R ? R.currentTime : 0, U = R && R.playbackRate !== 0 ? Math.abs(R.playbackRate) : 1, F = this._bwEstimator ? this._bwEstimator.getEstimate() : E.abrEwmaDefaultEstimate, te = (ct.bufferInfo(R, P, E.maxBufferHole).end - P) / U, he = this._findBestLevel(C, k, F, w, u, te, E.abrBandWidthFactor, E.abrBandWidthUpFactor, f);
                if (he >= 0)
                  return he;
                d.b.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");
                var xe = k ? Math.min(k, E.maxStarvationDelay) : E.maxStarvationDelay, ge = E.abrBandWidthFactor, Ce = E.abrBandWidthUpFactor;
                if (te === 0) {
                  var Se = this.bitrateTestDelay;
                  if (Se) {
                    var Pe = k ? Math.min(k, E.maxLoadingDelay) : E.maxLoadingDelay;
                    xe = Pe - Se, d.b.trace("bitrate test took " + Math.round(1e3 * Se) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * xe) + " ms"), ge = Ce = 1;
                  }
                }
                return he = this._findBestLevel(C, k, F, w, u, te + xe, ge, Ce, f), Math.max(he, 0);
              }
            }]), l;
          }(O), kn = cs;
          function Dn(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function Zr(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function rn(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var Ci = Hs(), ds = function(g) {
            rn(l, g);
            function l(o) {
              Dn(this, l);
              var s = Zr(this, g.call(this, o, p.a.MEDIA_ATTACHING, p.a.MEDIA_DETACHING, p.a.MANIFEST_PARSED, p.a.BUFFER_RESET, p.a.BUFFER_APPENDING, p.a.BUFFER_CODECS, p.a.BUFFER_EOS, p.a.BUFFER_FLUSHING, p.a.LEVEL_PTS_UPDATED, p.a.LEVEL_UPDATED));
              return s._msDuration = null, s._levelDuration = null, s._live = null, s._objectUrl = null, s.onsbue = s.onSBUpdateEnd.bind(s), s.onsbe = s.onSBUpdateError.bind(s), s.pendingTracks = {}, s.tracks = {}, s;
            }
            return l.prototype.destroy = function() {
              O.prototype.destroy.call(this);
            }, l.prototype.onLevelPtsUpdated = function(s) {
              var u = s.type, f = this.tracks.audio;
              if (u === "audio" && f && f.container === "audio/mpeg") {
                var E = this.sourceBuffer.audio, w = Math.abs(E.timestampOffset - s.start);
                if (w > 0.1) {
                  var R = E.updating;
                  try {
                    E.abort();
                  } catch (C) {
                    R = !0, d.b.warn("can not abort audio buffer: " + C);
                  }
                  R ? this.audioTimestampOffset = s.start : (d.b.warn("change mpeg audio timestamp offset from " + E.timestampOffset + " to " + s.start), E.timestampOffset = s.start);
                }
              }
            }, l.prototype.onManifestParsed = function(s) {
              var u = s.audio, f = s.video || s.levels.length && s.audio, E = 0;
              s.altAudio && (u || f) && (E = (u ? 1 : 0) + (f ? 1 : 0), d.b.log(E + " sourceBuffer(s) expected")), this.sourceBufferNb = E;
            }, l.prototype.onMediaAttaching = function(s) {
              var u = this.media = s.media;
              if (u) {
                var f = this.mediaSource = new Ci();
                this.onmso = this.onMediaSourceOpen.bind(this), this.onmse = this.onMediaSourceEnded.bind(this), this.onmsc = this.onMediaSourceClose.bind(this), f.addEventListener("sourceopen", this.onmso), f.addEventListener("sourceended", this.onmse), f.addEventListener("sourceclose", this.onmsc), u.src = URL.createObjectURL(f), this._objectUrl = u.src;
              }
            }, l.prototype.onMediaDetaching = function() {
              d.b.log("media source detaching");
              var s = this.mediaSource;
              if (s) {
                if (s.readyState === "open")
                  try {
                    s.endOfStream();
                  } catch (u) {
                    d.b.warn("onMediaDetaching:" + u.message + " while calling endOfStream");
                  }
                s.removeEventListener("sourceopen", this.onmso), s.removeEventListener("sourceended", this.onmse), s.removeEventListener("sourceclose", this.onmsc), this.media && (URL.revokeObjectURL(this._objectUrl), this.media.src === this._objectUrl ? (this.media.removeAttribute("src"), this.media.load()) : d.b.warn("media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;
              }
              this.onmso = this.onmse = this.onmsc = null, this.hls.trigger(p.a.MEDIA_DETACHED);
            }, l.prototype.onMediaSourceOpen = function() {
              d.b.log("media source opened"), this.hls.trigger(p.a.MEDIA_ATTACHED, { media: this.media });
              var s = this.mediaSource;
              s && s.removeEventListener("sourceopen", this.onmso), this.checkPendingTracks();
            }, l.prototype.checkPendingTracks = function() {
              var s = this.pendingTracks, u = Object.keys(s).length;
              u && (this.sourceBufferNb <= u || this.sourceBufferNb === 0) && (this.createSourceBuffers(s), this.pendingTracks = {}, this.doAppending());
            }, l.prototype.onMediaSourceClose = function() {
              d.b.log("media source closed");
            }, l.prototype.onMediaSourceEnded = function() {
              d.b.log("media source ended");
            }, l.prototype.onSBUpdateEnd = function() {
              if (this.audioTimestampOffset) {
                var s = this.sourceBuffer.audio;
                d.b.warn("change mpeg audio timestamp offset from " + s.timestampOffset + " to " + this.audioTimestampOffset), s.timestampOffset = this.audioTimestampOffset, delete this.audioTimestampOffset;
              }
              this._needsFlush && this.doFlush(), this._needsEos && this.checkEos(), this.appending = !1;
              var u = this.parent, f = this.segments.reduce(function(E, w) {
                return w.parent === u ? E + 1 : E;
              }, 0);
              this.hls.trigger(p.a.BUFFER_APPENDED, { parent: u, pending: f }), this._needsFlush || this.doAppending(), this.updateMediaElementDuration();
            }, l.prototype.onSBUpdateError = function(s) {
              d.b.error("sourceBuffer error:", s), this.hls.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.BUFFER_APPENDING_ERROR, fatal: !1 });
            }, l.prototype.onBufferReset = function() {
              var s = this.sourceBuffer;
              for (var u in s) {
                var f = s[u];
                try {
                  this.mediaSource.removeSourceBuffer(f), f.removeEventListener("updateend", this.onsbue), f.removeEventListener("error", this.onsbe);
                } catch {
                }
              }
              this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;
            }, l.prototype.onBufferCodecs = function(s) {
              if (Object.keys(this.sourceBuffer).length === 0) {
                for (var u in s)
                  this.pendingTracks[u] = s[u];
                var f = this.mediaSource;
                f && f.readyState === "open" && this.checkPendingTracks();
              }
            }, l.prototype.createSourceBuffers = function(s) {
              var u = this.sourceBuffer, f = this.mediaSource;
              for (var E in s)
                if (!u[E]) {
                  var w = s[E], R = w.levelCodec || w.codec, C = w.container + ";codecs=" + R;
                  d.b.log("creating sourceBuffer(" + C + ")");
                  try {
                    var k = u[E] = f.addSourceBuffer(C);
                    k.addEventListener("updateend", this.onsbue), k.addEventListener("error", this.onsbe), this.tracks[E] = { codec: R, container: w.container }, w.buffer = k;
                  } catch (P) {
                    d.b.error("error while trying to add sourceBuffer:" + P.message), this.hls.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.BUFFER_ADD_CODEC_ERROR, fatal: !1, err: P, mimeType: C });
                  }
                }
              this.hls.trigger(p.a.BUFFER_CREATED, { tracks: s });
            }, l.prototype.onBufferAppending = function(s) {
              this._needsFlush || (this.segments ? this.segments.push(s) : this.segments = [s], this.doAppending());
            }, l.prototype.onBufferAppendFail = function(s) {
              d.b.error("sourceBuffer error:", s.event), this.hls.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.BUFFER_APPENDING_ERROR, fatal: !1 });
            }, l.prototype.onBufferEos = function(s) {
              var u = this.sourceBuffer, f = s.type;
              for (var E in u)
                (!f || E === f) && (u[E].ended || (u[E].ended = !0, d.b.log(E + " sourceBuffer now EOS")));
              this.checkEos();
            }, l.prototype.checkEos = function() {
              var s = this.sourceBuffer, u = this.mediaSource;
              if (!u || u.readyState !== "open") {
                this._needsEos = !1;
                return;
              }
              for (var f in s) {
                var E = s[f];
                if (!E.ended)
                  return;
                if (E.updating) {
                  this._needsEos = !0;
                  return;
                }
              }
              d.b.log("all media data available, signal endOfStream() to MediaSource and stop loading fragment");
              try {
                u.endOfStream();
              } catch {
                d.b.warn("exception while calling mediaSource.endOfStream()");
              }
              this._needsEos = !1;
            }, l.prototype.onBufferFlushing = function(s) {
              this.flushRange.push({ start: s.startOffset, end: s.endOffset, type: s.type }), this.flushBufferCounter = 0, this.doFlush();
            }, l.prototype.onLevelUpdated = function(s) {
              var u = s.details;
              u.fragments.length > 0 && (this._levelDuration = u.totalduration + u.fragments[0].start, this._live = u.live, this.updateMediaElementDuration());
            }, l.prototype.updateMediaElementDuration = function() {
              var s = this.hls.config, u = void 0;
              if (!(this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== "open")) {
                for (var f in this.sourceBuffer)
                  if (this.sourceBuffer[f].updating === !0)
                    return;
                u = this.media.duration, this._msDuration === null && (this._msDuration = this.mediaSource.duration), this._live === !0 && s.liveDurationInfinity === !0 ? (d.b.log("Media Source duration is set to Infinity"), this._msDuration = this.mediaSource.duration = 1 / 0) : (this._levelDuration > this._msDuration && this._levelDuration > u || u === 1 / 0 || isNaN(u)) && (d.b.log("Updating Media Source duration to " + this._levelDuration.toFixed(3)), this._msDuration = this.mediaSource.duration = this._levelDuration);
              }
            }, l.prototype.doFlush = function() {
              for (; this.flushRange.length; ) {
                var s = this.flushRange[0];
                if (this.flushBuffer(s.start, s.end, s.type))
                  this.flushRange.shift(), this.flushBufferCounter = 0;
                else {
                  this._needsFlush = !0;
                  return;
                }
              }
              if (this.flushRange.length === 0) {
                this._needsFlush = !1;
                var u = 0, f = this.sourceBuffer;
                try {
                  for (var E in f)
                    u += f[E].buffered.length;
                } catch {
                  d.b.error("error while accessing sourceBuffer.buffered");
                }
                this.appended = u, this.hls.trigger(p.a.BUFFER_FLUSHED);
              }
            }, l.prototype.doAppending = function() {
              var s = this.hls, u = this.sourceBuffer, f = this.segments;
              if (Object.keys(u).length) {
                if (this.media.error) {
                  this.segments = [], d.b.error("trying to append although a media error occured, flush segment and abort");
                  return;
                }
                if (this.appending)
                  return;
                if (f && f.length) {
                  var E = f.shift();
                  try {
                    var w = E.type, R = u[w];
                    R ? R.updating ? f.unshift(E) : (R.ended = !1, this.parent = E.parent, R.appendBuffer(E.data), this.appendError = 0, this.appended++, this.appending = !0) : this.onSBUpdateEnd();
                  } catch (k) {
                    d.b.error("error while trying to append buffer:" + k.message), f.unshift(E);
                    var C = { type: y.b.MEDIA_ERROR, parent: E.parent };
                    if (k.code !== 22)
                      if (this.appendError ? this.appendError++ : this.appendError = 1, C.details = y.a.BUFFER_APPEND_ERROR, this.appendError > s.config.appendErrorMaxRetry) {
                        d.b.log("fail " + s.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), f = [], C.fatal = !0, s.trigger(p.a.ERROR, C);
                        return;
                      } else
                        C.fatal = !1, s.trigger(p.a.ERROR, C);
                    else {
                      this.segments = [], C.details = y.a.BUFFER_FULL_ERROR, C.fatal = !1, s.trigger(p.a.ERROR, C);
                      return;
                    }
                  }
                }
              }
            }, l.prototype.flushBuffer = function(s, u, f) {
              var E, w, R, C, k, P, U = this.sourceBuffer;
              if (Object.keys(U).length) {
                if (d.b.log("flushBuffer,pos/start/end: " + this.media.currentTime.toFixed(3) + "/" + s + "/" + u), this.flushBufferCounter < this.appended) {
                  for (var F in U)
                    if (!(f && F !== f)) {
                      if (E = U[F], E.ended = !1, E.updating)
                        return d.b.warn("cannot flush, sb updating in progress"), !1;
                      try {
                        for (w = 0; w < E.buffered.length; w++)
                          if (R = E.buffered.start(w), C = E.buffered.end(w), navigator.userAgent.toLowerCase().indexOf("firefox") !== -1 && u === Number.POSITIVE_INFINITY ? (k = s, P = u) : (k = Math.max(R, s), P = Math.min(C, u)), Math.min(P, C) - k > 0.5)
                            return this.flushBufferCounter++, d.b.log("flush " + F + " [" + k + "," + P + "], of [" + R + "," + C + "], pos:" + this.media.currentTime), E.remove(k, P), !1;
                      } catch {
                        d.b.warn("exception while accessing sourcebuffer, it might have been removed from MediaSource");
                      }
                    }
                } else
                  d.b.warn("abort flushing too many retries");
                d.b.log("buffer flushed");
              }
              return !0;
            }, l;
          }(O), Wr = ds, Qu = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function Ws(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function ec(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Gl(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var ql = function(g) {
            Gl(l, g);
            function l(o) {
              return Ws(this, l), ec(this, g.call(this, o, p.a.FPS_DROP_LEVEL_CAPPING, p.a.MEDIA_ATTACHING, p.a.MANIFEST_PARSED));
            }
            return l.prototype.destroy = function() {
              this.hls.config.capLevelToPlayerSize && (this.media = this.restrictedLevels = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer)));
            }, l.prototype.onFpsDropLevelCapping = function(s) {
              l.isLevelAllowed(s.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(s.droppedLevel);
            }, l.prototype.onMediaAttaching = function(s) {
              this.media = s.media instanceof HTMLVideoElement ? s.media : null;
            }, l.prototype.onManifestParsed = function(s) {
              var u = this.hls;
              this.restrictedLevels = [], u.config.capLevelToPlayerSize && (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.levels = s.levels, u.firstLevel = this.getMaxLevel(s.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
            }, l.prototype.detectPlayerSize = function() {
              if (this.media) {
                var s = this.levels ? this.levels.length : 0;
                if (s) {
                  var u = this.hls;
                  u.autoLevelCapping = this.getMaxLevel(s - 1), u.autoLevelCapping > this.autoLevelCapping && u.streamController.nextLevelSwitch(), this.autoLevelCapping = u.autoLevelCapping;
                }
              }
            }, l.prototype.getMaxLevel = function(s) {
              var u = this;
              if (!this.levels)
                return -1;
              var f = this.levels.filter(function(E, w) {
                return l.isLevelAllowed(w, u.restrictedLevels) && w <= s;
              });
              return l.getMaxLevelByMediaSize(f, this.mediaWidth, this.mediaHeight);
            }, l.isLevelAllowed = function(s) {
              var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
              return u.indexOf(s) === -1;
            }, l.getMaxLevelByMediaSize = function(s, u, f) {
              if (!s || s && !s.length)
                return -1;
              for (var E = function(P, U) {
                return U ? P.width !== U.width || P.height !== U.height : !0;
              }, w = s.length - 1, R = 0; R < s.length; R += 1) {
                var C = s[R];
                if ((C.width >= u || C.height >= f) && E(C, s[R + 1])) {
                  w = R;
                  break;
                }
              }
              return w;
            }, Qu(l, [{
              key: "mediaWidth",
              get: function() {
                var s = void 0, u = this.media;
                return u && (s = u.width || u.clientWidth || u.offsetWidth, s *= l.contentScaleFactor), s;
              }
            }, {
              key: "mediaHeight",
              get: function() {
                var s = void 0, u = this.media;
                return u && (s = u.height || u.clientHeight || u.offsetHeight, s *= l.contentScaleFactor), s;
              }
            }], [{
              key: "contentScaleFactor",
              get: function() {
                var s = 1;
                try {
                  s = window.devicePixelRatio;
                } catch {
                }
                return s;
              }
            }]), l;
          }(O), gr = ql;
          function nn(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function zl(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Xl(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var Ym = function(g) {
            Xl(l, g);
            function l(o) {
              return nn(this, l), zl(this, g.call(this, o, p.a.MEDIA_ATTACHING));
            }
            return l.prototype.destroy = function() {
              this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1;
            }, l.prototype.onMediaAttaching = function(s) {
              var u = this.hls.config;
              if (u.capLevelOnFPSDrop) {
                var f = this.video = s.media instanceof HTMLVideoElement ? s.media : null;
                typeof f.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), u.fpsDroppedMonitoringPeriod);
              }
            }, l.prototype.checkFPS = function(s, u, f) {
              var E = performance.now();
              if (u) {
                if (this.lastTime) {
                  var w = E - this.lastTime, R = f - this.lastDroppedFrames, C = u - this.lastDecodedFrames, k = 1e3 * R / w, P = this.hls;
                  if (P.trigger(p.a.FPS_DROP, { currentDropped: R, currentDecoded: C, totalDroppedFrames: f }), k > 0 && R > P.config.fpsDroppedMonitoringThreshold * C) {
                    var U = P.currentLevel;
                    d.b.warn("drop FPS ratio greater than max allowed value for currentLevel: " + U), U > 0 && (P.autoLevelCapping === -1 || P.autoLevelCapping >= U) && (U = U - 1, P.trigger(p.a.FPS_DROP_LEVEL_CAPPING, { level: U, droppedLevel: P.currentLevel }), P.autoLevelCapping = U, P.streamController.nextLevelSwitch());
                  }
                }
                this.lastTime = E, this.lastDroppedFrames = f, this.lastDecodedFrames = u;
              }
            }, l.prototype.checkFPSInterval = function() {
              var s = this.video;
              if (s)
                if (this.isVideoPlaybackQualityAvailable) {
                  var u = s.getVideoPlaybackQuality();
                  this.checkFPS(s, u.totalVideoFrames, u.droppedVideoFrames);
                } else
                  this.checkFPS(s, s.webkitDecodedFrameCount, s.webkitDroppedFrameCount);
            }, l;
          }(O), Jm = Ym;
          function Qm(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var ey = function() {
            function g(l) {
              Qm(this, g), l && l.xhrSetup && (this.xhrSetup = l.xhrSetup);
            }
            return g.prototype.destroy = function() {
              this.abort(), this.loader = null;
            }, g.prototype.abort = function() {
              var o = this.loader;
              o && o.readyState !== 4 && (this.stats.aborted = !0, o.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null;
            }, g.prototype.load = function(o, s, u) {
              this.context = o, this.config = s, this.callbacks = u, this.stats = { trequest: performance.now(), retry: 0 }, this.retryDelay = s.retryDelay, this.loadInternal();
            }, g.prototype.loadInternal = function() {
              var o, s = this.context;
              o = this.loader = new XMLHttpRequest();
              var u = this.stats;
              u.tfirst = 0, u.loaded = 0;
              var f = this.xhrSetup;
              try {
                if (f)
                  try {
                    f(o, s.url);
                  } catch {
                    o.open("GET", s.url, !0), f(o, s.url);
                  }
                o.readyState || o.open("GET", s.url, !0);
              } catch (E) {
                this.callbacks.onError({ code: o.status, text: E.message }, s, o);
                return;
              }
              s.rangeEnd && o.setRequestHeader("Range", "bytes=" + s.rangeStart + "-" + (s.rangeEnd - 1)), o.onreadystatechange = this.readystatechange.bind(this), o.onprogress = this.loadprogress.bind(this), o.responseType = s.responseType, this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), o.send();
            }, g.prototype.readystatechange = function(o) {
              var s = o.currentTarget, u = s.readyState, f = this.stats, E = this.context, w = this.config;
              if (!f.aborted && u >= 2)
                if (window.clearTimeout(this.requestTimeout), f.tfirst === 0 && (f.tfirst = Math.max(performance.now(), f.trequest)), u === 4) {
                  var R = s.status;
                  if (R >= 200 && R < 300) {
                    f.tload = Math.max(f.tfirst, performance.now());
                    var C = void 0, k = void 0;
                    E.responseType === "arraybuffer" ? (C = s.response, k = C.byteLength) : (C = s.responseText, k = C.length), f.loaded = f.total = k;
                    var P = { url: s.responseURL, data: C };
                    this.callbacks.onSuccess(P, f, E, s);
                  } else
                    f.retry >= w.maxRetry || R >= 400 && R < 499 ? (d.b.error(R + " while loading " + E.url), this.callbacks.onError({ code: R, text: s.statusText }, E, s)) : (d.b.warn(R + " while loading " + E.url + ", retrying in " + this.retryDelay + "..."), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, w.maxRetryDelay), f.retry++);
                } else
                  this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), w.timeout);
            }, g.prototype.loadtimeout = function() {
              d.b.warn("timeout while loading " + this.context.url), this.callbacks.onTimeout(this.stats, this.context, null);
            }, g.prototype.loadprogress = function(o) {
              var s = o.currentTarget, u = this.stats;
              u.loaded = o.loaded, o.lengthComputable && (u.total = o.total);
              var f = this.callbacks.onProgress;
              f && f(u, this.context, null, s);
            }, g;
          }(), ty = ey, ry = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function iy(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function ny(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function sy(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var ay = function(g) {
            sy(l, g);
            function l(o) {
              iy(this, l);
              var s = ny(this, g.call(this, o, p.a.MANIFEST_LOADING, p.a.MANIFEST_PARSED, p.a.AUDIO_TRACK_LOADED, p.a.ERROR));
              return s.ticks = 0, s.ontick = s.tick.bind(s), s;
            }
            return l.prototype.destroy = function() {
              this.cleanTimer(), O.prototype.destroy.call(this);
            }, l.prototype.cleanTimer = function() {
              this.timer && (clearTimeout(this.timer), this.timer = null);
            }, l.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, l.prototype.doTick = function() {
              this.updateTrack(this.trackId);
            }, l.prototype.onError = function(s) {
              s.fatal && s.type === y.b.NETWORK_ERROR && this.cleanTimer();
            }, l.prototype.onManifestLoading = function() {
              this.tracks = [], this.trackId = -1;
            }, l.prototype.onManifestParsed = function(s) {
              var u = this, f = s.audioTracks || [], E = !1;
              this.tracks = f, this.hls.trigger(p.a.AUDIO_TRACKS_UPDATED, { audioTracks: f });
              var w = 0;
              f.forEach(function(R) {
                if (R.default && !E) {
                  u.audioTrack = w, E = !0;
                  return;
                }
                w++;
              }), E === !1 && f.length && (d.b.log("no default audio track defined, use first audio track as default"), this.audioTrack = 0);
            }, l.prototype.onAudioTrackLoaded = function(s) {
              s.id < this.tracks.length && (d.b.log("audioTrack " + s.id + " loaded"), this.tracks[s.id].details = s.details, s.details.live && !this.timer && (this.timer = setInterval(this.ontick, 1e3 * s.details.targetduration)), !s.details.live && this.timer && this.cleanTimer());
            }, l.prototype.setAudioTrackInternal = function(s) {
              if (s >= 0 && s < this.tracks.length) {
                this.cleanTimer(), this.trackId = s, d.b.log("switching to audioTrack " + s);
                var u = this.tracks[s], f = this.hls, E = u.type, w = u.url, R = { id: s, type: E, url: w };
                f.trigger(p.a.AUDIO_TRACK_SWITCH, R), f.trigger(p.a.AUDIO_TRACK_SWITCHING, R);
                var C = u.details;
                w && (C === void 0 || C.live === !0) && (d.b.log("(re)loading playlist for audioTrack " + s), f.trigger(p.a.AUDIO_TRACK_LOADING, { url: w, id: s }));
              }
            }, l.prototype.updateTrack = function(s) {
              if (s >= 0 && s < this.tracks.length) {
                this.cleanTimer(), this.trackId = s, d.b.log("updating audioTrack " + s);
                var u = this.tracks[s], f = u.url, E = u.details;
                f && (E === void 0 || E.live === !0) && (d.b.log("(re)loading playlist for audioTrack " + s), this.hls.trigger(p.a.AUDIO_TRACK_LOADING, { url: f, id: s }));
              }
            }, ry(l, [{
              key: "audioTracks",
              get: function() {
                return this.tracks;
              }
              /** get index of the selected audio track (index in audio track lists) **/
            }, {
              key: "audioTrack",
              get: function() {
                return this.trackId;
              },
              set: function(s) {
                (this.trackId !== s || this.tracks[s].details === void 0) && this.setAudioTrackInternal(s);
              }
            }]), l;
          }(O), oy = ay, ly = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function uy(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function cy(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function dy(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var Ee = {
            STOPPED: "STOPPED",
            STARTING: "STARTING",
            IDLE: "IDLE",
            PAUSED: "PAUSED",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING",
            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
            WAITING_TRACK: "WAITING_TRACK",
            PARSING: "PARSING",
            PARSED: "PARSED",
            BUFFER_FLUSHING: "BUFFER_FLUSHING",
            ENDED: "ENDED",
            ERROR: "ERROR",
            WAITING_INIT_PTS: "WAITING_INIT_PTS"
          }, fy = function(g) {
            dy(l, g);
            function l(o) {
              uy(this, l);
              var s = cy(this, g.call(this, o, p.a.MEDIA_ATTACHED, p.a.MEDIA_DETACHING, p.a.AUDIO_TRACKS_UPDATED, p.a.AUDIO_TRACK_SWITCHING, p.a.AUDIO_TRACK_LOADED, p.a.KEY_LOADED, p.a.FRAG_LOADED, p.a.FRAG_PARSING_INIT_SEGMENT, p.a.FRAG_PARSING_DATA, p.a.FRAG_PARSED, p.a.ERROR, p.a.BUFFER_RESET, p.a.BUFFER_CREATED, p.a.BUFFER_APPENDED, p.a.BUFFER_FLUSHED, p.a.INIT_PTS_FOUND));
              return s.config = o.config, s.audioCodecSwap = !1, s.ticks = 0, s._state = Ee.STOPPED, s.ontick = s.tick.bind(s), s.initPTS = [], s.waitingFragment = null, s.videoTrackCC = null, s;
            }
            return l.prototype.destroy = function() {
              this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), O.prototype.destroy.call(this), this.state = Ee.STOPPED;
            }, l.prototype.onInitPtsFound = function(s) {
              var u = s.id, f = s.frag.cc, E = s.initPTS;
              u === "main" && (this.initPTS[f] = E, this.videoTrackCC = f, d.b.log("InitPTS for cc:" + f + " found from video track:" + E), this.state === Ee.WAITING_INIT_PTS && this.tick());
            }, l.prototype.startLoad = function(s) {
              if (this.tracks) {
                var u = this.lastCurrentTime;
                this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.fragLoadError = 0, u > 0 && s === -1 ? (d.b.log("audio:override startPosition with lastCurrentTime @" + u.toFixed(3)), this.state = Ee.IDLE) : (this.lastCurrentTime = this.startPosition ? this.startPosition : s, this.state = Ee.STARTING), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick();
              } else
                this.startPosition = s, this.state = Ee.STOPPED;
            }, l.prototype.stopLoad = function() {
              var s = this.fragCurrent;
              s && (s.loader && s.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = Ee.STOPPED;
            }, l.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, l.prototype.doTick = function() {
              var s, u, f, E = this.hls, w = E.config;
              switch (this.state) {
                case Ee.ERROR:
                case Ee.PAUSED:
                case Ee.BUFFER_FLUSHING:
                  break;
                case Ee.STARTING:
                  this.state = Ee.WAITING_TRACK, this.loadedmetadata = !1;
                  break;
                case Ee.IDLE:
                  var R = this.tracks;
                  if (!R || !this.media && (this.startFragRequested || !w.startFragPrefetch))
                    break;
                  if (this.loadedmetadata)
                    s = this.media.currentTime;
                  else if (s = this.nextLoadPosition, s === void 0)
                    break;
                  var C = this.mediaBuffer ? this.mediaBuffer : this.media, k = this.videoBuffer ? this.videoBuffer : this.media, P = ct.bufferInfo(C, s, w.maxBufferHole), U = ct.bufferInfo(k, s, w.maxBufferHole), F = P.len, te = P.end, he = this.fragPrevious, xe = Math.max(w.maxBufferLength, U.len), ge = this.audioSwitch, Ce = this.trackId;
                  if ((F < xe || ge) && Ce < R.length) {
                    if (f = R[Ce].details, typeof f > "u") {
                      this.state = Ee.WAITING_TRACK;
                      break;
                    }
                    if (!ge && !f.live && he && he.sn === f.endSN && !P.nextStart && (!this.media.seeking || this.media.duration - te < he.duration / 2)) {
                      this.hls.trigger(p.a.BUFFER_EOS, { type: "audio" }), this.state = Ee.ENDED;
                      break;
                    }
                    var Se = f.fragments, Pe = Se.length, Xe = Se[0].start, dt = Se[Pe - 1].start + Se[Pe - 1].duration, _e = void 0;
                    if (ge) {
                      if (f.live && !f.PTSKnown)
                        d.b.log("switching audiotrack, live stream, unknown PTS,load first fragment"), te = 0;
                      else if (te = s, f.PTSKnown && s < Xe)
                        if (P.end > Xe || P.nextStart)
                          d.b.log("alt audio track ahead of main track, seek to start of alt audio track"), this.media.currentTime = Xe + 0.05;
                        else
                          return;
                    }
                    if (f.initSegment && !f.initSegment.data)
                      _e = f.initSegment;
                    else if (te <= Xe) {
                      if (_e = Se[0], this.videoTrackCC !== null && _e.cc !== this.videoTrackCC && (_e = M(Se, this.videoTrackCC)), f.live && _e.loadIdx && _e.loadIdx === this.fragLoadIdx) {
                        var Pt = P.nextStart ? P.nextStart : Xe;
                        d.b.log("no alt audio available @currentTime:" + this.media.currentTime + ", seeking @" + (Pt + 0.05)), this.media.currentTime = Pt + 0.05;
                        return;
                      }
                    } else {
                      var it = void 0, sn = w.maxFragLookUpTolerance, ze = he ? Se[he.sn - Se[0].sn + 1] : void 0, Me = function(Ys) {
                        var Rd = Math.min(sn, Ys.duration);
                        return Ys.start + Ys.duration - Rd <= te ? 1 : Ys.start - Rd > te && Ys.start ? -1 : 0;
                      };
                      te < dt ? (te > dt - sn && (sn = 0), ze && !Me(ze) ? it = ze : it = Br.search(Se, Me)) : it = Se[Pe - 1], it && (_e = it, Xe = it.start, he && _e.level === he.level && _e.sn === he.sn && (_e.sn < f.endSN ? (_e = Se[_e.sn + 1 - f.startSN], d.b.log("SN just loaded, load next one: " + _e.sn)) : _e = null));
                    }
                    if (_e)
                      if (_e.decryptdata && _e.decryptdata.uri != null && _e.decryptdata.key == null)
                        d.b.log("Loading key for " + _e.sn + " of [" + f.startSN + " ," + f.endSN + "],track " + Ce), this.state = Ee.KEY_LOADING, E.trigger(p.a.KEY_LOADING, { frag: _e });
                      else {
                        if (d.b.log("Loading " + _e.sn + ", cc: " + _e.cc + " of [" + f.startSN + " ," + f.endSN + "],track " + Ce + ", currentTime:" + s + ",bufferEnd:" + te.toFixed(3)), this.fragLoadIdx !== void 0 ? this.fragLoadIdx++ : this.fragLoadIdx = 0, _e.loadCounter) {
                          _e.loadCounter++;
                          var Ft = w.fragLoadingLoopThreshold;
                          if (_e.loadCounter > Ft && Math.abs(this.fragLoadIdx - _e.loadIdx) < Ft) {
                            E.trigger(p.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.FRAG_LOOP_LOADING_ERROR, fatal: !1, frag: _e });
                            return;
                          }
                        } else
                          _e.loadCounter = 1;
                        _e.loadIdx = this.fragLoadIdx, this.fragCurrent = _e, this.startFragRequested = !0, isNaN(_e.sn) || (this.nextLoadPosition = _e.start + _e.duration), E.trigger(p.a.FRAG_LOADING, { frag: _e }), this.state = Ee.FRAG_LOADING;
                      }
                  }
                  break;
                case Ee.WAITING_TRACK:
                  u = this.tracks[this.trackId], u && u.details && (this.state = Ee.IDLE);
                  break;
                case Ee.FRAG_LOADING_WAITING_RETRY:
                  var Wl = performance.now(), xd = this.retryDate;
                  C = this.media;
                  var tb = C && C.seeking;
                  (!xd || Wl >= xd || tb) && (d.b.log("audioStreamController: retryDate reached, switch back to IDLE state"), this.state = Ee.IDLE);
                  break;
                case Ee.WAITING_INIT_PTS:
                  var sc = this.videoTrackCC;
                  if (this.initPTS[sc] === void 0)
                    break;
                  var Ed = this.waitingFragment;
                  if (Ed) {
                    var vd = Ed.frag.cc;
                    sc !== vd ? (u = this.tracks[this.trackId], u.details && u.details.live && (d.b.warn("Waiting fragment CC (" + vd + ") does not match video track CC (" + sc + ")"), this.waitingFragment = null, this.state = Ee.IDLE)) : (this.state = Ee.FRAG_LOADING, this.onFragLoaded(this.waitingFragment), this.waitingFragment = null);
                  } else
                    this.state = Ee.IDLE;
                  break;
              }
            }, l.prototype.onMediaAttached = function(s) {
              var u = this.media = this.mediaBuffer = s.media;
              this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), u.addEventListener("seeking", this.onvseeking), u.addEventListener("ended", this.onvended);
              var f = this.config;
              this.tracks && f.autoStartLoad && this.startLoad(f.startPosition);
            }, l.prototype.onMediaDetaching = function() {
              var s = this.media;
              s && s.ended && (d.b.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
              var u = this.tracks;
              u && u.forEach(function(f) {
                f.details && f.details.fragments.forEach(function(E) {
                  E.loadCounter = void 0;
                });
              }), s && (s.removeEventListener("seeking", this.onvseeking), s.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1, this.stopLoad();
            }, l.prototype.onMediaSeeking = function() {
              this.state === Ee.ENDED && (this.state = Ee.IDLE), this.media && (this.lastCurrentTime = this.media.currentTime), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.tick();
            }, l.prototype.onMediaEnded = function() {
              this.startPosition = this.lastCurrentTime = 0;
            }, l.prototype.onAudioTracksUpdated = function(s) {
              d.b.log("audio tracks updated"), this.tracks = s.audioTracks;
            }, l.prototype.onAudioTrackSwitching = function(s) {
              var u = !!s.url;
              this.trackId = s.id, this.fragCurrent = null, this.state = Ee.PAUSED, this.waitingFragment = null, u ? this.timer || (this.timer = setInterval(this.ontick, 100)) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), u && (this.audioSwitch = !0, this.state = Ee.IDLE, this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold)), this.tick();
            }, l.prototype.onAudioTrackLoaded = function(s) {
              var u = s.details, f = s.id, E = this.tracks[f], w = u.totalduration, R = 0;
              if (d.b.log("track " + f + " loaded [" + u.startSN + "," + u.endSN + "],duration:" + w), u.live) {
                var C = E.details;
                C && u.fragments.length > 0 ? (S(C, u), R = u.fragments[0].start, u.PTSKnown ? d.b.log("live audio playlist sliding:" + R.toFixed(3)) : d.b.log("live audio playlist - outdated PTS, unknown sliding")) : (u.PTSKnown = !1, d.b.log("live audio playlist - first load, unknown sliding"));
              } else
                u.PTSKnown = !1;
              if (E.details = u, !this.startFragRequested) {
                if (this.startPosition === -1) {
                  var k = u.startTimeOffset;
                  isNaN(k) ? this.startPosition = 0 : (d.b.log("start time offset found in playlist, adjust startPosition to " + k), this.startPosition = k);
                }
                this.nextLoadPosition = this.startPosition;
              }
              this.state === Ee.WAITING_TRACK && (this.state = Ee.IDLE), this.tick();
            }, l.prototype.onKeyLoaded = function() {
              this.state === Ee.KEY_LOADING && (this.state = Ee.IDLE, this.tick());
            }, l.prototype.onFragLoaded = function(s) {
              var u = this.fragCurrent, f = s.frag;
              if (this.state === Ee.FRAG_LOADING && u && f.type === "audio" && f.level === u.level && f.sn === u.sn) {
                var E = this.tracks[this.trackId], w = E.details, R = w.totalduration, C = u.level, k = u.sn, P = u.cc, U = this.config.defaultAudioCodec || E.audioCodec || "mp4a.40.2", F = this.stats = s.stats;
                if (k === "initSegment")
                  this.state = Ee.IDLE, F.tparsed = F.tbuffered = performance.now(), w.initSegment.data = s.payload, this.hls.trigger(p.a.FRAG_BUFFERED, { stats: F, frag: u, id: "audio" }), this.tick();
                else {
                  this.state = Ee.PARSING, this.appended = !1, this.demuxer || (this.demuxer = new I(this.hls, "audio"));
                  var te = this.initPTS[P], he = w.initSegment ? w.initSegment.data : [];
                  if (w.initSegment || te !== void 0) {
                    this.pendingBuffering = !0, d.b.log("Demuxing " + k + " of [" + w.startSN + " ," + w.endSN + "],track " + C);
                    var xe = !1;
                    this.demuxer.push(s.payload, he, U, null, u, R, xe, te);
                  } else
                    d.b.log("unknown video PTS for continuity counter " + P + ", waiting for video PTS before demuxing audio frag " + k + " of [" + w.startSN + " ," + w.endSN + "],track " + C), this.waitingFragment = s, this.state = Ee.WAITING_INIT_PTS;
                }
              }
              this.fragLoadError = 0;
            }, l.prototype.onFragParsingInitSegment = function(s) {
              var u = this.fragCurrent, f = s.frag;
              if (u && s.id === "audio" && f.sn === u.sn && f.level === u.level && this.state === Ee.PARSING) {
                var E = s.tracks, w = void 0;
                if (E.video && delete E.video, w = E.audio, w) {
                  w.levelCodec = w.codec, w.id = s.id, this.hls.trigger(p.a.BUFFER_CODECS, E), d.b.log("audio track:audio,container:" + w.container + ",codecs[level/parsed]=[" + w.levelCodec + "/" + w.codec + "]");
                  var R = w.initSegment;
                  if (R) {
                    var C = { type: "audio", data: R, parent: "audio", content: "initSegment" };
                    this.audioSwitch ? this.pendingData = [C] : (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(p.a.BUFFER_APPENDING, C));
                  }
                  this.tick();
                }
              }
            }, l.prototype.onFragParsingData = function(s) {
              var u = this, f = this.fragCurrent, E = s.frag;
              if (f && s.id === "audio" && s.type === "audio" && E.sn === f.sn && E.level === f.level && this.state === Ee.PARSING) {
                var w = this.trackId, R = this.tracks[w], C = this.hls;
                isNaN(s.endPTS) && (s.endPTS = s.startPTS + f.duration, s.endDTS = s.startDTS + f.duration), d.b.log("parsed " + s.type + ",PTS:[" + s.startPTS.toFixed(3) + "," + s.endPTS.toFixed(3) + "],DTS:[" + s.startDTS.toFixed(3) + "/" + s.endDTS.toFixed(3) + "],nb:" + s.nb), T(R.details, f, s.startPTS, s.endPTS);
                var k = this.audioSwitch, P = this.media, U = !1;
                if (k && P)
                  if (P.readyState) {
                    var F = P.currentTime;
                    d.b.log("switching audio track : currentTime:" + F), F >= s.startPTS && (d.b.log("switching audio track : flushing all audio"), this.state = Ee.BUFFER_FLUSHING, C.trigger(p.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), U = !0, this.audioSwitch = !1, C.trigger(p.a.AUDIO_TRACK_SWITCHED, { id: w }));
                  } else
                    this.audioSwitch = !1, C.trigger(p.a.AUDIO_TRACK_SWITCHED, { id: w });
                var te = this.pendingData;
                this.audioSwitch || ([s.data1, s.data2].forEach(function(he) {
                  he && he.length && te.push({ type: s.type, data: he, parent: "audio", content: "data" });
                }), !U && te.length && (te.forEach(function(he) {
                  u.state === Ee.PARSING && (u.pendingBuffering = !0, u.hls.trigger(p.a.BUFFER_APPENDING, he));
                }), this.pendingData = [], this.appended = !0)), this.tick();
              }
            }, l.prototype.onFragParsed = function(s) {
              var u = this.fragCurrent, f = s.frag;
              u && s.id === "audio" && f.sn === u.sn && f.level === u.level && this.state === Ee.PARSING && (this.stats.tparsed = performance.now(), this.state = Ee.PARSED, this._checkAppendedParsed());
            }, l.prototype.onBufferReset = function() {
              this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1;
            }, l.prototype.onBufferCreated = function(s) {
              var u = s.tracks.audio;
              u && (this.mediaBuffer = u.buffer, this.loadedmetadata = !0), s.tracks.video && (this.videoBuffer = s.tracks.video.buffer);
            }, l.prototype.onBufferAppended = function(s) {
              if (s.parent === "audio") {
                var u = this.state;
                (u === Ee.PARSING || u === Ee.PARSED) && (this.pendingBuffering = s.pending > 0, this._checkAppendedParsed());
              }
            }, l.prototype._checkAppendedParsed = function() {
              if (this.state === Ee.PARSED && (!this.appended || !this.pendingBuffering)) {
                var s = this.fragCurrent, u = this.stats, f = this.hls;
                if (s) {
                  this.fragPrevious = s, u.tbuffered = performance.now(), f.trigger(p.a.FRAG_BUFFERED, { stats: u, frag: s, id: "audio" });
                  var E = this.mediaBuffer ? this.mediaBuffer : this.media;
                  d.b.log("audio buffered : " + D.toString(E.buffered)), this.audioSwitch && this.appended && (this.audioSwitch = !1, f.trigger(p.a.AUDIO_TRACK_SWITCHED, { id: this.trackId })), this.state = Ee.IDLE;
                }
                this.tick();
              }
            }, l.prototype.onError = function(s) {
              var u = s.frag;
              if (!(u && u.type !== "audio"))
                switch (s.details) {
                  case y.a.FRAG_LOAD_ERROR:
                  case y.a.FRAG_LOAD_TIMEOUT:
                    if (!s.fatal) {
                      var f = this.fragLoadError;
                      f ? f++ : f = 1;
                      var E = this.config;
                      if (f <= E.fragLoadingMaxRetry) {
                        this.fragLoadError = f, u.loadCounter = 0;
                        var w = Math.min(Math.pow(2, f - 1) * E.fragLoadingRetryDelay, E.fragLoadingMaxRetryTimeout);
                        d.b.warn("audioStreamController: frag loading failed, retry in " + w + " ms"), this.retryDate = performance.now() + w, this.state = Ee.FRAG_LOADING_WAITING_RETRY;
                      } else
                        d.b.error("audioStreamController: " + s.details + " reaches max retry, redispatch as fatal ..."), s.fatal = !0, this.state = Ee.ERROR;
                    }
                    break;
                  case y.a.FRAG_LOOP_LOADING_ERROR:
                  case y.a.AUDIO_TRACK_LOAD_ERROR:
                  case y.a.AUDIO_TRACK_LOAD_TIMEOUT:
                  case y.a.KEY_LOAD_ERROR:
                  case y.a.KEY_LOAD_TIMEOUT:
                    this.state !== Ee.ERROR && (this.state = s.fatal ? Ee.ERROR : Ee.IDLE, d.b.warn("audioStreamController: " + s.details + " while loading frag,switch to " + this.state + " state ..."));
                    break;
                  case y.a.BUFFER_FULL_ERROR:
                    if (s.parent === "audio" && (this.state === Ee.PARSING || this.state === Ee.PARSED)) {
                      var R = this.mediaBuffer, C = this.media.currentTime, k = R && ct.isBuffered(R, C) && ct.isBuffered(R, C + 0.5);
                      if (k) {
                        var P = this.config;
                        P.maxMaxBufferLength >= P.maxBufferLength && (P.maxMaxBufferLength /= 2, d.b.warn("audio:reduce max buffer length to " + P.maxMaxBufferLength + "s"), this.fragLoadIdx += 2 * P.fragLoadingLoopThreshold), this.state = Ee.IDLE;
                      } else
                        d.b.warn("buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, this.state = Ee.BUFFER_FLUSHING, this.hls.trigger(p.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" });
                    }
                    break;
                }
            }, l.prototype.onBufferFlushed = function() {
              var s = this, u = this.pendingData;
              u && u.length ? (d.b.log("appending pending audio data on Buffer Flushed"), u.forEach(function(f) {
                s.hls.trigger(p.a.BUFFER_APPENDING, f);
              }), this.appended = !0, this.pendingData = [], this.state = Ee.PARSED) : (this.state = Ee.IDLE, this.fragPrevious = null, this.tick());
            }, ly(l, [{
              key: "state",
              set: function(s) {
                if (this.state !== s) {
                  var u = this.state;
                  this._state = s, d.b.log("audio stream:" + u + "->" + s);
                }
              },
              get: function() {
                return this._state;
              }
            }]), l;
          }(O), py = fy, od = function() {
            if (typeof window < "u" && window.VTTCue)
              return window.VTTCue;
            var g = "auto", l = {
              "": !0,
              lr: !0,
              rl: !0
            }, o = {
              start: !0,
              middle: !0,
              end: !0,
              left: !0,
              right: !0
            };
            function s(w) {
              if (typeof w != "string")
                return !1;
              var R = l[w.toLowerCase()];
              return R ? w.toLowerCase() : !1;
            }
            function u(w) {
              if (typeof w != "string")
                return !1;
              var R = o[w.toLowerCase()];
              return R ? w.toLowerCase() : !1;
            }
            function f(w) {
              for (var R = 1; R < arguments.length; R++) {
                var C = arguments[R];
                for (var k in C)
                  w[k] = C[k];
              }
              return w;
            }
            function E(w, R, C) {
              var k = this, P = function() {
                if (!(typeof navigator > "u"))
                  return /MSIE\s8\.0/.test(navigator.userAgent);
              }(), U = {};
              P ? k = document.createElement("custom") : U.enumerable = !0, k.hasBeenReset = !1;
              var F = "", te = !1, he = w, xe = R, ge = C, Ce = null, Se = "", Pe = !0, Xe = "auto", dt = "start", _e = 50, Pt = "middle", it = 50, sn = "middle";
              if (Object.defineProperty(k, "id", f({}, U, {
                get: function() {
                  return F;
                },
                set: function(Me) {
                  F = "" + Me;
                }
              })), Object.defineProperty(k, "pauseOnExit", f({}, U, {
                get: function() {
                  return te;
                },
                set: function(Me) {
                  te = !!Me;
                }
              })), Object.defineProperty(k, "startTime", f({}, U, {
                get: function() {
                  return he;
                },
                set: function(Me) {
                  if (typeof Me != "number")
                    throw new TypeError("Start time must be set to a number.");
                  he = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "endTime", f({}, U, {
                get: function() {
                  return xe;
                },
                set: function(Me) {
                  if (typeof Me != "number")
                    throw new TypeError("End time must be set to a number.");
                  xe = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "text", f({}, U, {
                get: function() {
                  return ge;
                },
                set: function(Me) {
                  ge = "" + Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "region", f({}, U, {
                get: function() {
                  return Ce;
                },
                set: function(Me) {
                  Ce = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "vertical", f({}, U, {
                get: function() {
                  return Se;
                },
                set: function(Me) {
                  var Ft = s(Me);
                  if (Ft === !1)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  Se = Ft, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "snapToLines", f({}, U, {
                get: function() {
                  return Pe;
                },
                set: function(Me) {
                  Pe = !!Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "line", f({}, U, {
                get: function() {
                  return Xe;
                },
                set: function(Me) {
                  if (typeof Me != "number" && Me !== g)
                    throw new SyntaxError("An invalid number or illegal string was specified.");
                  Xe = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "lineAlign", f({}, U, {
                get: function() {
                  return dt;
                },
                set: function(Me) {
                  var Ft = u(Me);
                  if (!Ft)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  dt = Ft, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "position", f({}, U, {
                get: function() {
                  return _e;
                },
                set: function(Me) {
                  if (Me < 0 || Me > 100)
                    throw new Error("Position must be between 0 and 100.");
                  _e = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "positionAlign", f({}, U, {
                get: function() {
                  return Pt;
                },
                set: function(Me) {
                  var Ft = u(Me);
                  if (!Ft)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  Pt = Ft, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "size", f({}, U, {
                get: function() {
                  return it;
                },
                set: function(Me) {
                  if (Me < 0 || Me > 100)
                    throw new Error("Size must be between 0 and 100.");
                  it = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "align", f({}, U, {
                get: function() {
                  return sn;
                },
                set: function(Me) {
                  var Ft = u(Me);
                  if (!Ft)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  sn = Ft, this.hasBeenReset = !0;
                }
              })), k.displayState = void 0, P)
                return k;
            }
            return E.prototype.getCueAsHTML = function() {
              var w = window.WebVTT;
              return w.convertCueToDOMTree(window, this.text);
            }, E;
          }(), hy = function() {
            return {
              decode: function(o) {
                if (!o)
                  return "";
                if (typeof o != "string")
                  throw new Error("Error - expected string data.");
                return decodeURIComponent(encodeURIComponent(o));
              }
            };
          };
          function ld() {
            this.window = window, this.state = "INITIAL", this.buffer = "", this.decoder = new hy(), this.regionList = [];
          }
          function my(g) {
            function l(s, u, f, E) {
              return (s | 0) * 3600 + (u | 0) * 60 + (f | 0) + (E | 0) / 1e3;
            }
            var o = g.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
            return o ? o[3] ? l(o[1], o[2], o[3].replace(":", ""), o[4]) : o[1] > 59 ? l(o[1], o[2], 0, o[4]) : l(0, o[1], o[2], o[4]) : null;
          }
          function ud() {
            this.values = /* @__PURE__ */ Object.create(null);
          }
          ud.prototype = {
            // Only accept the first assignment to any key.
            set: function(l, o) {
              !this.get(l) && o !== "" && (this.values[l] = o);
            },
            // Return the value for a key, or a default value.
            // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
            // a number of possible default values as properties where 'defaultKey' is
            // the key of the property that will be chosen; otherwise it's assumed to be
            // a single value.
            get: function(l, o, s) {
              return s ? this.has(l) ? this.values[l] : o[s] : this.has(l) ? this.values[l] : o;
            },
            // Check whether we have a value for a key.
            has: function(l) {
              return l in this.values;
            },
            // Accept a setting if its one of the given alternatives.
            alt: function(l, o, s) {
              for (var u = 0; u < s.length; ++u)
                if (o === s[u]) {
                  this.set(l, o);
                  break;
                }
            },
            // Accept a setting if its a valid (signed) integer.
            integer: function(l, o) {
              /^-?\d+$/.test(o) && this.set(l, parseInt(o, 10));
            },
            // Accept a setting if its a valid percentage.
            percent: function(l, o) {
              return o.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (o = parseFloat(o), o >= 0 && o <= 100) ? (this.set(l, o), !0) : !1;
            }
          };
          function cd(g, l, o, s) {
            var u = s ? g.split(s) : [g];
            for (var f in u)
              if (typeof u[f] == "string") {
                var E = u[f].split(o);
                if (E.length === 2) {
                  var w = E[0], R = E[1];
                  l(w, R);
                }
              }
          }
          var tc = new od(0, 0, 0), Hl = tc.align === "middle" ? "middle" : "center";
          function yy(g, l, o) {
            var s = g;
            function u() {
              var w = my(g);
              if (w === null)
                throw new Error("Malformed timestamp: " + s);
              return g = g.replace(/^[^\sa-zA-Z-]+/, ""), w;
            }
            function f(w, R) {
              var C = new ud();
              cd(w, function(U, F) {
                switch (U) {
                  case "region":
                    for (var te = o.length - 1; te >= 0; te--)
                      if (o[te].id === F) {
                        C.set(U, o[te].region);
                        break;
                      }
                    break;
                  case "vertical":
                    C.alt(U, F, ["rl", "lr"]);
                    break;
                  case "line":
                    var he = F.split(","), xe = he[0];
                    C.integer(U, xe), C.percent(U, xe) && C.set("snapToLines", !1), C.alt(U, xe, ["auto"]), he.length === 2 && C.alt("lineAlign", he[1], ["start", Hl, "end"]);
                    break;
                  case "position":
                    he = F.split(","), C.percent(U, he[0]), he.length === 2 && C.alt("positionAlign", he[1], ["start", Hl, "end", "line-left", "line-right", "auto"]);
                    break;
                  case "size":
                    C.percent(U, F);
                    break;
                  case "align":
                    C.alt(U, F, ["start", Hl, "end", "left", "right"]);
                    break;
                }
              }, /:/, /\s/), R.region = C.get("region", null), R.vertical = C.get("vertical", "");
              var k = C.get("line", "auto");
              k === "auto" && tc.line === -1 && (k = -1), R.line = k, R.lineAlign = C.get("lineAlign", "start"), R.snapToLines = C.get("snapToLines", !0), R.size = C.get("size", 100), R.align = C.get("align", Hl);
              var P = C.get("position", "auto");
              P === "auto" && tc.position === 50 && (P = R.align === "start" || R.align === "left" ? 0 : R.align === "end" || R.align === "right" ? 100 : 50), R.position = P;
            }
            function E() {
              g = g.replace(/^\s+/, "");
            }
            if (E(), l.startTime = u(), E(), g.substr(0, 3) !== "-->")
              throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + s);
            g = g.substr(3), E(), l.endTime = u(), E(), f(g, l);
          }
          function dd(g) {
            return g.replace(/<br(?: \/)?>/gi, `
`);
          }
          ld.prototype = {
            parse: function(l) {
              var o = this;
              l && (o.buffer += o.decoder.decode(l, { stream: !0 }));
              function s() {
                var C = o.buffer, k = 0;
                for (C = dd(C); k < C.length && C[k] !== "\r" && C[k] !== `
`; )
                  ++k;
                var P = C.substr(0, k);
                return C[k] === "\r" && ++k, C[k] === `
` && ++k, o.buffer = C.substr(k), P;
              }
              function u(C) {
                cd(C, function(k, P) {
                  switch (k) {
                    case "Region":
                      console.log("parse region", P);
                      break;
                  }
                }, /:/);
              }
              try {
                var f;
                if (o.state === "INITIAL") {
                  if (!/\r\n|\n/.test(o.buffer))
                    return this;
                  f = s();
                  var E = f.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                  if (!E || !E[0])
                    throw new Error("Malformed WebVTT signature.");
                  o.state = "HEADER";
                }
                for (var w = !1; o.buffer; ) {
                  if (!/\r\n|\n/.test(o.buffer))
                    return this;
                  switch (w ? w = !1 : f = s(), o.state) {
                    case "HEADER":
                      /:/.test(f) ? u(f) : f || (o.state = "ID");
                      continue;
                    case "NOTE":
                      f || (o.state = "ID");
                      continue;
                    case "ID":
                      if (/^NOTE($|[ \t])/.test(f)) {
                        o.state = "NOTE";
                        break;
                      }
                      if (!f)
                        continue;
                      if (o.cue = new od(0, 0, ""), o.state = "CUE", f.indexOf("-->") === -1) {
                        o.cue.id = f;
                        continue;
                      }
                    case "CUE":
                      try {
                        yy(f, o.cue, o.regionList);
                      } catch {
                        o.cue = null, o.state = "BADCUE";
                        continue;
                      }
                      o.state = "CUETEXT";
                      continue;
                    case "CUETEXT":
                      var R = f.indexOf("-->") !== -1;
                      if (!f || R && (w = !0)) {
                        o.oncue && o.oncue(o.cue), o.cue = null, o.state = "ID";
                        continue;
                      }
                      o.cue.text && (o.cue.text += `
`), o.cue.text += f;
                      continue;
                    case "BADCUE":
                      f || (o.state = "ID");
                      continue;
                  }
                }
              } catch {
                o.state === "CUETEXT" && o.cue && o.oncue && o.oncue(o.cue), o.cue = null, o.state = o.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
              }
              return this;
            },
            flush: function() {
              var l = this;
              try {
                if (l.buffer += l.decoder.decode(), (l.cue || l.state === "HEADER") && (l.buffer += `

`, l.parse()), l.state === "INITIAL")
                  throw new Error("Malformed WebVTT signature.");
              } catch (o) {
                throw o;
              }
              return l.onflush && l.onflush(), this;
            }
          };
          var by = ld;
          function gy(g, l, o, s) {
            for (var u, f, E, w, R, C = window.VTTCue || window.TextTrackCue, k = 0; k < s.rows.length; k++)
              if (u = s.rows[k], E = !0, w = 0, R = "", !u.isEmpty()) {
                for (var P = 0; P < u.chars.length; P++)
                  u.chars[P].uchar.match(/\s/) && E ? w++ : (R += u.chars[P].uchar, E = !1);
                u.cueStartTime = l, l === o && (o += 1e-4), f = new C(l, o, dd(R.trim())), w >= 16 ? w-- : w++, navigator.userAgent.match(/Firefox\//) ? f.line = k + 1 : f.line = k > 7 ? k - 2 : k + 1, f.align = "left", f.position = Math.max(0, Math.min(100, 100 * (w / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0))), g.addCue(f);
              }
          }
          function fs(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var fd = {
            42: 225,
            // lowercase a, acute accent
            92: 233,
            // lowercase e, acute accent
            94: 237,
            // lowercase i, acute accent
            95: 243,
            // lowercase o, acute accent
            96: 250,
            // lowercase u, acute accent
            123: 231,
            // lowercase c with cedilla
            124: 247,
            // division symbol
            125: 209,
            // uppercase N tilde
            126: 241,
            // lowercase n tilde
            127: 9608,
            // Full block
            // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
            // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
            128: 174,
            // Registered symbol (R)
            129: 176,
            // degree sign
            130: 189,
            // 1/2 symbol
            131: 191,
            // Inverted (open) question mark
            132: 8482,
            // Trademark symbol (TM)
            133: 162,
            // Cents symbol
            134: 163,
            // Pounds sterling
            135: 9834,
            // Music 8'th note
            136: 224,
            // lowercase a, grave accent
            137: 32,
            // transparent space (regular)
            138: 232,
            // lowercase e, grave accent
            139: 226,
            // lowercase a, circumflex accent
            140: 234,
            // lowercase e, circumflex accent
            141: 238,
            // lowercase i, circumflex accent
            142: 244,
            // lowercase o, circumflex accent
            143: 251,
            // lowercase u, circumflex accent
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
            144: 193,
            // capital letter A with acute
            145: 201,
            // capital letter E with acute
            146: 211,
            // capital letter O with acute
            147: 218,
            // capital letter U with acute
            148: 220,
            // capital letter U with diaresis
            149: 252,
            // lowercase letter U with diaeresis
            150: 8216,
            // opening single quote
            151: 161,
            // inverted exclamation mark
            152: 42,
            // asterisk
            153: 8217,
            // closing single quote
            154: 9473,
            // box drawings heavy horizontal
            155: 169,
            // copyright sign
            156: 8480,
            // Service mark
            157: 8226,
            // (round) bullet
            158: 8220,
            // Left double quotation mark
            159: 8221,
            // Right double quotation mark
            160: 192,
            // uppercase A, grave accent
            161: 194,
            // uppercase A, circumflex
            162: 199,
            // uppercase C with cedilla
            163: 200,
            // uppercase E, grave accent
            164: 202,
            // uppercase E, circumflex
            165: 203,
            // capital letter E with diaresis
            166: 235,
            // lowercase letter e with diaresis
            167: 206,
            // uppercase I, circumflex
            168: 207,
            // uppercase I, with diaresis
            169: 239,
            // lowercase i, with diaresis
            170: 212,
            // uppercase O, circumflex
            171: 217,
            // uppercase U, grave accent
            172: 249,
            // lowercase u, grave accent
            173: 219,
            // uppercase U, circumflex
            174: 171,
            // left-pointing double angle quotation mark
            175: 187,
            // right-pointing double angle quotation mark
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
            176: 195,
            // Uppercase A, tilde
            177: 227,
            // Lowercase a, tilde
            178: 205,
            // Uppercase I, acute accent
            179: 204,
            // Uppercase I, grave accent
            180: 236,
            // Lowercase i, grave accent
            181: 210,
            // Uppercase O, grave accent
            182: 242,
            // Lowercase o, grave accent
            183: 213,
            // Uppercase O, tilde
            184: 245,
            // Lowercase o, tilde
            185: 123,
            // Open curly brace
            186: 125,
            // Closing curly brace
            187: 92,
            // Backslash
            188: 94,
            // Caret
            189: 95,
            // Underscore
            190: 124,
            // Pipe (vertical line)
            191: 8764,
            // Tilde operator
            192: 196,
            // Uppercase A, umlaut
            193: 228,
            // Lowercase A, umlaut
            194: 214,
            // Uppercase O, umlaut
            195: 246,
            // Lowercase o, umlaut
            196: 223,
            // Esszett (sharp S)
            197: 165,
            // Yen symbol
            198: 164,
            // Generic currency sign
            199: 9475,
            // Box drawings heavy vertical
            200: 197,
            // Uppercase A, ring
            201: 229,
            // Lowercase A, ring
            202: 216,
            // Uppercase O, stroke
            203: 248,
            // Lowercase o, strok
            204: 9487,
            // Box drawings heavy down and right
            205: 9491,
            // Box drawings heavy down and left
            206: 9495,
            // Box drawings heavy up and right
            207: 9499
            // Box drawings heavy up and left
          }, pd = function(l) {
            var o = l;
            return fd.hasOwnProperty(l) && (o = fd[l]), String.fromCharCode(o);
          }, Ur = 15, Si = 100, xy = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, Ey = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, vy = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, Ry = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, Ay = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"], je = {
            verboseFilter: { DATA: 3, DEBUG: 3, INFO: 2, WARNING: 2, TEXT: 1, ERROR: 0 },
            time: null,
            verboseLevel: 0,
            // Only write errors
            setTime: function(l) {
              this.time = l;
            },
            log: function(l, o) {
              var s = this.verboseFilter[l];
              this.verboseLevel >= s && console.log(this.time + " [" + l + "] " + o);
            }
          }, Pn = function(l) {
            for (var o = [], s = 0; s < l.length; s++)
              o.push(l[s].toString(16));
            return o;
          }, hd = function() {
            function g(l, o, s, u, f) {
              fs(this, g), this.foreground = l || "white", this.underline = o || !1, this.italics = s || !1, this.background = u || "black", this.flash = f || !1;
            }
            return g.prototype.reset = function() {
              this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
            }, g.prototype.setStyles = function(o) {
              for (var s = ["foreground", "underline", "italics", "background", "flash"], u = 0; u < s.length; u++) {
                var f = s[u];
                o.hasOwnProperty(f) && (this[f] = o[f]);
              }
            }, g.prototype.isDefault = function() {
              return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
            }, g.prototype.equals = function(o) {
              return this.foreground === o.foreground && this.underline === o.underline && this.italics === o.italics && this.background === o.background && this.flash === o.flash;
            }, g.prototype.copy = function(o) {
              this.foreground = o.foreground, this.underline = o.underline, this.italics = o.italics, this.background = o.background, this.flash = o.flash;
            }, g.prototype.toString = function() {
              return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
            }, g;
          }(), _y = function() {
            function g(l, o, s, u, f, E) {
              fs(this, g), this.uchar = l || " ", this.penState = new hd(o, s, u, f, E);
            }
            return g.prototype.reset = function() {
              this.uchar = " ", this.penState.reset();
            }, g.prototype.setChar = function(o, s) {
              this.uchar = o, this.penState.copy(s);
            }, g.prototype.setPenState = function(o) {
              this.penState.copy(o);
            }, g.prototype.equals = function(o) {
              return this.uchar === o.uchar && this.penState.equals(o.penState);
            }, g.prototype.copy = function(o) {
              this.uchar = o.uchar, this.penState.copy(o.penState);
            }, g.prototype.isEmpty = function() {
              return this.uchar === " " && this.penState.isDefault();
            }, g;
          }(), wy = function() {
            function g() {
              fs(this, g), this.chars = [];
              for (var l = 0; l < Si; l++)
                this.chars.push(new _y());
              this.pos = 0, this.currPenState = new hd();
            }
            return g.prototype.equals = function(o) {
              for (var s = !0, u = 0; u < Si; u++)
                if (!this.chars[u].equals(o.chars[u])) {
                  s = !1;
                  break;
                }
              return s;
            }, g.prototype.copy = function(o) {
              for (var s = 0; s < Si; s++)
                this.chars[s].copy(o.chars[s]);
            }, g.prototype.isEmpty = function() {
              for (var o = !0, s = 0; s < Si; s++)
                if (!this.chars[s].isEmpty()) {
                  o = !1;
                  break;
                }
              return o;
            }, g.prototype.setCursor = function(o) {
              this.pos !== o && (this.pos = o), this.pos < 0 ? (je.log("ERROR", "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Si && (je.log("ERROR", "Too large cursor position " + this.pos), this.pos = Si);
            }, g.prototype.moveCursor = function(o) {
              var s = this.pos + o;
              if (o > 1)
                for (var u = this.pos + 1; u < s + 1; u++)
                  this.chars[u].setPenState(this.currPenState);
              this.setCursor(s);
            }, g.prototype.backSpace = function() {
              this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
            }, g.prototype.insertChar = function(o) {
              o >= 144 && this.backSpace();
              var s = pd(o);
              if (this.pos >= Si) {
                je.log("ERROR", "Cannot insert " + o.toString(16) + " (" + s + ") at position " + this.pos + ". Skipping it!");
                return;
              }
              this.chars[this.pos].setChar(s, this.currPenState), this.moveCursor(1);
            }, g.prototype.clearFromPos = function(o) {
              var s;
              for (s = o; s < Si; s++)
                this.chars[s].reset();
            }, g.prototype.clear = function() {
              this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
            }, g.prototype.clearToEndOfRow = function() {
              this.clearFromPos(this.pos);
            }, g.prototype.getTextString = function() {
              for (var o = [], s = !0, u = 0; u < Si; u++) {
                var f = this.chars[u].uchar;
                f !== " " && (s = !1), o.push(f);
              }
              return s ? "" : o.join("");
            }, g.prototype.setPenStyles = function(o) {
              this.currPenState.setStyles(o);
              var s = this.chars[this.pos];
              s.setPenState(this.currPenState);
            }, g;
          }(), rc = function() {
            function g() {
              fs(this, g), this.rows = [];
              for (var l = 0; l < Ur; l++)
                this.rows.push(new wy());
              this.currRow = Ur - 1, this.nrRollUpRows = null, this.reset();
            }
            return g.prototype.reset = function() {
              for (var o = 0; o < Ur; o++)
                this.rows[o].clear();
              this.currRow = Ur - 1;
            }, g.prototype.equals = function(o) {
              for (var s = !0, u = 0; u < Ur; u++)
                if (!this.rows[u].equals(o.rows[u])) {
                  s = !1;
                  break;
                }
              return s;
            }, g.prototype.copy = function(o) {
              for (var s = 0; s < Ur; s++)
                this.rows[s].copy(o.rows[s]);
            }, g.prototype.isEmpty = function() {
              for (var o = !0, s = 0; s < Ur; s++)
                if (!this.rows[s].isEmpty()) {
                  o = !1;
                  break;
                }
              return o;
            }, g.prototype.backSpace = function() {
              var o = this.rows[this.currRow];
              o.backSpace();
            }, g.prototype.clearToEndOfRow = function() {
              var o = this.rows[this.currRow];
              o.clearToEndOfRow();
            }, g.prototype.insertChar = function(o) {
              var s = this.rows[this.currRow];
              s.insertChar(o);
            }, g.prototype.setPen = function(o) {
              var s = this.rows[this.currRow];
              s.setPenStyles(o);
            }, g.prototype.moveCursor = function(o) {
              var s = this.rows[this.currRow];
              s.moveCursor(o);
            }, g.prototype.setCursor = function(o) {
              je.log("INFO", "setCursor: " + o);
              var s = this.rows[this.currRow];
              s.setCursor(o);
            }, g.prototype.setPAC = function(o) {
              je.log("INFO", "pacData = " + JSON.stringify(o));
              var s = o.row - 1;
              if (this.nrRollUpRows && s < this.nrRollUpRows - 1 && (s = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== s) {
                for (var u = 0; u < Ur; u++)
                  this.rows[u].clear();
                var f = this.currRow + 1 - this.nrRollUpRows, E = this.lastOutputScreen;
                if (E) {
                  var w = E.rows[f].cueStartTime;
                  if (w && w < je.time)
                    for (var R = 0; R < this.nrRollUpRows; R++)
                      this.rows[s - this.nrRollUpRows + R + 1].copy(E.rows[f + R]);
                }
              }
              this.currRow = s;
              var C = this.rows[this.currRow];
              if (o.indent !== null) {
                var k = o.indent, P = Math.max(k - 1, 0);
                C.setCursor(o.indent), o.color = C.chars[P].penState.foreground;
              }
              var U = { foreground: o.color, underline: o.underline, italics: o.italics, background: "black", flash: !1 };
              this.setPen(U);
            }, g.prototype.setBkgData = function(o) {
              je.log("INFO", "bkgData = " + JSON.stringify(o)), this.backSpace(), this.setPen(o), this.insertChar(32);
            }, g.prototype.setRollUpRows = function(o) {
              this.nrRollUpRows = o;
            }, g.prototype.rollUp = function() {
              if (this.nrRollUpRows === null) {
                je.log("DEBUG", "roll_up but nrRollUpRows not set yet");
                return;
              }
              je.log("TEXT", this.getDisplayText());
              var o = this.currRow + 1 - this.nrRollUpRows, s = this.rows.splice(o, 1)[0];
              s.clear(), this.rows.splice(this.currRow, 0, s), je.log("INFO", "Rolling up");
            }, g.prototype.getDisplayText = function(o) {
              o = o || !1;
              for (var s = [], u = "", f = -1, E = 0; E < Ur; E++) {
                var w = this.rows[E].getTextString();
                w && (f = E + 1, o ? s.push("Row " + f + ": '" + w + "'") : s.push(w.trim()));
              }
              return s.length > 0 && (o ? u = "[" + s.join(" | ") + "]" : u = s.join(`
`)), u;
            }, g.prototype.getTextAndFormat = function() {
              return this.rows;
            }, g;
          }(), md = function() {
            function g(l, o) {
              fs(this, g), this.chNr = l, this.outputFilter = o, this.mode = null, this.verbose = 0, this.displayedMemory = new rc(), this.nonDisplayedMemory = new rc(), this.lastOutputScreen = new rc(), this.currRollUpRow = this.displayedMemory.rows[Ur - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
            }
            return g.prototype.reset = function() {
              this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[Ur - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.lastCueEndTime = null;
            }, g.prototype.getHandler = function() {
              return this.outputFilter;
            }, g.prototype.setHandler = function(o) {
              this.outputFilter = o;
            }, g.prototype.setPAC = function(o) {
              this.writeScreen.setPAC(o);
            }, g.prototype.setBkgData = function(o) {
              this.writeScreen.setBkgData(o);
            }, g.prototype.setMode = function(o) {
              o !== this.mode && (this.mode = o, je.log("INFO", "MODE=" + o), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = o);
            }, g.prototype.insertChars = function(o) {
              for (var s = 0; s < o.length; s++)
                this.writeScreen.insertChar(o[s]);
              var u = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
              je.log("INFO", u + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (je.log("TEXT", "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
            }, g.prototype.ccRCL = function() {
              je.log("INFO", "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
            }, g.prototype.ccBS = function() {
              je.log("INFO", "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
            }, g.prototype.ccAOF = function() {
            }, g.prototype.ccAON = function() {
            }, g.prototype.ccDER = function() {
              je.log("INFO", "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
            }, g.prototype.ccRU = function(o) {
              je.log("INFO", "RU(" + o + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(o);
            }, g.prototype.ccFON = function() {
              je.log("INFO", "FON - Flash On"), this.writeScreen.setPen({ flash: !0 });
            }, g.prototype.ccRDC = function() {
              je.log("INFO", "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
            }, g.prototype.ccTR = function() {
              je.log("INFO", "TR"), this.setMode("MODE_TEXT");
            }, g.prototype.ccRTD = function() {
              je.log("INFO", "RTD"), this.setMode("MODE_TEXT");
            }, g.prototype.ccEDM = function() {
              je.log("INFO", "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
            }, g.prototype.ccCR = function() {
              je.log("CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
            }, g.prototype.ccENM = function() {
              je.log("INFO", "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
            }, g.prototype.ccEOC = function() {
              if (je.log("INFO", "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
                var o = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = o, this.writeScreen = this.nonDisplayedMemory, je.log("TEXT", "DISP: " + this.displayedMemory.getDisplayText());
              }
              this.outputDataUpdate(!0);
            }, g.prototype.ccTO = function(o) {
              je.log("INFO", "TO(" + o + ") - Tab Offset"), this.writeScreen.moveCursor(o);
            }, g.prototype.ccMIDROW = function(o) {
              var s = { flash: !1 };
              if (s.underline = o % 2 === 1, s.italics = o >= 46, s.italics)
                s.foreground = "white";
              else {
                var u = Math.floor(o / 2) - 16, f = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                s.foreground = f[u];
              }
              je.log("INFO", "MIDROW: " + JSON.stringify(s)), this.writeScreen.setPen(s);
            }, g.prototype.outputDataUpdate = function() {
              var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, s = je.time;
              s !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = s : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue && (this.outputFilter.newCue(this.cueStartTime, s, this.lastOutputScreen), o === !0 && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue()), this.cueStartTime = this.displayedMemory.isEmpty() ? null : s), this.lastOutputScreen.copy(this.displayedMemory));
            }, g.prototype.cueSplitAtTime = function(o) {
              this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, o, this.displayedMemory), this.cueStartTime = o));
            }, g;
          }(), Ty = function() {
            function g(l, o, s) {
              fs(this, g), this.field = l || 1, this.outputs = [o, s], this.channels = [new md(1, o), new md(2, s)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.bufferedData = [], this.startTime = null, this.lastTime = null, this.dataCounters = { padding: 0, char: 0, cmd: 0, other: 0 };
            }
            return g.prototype.getHandler = function(o) {
              return this.channels[o].getHandler();
            }, g.prototype.setHandler = function(o, s) {
              this.channels[o].setHandler(s);
            }, g.prototype.addData = function(o, s) {
              var u, f, E, w = !1;
              this.lastTime = o, je.setTime(o);
              for (var R = 0; R < s.length; R += 2) {
                if (f = s[R] & 127, E = s[R + 1] & 127, f === 0 && E === 0) {
                  this.dataCounters.padding += 2;
                  continue;
                } else
                  je.log("DATA", "[" + Pn([s[R], s[R + 1]]) + "] -> (" + Pn([f, E]) + ")");
                if (u = this.parseCmd(f, E), u || (u = this.parseMidrow(f, E)), u || (u = this.parsePAC(f, E)), u || (u = this.parseBackgroundAttributes(f, E)), !u && (w = this.parseChars(f, E), w))
                  if (this.currChNr && this.currChNr >= 0) {
                    var C = this.channels[this.currChNr - 1];
                    C.insertChars(w);
                  } else
                    je.log("WARNING", "No channel found yet. TEXT-MODE?");
                u ? this.dataCounters.cmd += 2 : w ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, je.log("WARNING", "Couldn't parse cleaned data " + Pn([f, E]) + " orig: " + Pn([s[R], s[R + 1]])));
              }
            }, g.prototype.parseCmd = function(o, s) {
              var u = null, f = (o === 20 || o === 28) && 32 <= s && s <= 47, E = (o === 23 || o === 31) && 33 <= s && s <= 35;
              if (!(f || E))
                return !1;
              if (o === this.lastCmdA && s === this.lastCmdB)
                return this.lastCmdA = null, this.lastCmdB = null, je.log("DEBUG", "Repeated command (" + Pn([o, s]) + ") is dropped"), !0;
              o === 20 || o === 23 ? u = 1 : u = 2;
              var w = this.channels[u - 1];
              return o === 20 || o === 28 ? s === 32 ? w.ccRCL() : s === 33 ? w.ccBS() : s === 34 ? w.ccAOF() : s === 35 ? w.ccAON() : s === 36 ? w.ccDER() : s === 37 ? w.ccRU(2) : s === 38 ? w.ccRU(3) : s === 39 ? w.ccRU(4) : s === 40 ? w.ccFON() : s === 41 ? w.ccRDC() : s === 42 ? w.ccTR() : s === 43 ? w.ccRTD() : s === 44 ? w.ccEDM() : s === 45 ? w.ccCR() : s === 46 ? w.ccENM() : s === 47 && w.ccEOC() : w.ccTO(s - 32), this.lastCmdA = o, this.lastCmdB = s, this.currChNr = u, !0;
            }, g.prototype.parseMidrow = function(o, s) {
              var u = null;
              if ((o === 17 || o === 25) && 32 <= s && s <= 47) {
                if (o === 17 ? u = 1 : u = 2, u !== this.currChNr)
                  return je.log("ERROR", "Mismatch channel in midrow parsing"), !1;
                var f = this.channels[u - 1];
                return f.ccMIDROW(s), je.log("DEBUG", "MIDROW (" + Pn([o, s]) + ")"), !0;
              }
              return !1;
            }, g.prototype.parsePAC = function(o, s) {
              var u = null, f = null, E = (17 <= o && o <= 23 || 25 <= o && o <= 31) && 64 <= s && s <= 127, w = (o === 16 || o === 24) && 64 <= s && s <= 95;
              if (!(E || w))
                return !1;
              if (o === this.lastCmdA && s === this.lastCmdB)
                return this.lastCmdA = null, this.lastCmdB = null, !0;
              u = o <= 23 ? 1 : 2, 64 <= s && s <= 95 ? f = u === 1 ? xy[o] : vy[o] : f = u === 1 ? Ey[o] : Ry[o];
              var R = this.interpretPAC(f, s), C = this.channels[u - 1];
              return C.setPAC(R), this.lastCmdA = o, this.lastCmdB = s, this.currChNr = u, !0;
            }, g.prototype.interpretPAC = function(o, s) {
              var u = s, f = { color: null, italics: !1, indent: null, underline: !1, row: o };
              return s > 95 ? u = s - 96 : u = s - 64, f.underline = (u & 1) === 1, u <= 13 ? f.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(u / 2)] : u <= 15 ? (f.italics = !0, f.color = "white") : f.indent = Math.floor((u - 16) / 2) * 4, f;
            }, g.prototype.parseChars = function(o, s) {
              var u = null, f = null, E = null;
              if (o >= 25 ? (u = 2, E = o - 8) : (u = 1, E = o), 17 <= E && E <= 19) {
                var w = s;
                E === 17 ? w = s + 80 : E === 18 ? w = s + 112 : w = s + 144, je.log("INFO", "Special char '" + pd(w) + "' in channel " + u), f = [w];
              } else 32 <= o && o <= 127 && (f = s === 0 ? [o] : [o, s]);
              if (f) {
                var R = Pn(f);
                je.log("DEBUG", "Char codes =  " + R.join(",")), this.lastCmdA = null, this.lastCmdB = null;
              }
              return f;
            }, g.prototype.parseBackgroundAttributes = function(o, s) {
              var u, f, E, w, R = (o === 16 || o === 24) && 32 <= s && s <= 47, C = (o === 23 || o === 31) && 45 <= s && s <= 47;
              return R || C ? (u = {}, o === 16 || o === 24 ? (f = Math.floor((s - 32) / 2), u.background = Ay[f], s % 2 === 1 && (u.background = u.background + "_semi")) : s === 45 ? u.background = "transparent" : (u.foreground = "black", s === 47 && (u.underline = !0)), E = o < 24 ? 1 : 2, w = this.channels[E - 1], w.setBkgData(u), this.lastCmdA = null, this.lastCmdB = null, !0) : !1;
            }, g.prototype.reset = function() {
              for (var o = 0; o < this.channels.length; o++)
                this.channels[o] && this.channels[o].reset();
              this.lastCmdA = null, this.lastCmdB = null;
            }, g.prototype.cueSplitAtTime = function(o) {
              for (var s = 0; s < this.channels.length; s++)
                this.channels[s] && this.channels[s].cueSplitAtTime(o);
            }, g;
          }(), Cy = Ty;
          function Sy(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ly = function() {
            function g(l, o) {
              Sy(this, g), this.timelineController = l, this.track = o, this.startTime = null, this.endTime = null, this.screen = null;
            }
            return g.prototype.dispatchCue = function() {
              this.startTime !== null && (this.timelineController.addCues("textTrack" + this.track, this.startTime, this.endTime, this.screen), this.startTime = null);
            }, g.prototype.newCue = function(o, s, u) {
              (this.startTime === null || this.startTime > o) && (this.startTime = o), this.endTime = s, this.screen = u, this.timelineController.createCaptionsTrack(this.track);
            }, g;
          }(), yd = Ly, ic = function(l, o, s) {
            return l.substr(0, o.length) === o;
          }, ky = function(l) {
            var o = parseInt(l.substr(-3)), s = parseInt(l.substr(-6, 2)), u = parseInt(l.substr(-9, 2)), f = l.length > 9 ? parseInt(l.substr(0, l.indexOf(":"))) : 0;
            return isNaN(o) || isNaN(s) || isNaN(u) || isNaN(f) ? -1 : (o += 1e3 * s, o += 60 * 1e3 * u, o += 60 * 60 * 1e3 * f, o);
          }, nc = function(l) {
            for (var o = 5381, s = l.length; s; )
              o = o * 33 ^ l.charCodeAt(--s);
            return (o >>> 0).toString();
          }, Dy = function(l, o, s) {
            var u = l[o], f = l[u.prevCC];
            if (!f || !f.new && u.new) {
              l.ccOffset = l.presentationOffset = u.start, u.new = !1;
              return;
            }
            for (; f && f.new; )
              l.ccOffset += u.start - f.start, u.new = !1, u = f, f = l[u.prevCC];
            l.presentationOffset = s;
          }, Py = {
            parse: function(l, o, s, u, f, E) {
              var w = /\r\n|\n\r|\n|\r/g, R = Object(Qe.b)(new Uint8Array(l)).trim().replace(w, `
`).split(`
`), C = "00:00.000", k = 0, P = 0, U = 0, F = [], te = void 0, he = !0, xe = new by();
              xe.oncue = function(ge) {
                var Ce = s[u], Se = s.ccOffset;
                Ce && Ce.new && (P !== void 0 ? Se = s.ccOffset = Ce.start : Dy(s, u, U)), U && (Se = U + s.ccOffset - s.presentationOffset), ge.startTime += Se - P, ge.endTime += Se - P, ge.id = nc(ge.startTime.toString()) + nc(ge.endTime.toString()) + nc(ge.text), ge.text = decodeURIComponent(encodeURIComponent(ge.text)), ge.endTime > 0 && F.push(ge);
              }, xe.onparsingerror = function(ge) {
                te = ge;
              }, xe.onflush = function() {
                if (te && E) {
                  E(te);
                  return;
                }
                f(F);
              }, R.forEach(function(ge) {
                if (he)
                  if (ic(ge, "X-TIMESTAMP-MAP=")) {
                    he = !1, ge.substr(16).split(",").forEach(function(Ce) {
                      ic(Ce, "LOCAL:") ? C = Ce.substr(6) : ic(Ce, "MPEGTS:") && (k = parseInt(Ce.substr(7)));
                    });
                    try {
                      o = o < 0 ? o + 8589934592 : o, k -= o, P = ky(C) / 1e3, U = k / 9e4, P === -1 && (te = new Error("Malformed X-TIMESTAMP-MAP: " + ge));
                    } catch {
                      te = new Error("Malformed X-TIMESTAMP-MAP: " + ge);
                    }
                    return;
                  } else ge === "" && (he = !1);
                xe.parse(ge + `
`);
              }), xe.flush();
            }
          }, By = Py;
          function Iy(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function Uy(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Oy(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          function Zl(g) {
            if (g && g.cues)
              for (; g.cues.length > 0; )
                g.removeCue(g.cues[0]);
          }
          function Ky(g, l) {
            return g && g.label === l.name && !(g.textTrack1 || g.textTrack2);
          }
          function My(g, l, o, s) {
            return Math.min(l, s) - Math.max(g, o);
          }
          var Ny = function(g) {
            Oy(l, g);
            function l(o) {
              Iy(this, l);
              var s = Uy(this, g.call(this, o, p.a.MEDIA_ATTACHING, p.a.MEDIA_DETACHING, p.a.FRAG_PARSING_USERDATA, p.a.FRAG_DECRYPTED, p.a.MANIFEST_LOADING, p.a.MANIFEST_LOADED, p.a.FRAG_LOADED, p.a.LEVEL_SWITCHING, p.a.INIT_PTS_FOUND));
              if (s.hls = o, s.config = o.config, s.enabled = !0, s.Cues = o.config.cueHandler, s.textTracks = [], s.tracks = [], s.unparsedVttFrags = [], s.initPTS = void 0, s.cueRanges = [], s.config.enableCEA708Captions) {
                var u = new yd(s, 1), f = new yd(s, 2);
                s.cea608Parser = new Cy(0, u, f);
              }
              return s;
            }
            return l.prototype.addCues = function(s, u, f, E) {
              for (var w = this.cueRanges, R = !1, C = w.length; C--; ) {
                var k = w[C], P = My(k[0], k[1], u, f);
                if (P >= 0 && (k[0] = Math.min(k[0], u), k[1] = Math.max(k[1], f), R = !0, P / (f - u) > 0.5))
                  return;
              }
              R || w.push([u, f]), this.Cues.newCue(this[s], u, f, E);
            }, l.prototype.onInitPtsFound = function(s) {
              var u = this;
              typeof this.initPTS > "u" && (this.initPTS = s.initPTS), this.unparsedVttFrags.length && (this.unparsedVttFrags.forEach(function(f) {
                u.onFragLoaded(f);
              }), this.unparsedVttFrags = []);
            }, l.prototype.getExistingTrack = function(s) {
              var u = this.media;
              if (u)
                for (var f = 0; f < u.textTracks.length; f++) {
                  var E = u.textTracks[f], w = "textTrack" + s;
                  if (E[w] === !0)
                    return E;
                }
              return null;
            }, l.prototype.sendAddTrackEvent = function(s, u) {
              var f = null;
              try {
                f = new window.Event("addtrack");
              } catch {
                f = document.createEvent("Event"), f.initEvent("addtrack", !1, !1);
              }
              f.track = s, u.dispatchEvent(f);
            }, l.prototype.createCaptionsTrack = function(s) {
              var u = "textTrack" + s;
              if (!this[u]) {
                var f = this.getExistingTrack(s);
                if (f)
                  this[u] = f, Zl(this[u]), this.sendAddTrackEvent(this[u], this.media);
                else {
                  var E = this.createTextTrack("captions", this.config["captionsTextTrack" + s + "Label"], this.config.captionsTextTrack1LanguageCode);
                  E && (E[u] = !0, this[u] = E);
                }
              }
            }, l.prototype.createTextTrack = function(s, u, f) {
              var E = this.media;
              if (E)
                return E.addTextTrack(s, u, f);
            }, l.prototype.destroy = function() {
              O.prototype.destroy.call(this);
            }, l.prototype.onMediaAttaching = function(s) {
              this.media = s.media, this._cleanTracks();
            }, l.prototype.onMediaDetaching = function() {
              Zl(this.textTrack1), Zl(this.textTrack2);
            }, l.prototype.onManifestLoading = function() {
              this.lastSn = -1, this.prevCC = -1, this.vttCCs = { ccOffset: 0, presentationOffset: 0 }, this._cleanTracks();
            }, l.prototype._cleanTracks = function() {
              var s = this.media;
              if (s) {
                var u = s.textTracks;
                if (u)
                  for (var f = 0; f < u.length; f++)
                    Zl(u[f]);
              }
            }, l.prototype.onManifestLoaded = function(s) {
              var u = this;
              if (this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = void 0, this.cueRanges = [], this.config.enableWebVTT) {
                this.tracks = s.subtitles || [];
                var f = this.media ? this.media.textTracks : [];
                this.tracks.forEach(function(E, w) {
                  var R = void 0;
                  if (w < f.length) {
                    var C = f[w];
                    Ky(C, E) && (R = C);
                  }
                  R || (R = u.createTextTrack("subtitles", E.name, E.lang)), R.mode = E.default ? "showing" : "hidden", u.textTracks.push(R);
                });
              }
            }, l.prototype.onLevelSwitching = function() {
              this.enabled = this.hls.currentLevel.closedCaptions !== "NONE";
            }, l.prototype.onFragLoaded = function(s) {
              var u = s.frag, f = s.payload;
              if (u.type === "main") {
                var E = u.sn;
                if (E !== this.lastSn + 1) {
                  var w = this.cea608Parser;
                  w && w.reset();
                }
                this.lastSn = E;
              } else if (u.type === "subtitle")
                if (f.byteLength) {
                  if (typeof this.initPTS > "u") {
                    this.unparsedVttFrags.push(s);
                    return;
                  }
                  var R = u.decryptdata;
                  (R == null || R.key == null || R.method !== "AES-128") && this._parseVTTs(u, f);
                } else
                  this.hls.trigger(p.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: u });
            }, l.prototype._parseVTTs = function(s, u) {
              var f = this.vttCCs;
              f[s.cc] || (f[s.cc] = { start: s.start, prevCC: this.prevCC, new: !0 }, this.prevCC = s.cc);
              var E = this.textTracks, w = this.hls;
              By.parse(u, this.initPTS, f, s.cc, function(R) {
                var C = E[s.trackId];
                R.forEach(function(k) {
                  if (!C.cues.getCueById(k.id))
                    try {
                      C.addCue(k);
                    } catch {
                      var P = new window.TextTrackCue(k.startTime, k.endTime, k.text);
                      P.id = k.id, C.addCue(P);
                    }
                }), w.trigger(p.a.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: s });
              }, function(R) {
                d.b.log("Failed to parse VTT cue: " + R), w.trigger(p.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: s });
              });
            }, l.prototype.onFragDecrypted = function(s) {
              var u = s.payload, f = s.frag;
              if (f.type === "subtitle") {
                if (typeof this.initPTS > "u") {
                  this.unparsedVttFrags.push(s);
                  return;
                }
                this._parseVTTs(f, u);
              }
            }, l.prototype.onFragParsingUserdata = function(s) {
              if (this.enabled && this.config.enableCEA708Captions)
                for (var u = 0; u < s.samples.length; u++) {
                  var f = this.extractCea608Data(s.samples[u].bytes);
                  this.cea608Parser.addData(s.samples[u].pts, f);
                }
            }, l.prototype.extractCea608Data = function(s) {
              for (var u = s[0] & 31, f = 2, E, w, R, C, k, P = [], U = 0; U < u; U++)
                E = s[f++], w = 127 & s[f++], R = 127 & s[f++], C = (4 & E) !== 0, k = 3 & E, !(w === 0 && R === 0) && C && k === 0 && (P.push(w), P.push(R));
              return P;
            }, l;
          }(O), Vy = Ny, jy = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function Fy(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function $y(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Gy(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          function bd(g) {
            for (var l = [], o = 0; o < g.length; o++)
              g[o].kind === "subtitles" && l.push(g[o]);
            return l;
          }
          var qy = function(g) {
            Gy(l, g);
            function l(o) {
              Fy(this, l);
              var s = $y(this, g.call(this, o, p.a.MEDIA_ATTACHED, p.a.MEDIA_DETACHING, p.a.MANIFEST_LOADING, p.a.MANIFEST_LOADED, p.a.SUBTITLE_TRACK_LOADED));
              return s.tracks = [], s.trackId = -1, s.media = void 0, s.subtitleDisplay = !1, s;
            }
            return l.prototype._onTextTracksChanged = function() {
              if (this.media) {
                for (var s = -1, u = bd(this.media.textTracks), f = 0; f < u.length; f++)
                  u[f].mode === "showing" && (s = f);
                this.subtitleTrack = s;
              }
            }, l.prototype.destroy = function() {
              O.prototype.destroy.call(this);
            }, l.prototype.onMediaAttached = function(s) {
              var u = this;
              this.media = s.media, this.media && (this.queuedDefaultTrack !== void 0 && (this.subtitleTrack = this.queuedDefaultTrack, delete this.queuedDefaultTrack), this.trackChangeListener = this._onTextTracksChanged.bind(this), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.subtitlePollingInterval = setInterval(function() {
                u.trackChangeListener();
              }, 500) : this.media.textTracks.addEventListener("change", this.trackChangeListener));
            }, l.prototype.onMediaDetaching = function() {
              this.media && (this.useTextTrackPolling ? clearInterval(this.subtitlePollingInterval) : this.media.textTracks.removeEventListener("change", this.trackChangeListener), this.media = void 0);
            }, l.prototype.onManifestLoading = function() {
              this.tracks = [], this.trackId = -1;
            }, l.prototype.onManifestLoaded = function(s) {
              var u = this, f = s.subtitles || [];
              this.tracks = f, this.trackId = -1, this.hls.trigger(p.a.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: f }), f.forEach(function(E) {
                E.default && (u.media ? u.subtitleTrack = E.id : u.queuedDefaultTrack = E.id);
              });
            }, l.prototype.onTick = function() {
              var s = this.trackId, u = this.tracks[s];
              if (u) {
                var f = u.details;
                (f === void 0 || f.live === !0) && (d.b.log("(re)loading playlist for subtitle track " + s), this.hls.trigger(p.a.SUBTITLE_TRACK_LOADING, { url: u.url, id: s }));
              }
            }, l.prototype.onSubtitleTrackLoaded = function(s) {
              var u = this;
              s.id < this.tracks.length && (d.b.log("subtitle track " + s.id + " loaded"), this.tracks[s.id].details = s.details, s.details.live && !this.timer && (this.timer = setInterval(function() {
                u.onTick();
              }, 1e3 * s.details.targetduration, this)), !s.details.live && this.timer && (clearInterval(this.timer), this.timer = null));
            }, l.prototype.setSubtitleTrackInternal = function(s) {
              if (!(s < -1 || s >= this.tracks.length)) {
                this.timer && (clearInterval(this.timer), this.timer = null);
                var u = bd(this.media.textTracks);
                if (this.trackId !== -1 && this.subtitleDisplay && (u[this.trackId].mode = "hidden"), this.trackId = s, d.b.log("switching to subtitle track " + s), this.hls.trigger(p.a.SUBTITLE_TRACK_SWITCH, { id: s }), s !== -1) {
                  var f = this.tracks[s];
                  this.subtitleDisplay && (u[s].mode = "showing");
                  var E = f.details;
                  (E === void 0 || E.live === !0) && (d.b.log("(re)loading playlist for subtitle track " + s), this.hls.trigger(p.a.SUBTITLE_TRACK_LOADING, { url: f.url, id: s }));
                }
              }
            }, jy(l, [{
              key: "subtitleTracks",
              get: function() {
                return this.tracks;
              }
              /** get index of the selected subtitle track (index in subtitle track lists) **/
            }, {
              key: "subtitleTrack",
              get: function() {
                return this.trackId;
              },
              set: function(s) {
                this.trackId !== s && this.setSubtitleTrackInternal(s);
              }
            }]), l;
          }(O), zy = qy, Xy = a(4);
          function Hy(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function Zy(g, l) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : g;
          }
          function Wy(g, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            g.prototype = Object.create(l.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), Object.setPrototypeOf ? Object.setPrototypeOf(g, l) : g.__proto__ = l;
          }
          var Yr = {
            STOPPED: "STOPPED",
            IDLE: "IDLE",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING"
          }, Yy = function(g) {
            Wy(l, g);
            function l(o) {
              Hy(this, l);
              var s = Zy(this, g.call(this, o, p.a.MEDIA_ATTACHED, p.a.ERROR, p.a.KEY_LOADED, p.a.FRAG_LOADED, p.a.SUBTITLE_TRACKS_UPDATED, p.a.SUBTITLE_TRACK_SWITCH, p.a.SUBTITLE_TRACK_LOADED, p.a.SUBTITLE_FRAG_PROCESSED));
              return s.config = o.config, s.vttFragSNsProcessed = {}, s.vttFragQueues = void 0, s.currentlyProcessing = null, s.state = Yr.STOPPED, s.currentTrackId = -1, s.ticks = 0, s.decrypter = new Xy.a(o.observer, o.config), s;
            }
            return l.prototype.destroy = function() {
              O.prototype.destroy.call(this), this.state = Yr.STOPPED;
            }, l.prototype.clearVttFragQueues = function() {
              var s = this;
              this.vttFragQueues = {}, this.tracks.forEach(function(u) {
                s.vttFragQueues[u.id] = [];
              });
            }, l.prototype.nextFrag = function() {
              if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
                var s = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
                this.fragCurrent = s, this.hls.trigger(p.a.FRAG_LOADING, { frag: s }), this.state = Yr.FRAG_LOADING;
              }
            }, l.prototype.onSubtitleFragProcessed = function(s) {
              s.success && this.vttFragSNsProcessed[s.frag.trackId].push(s.frag.sn), this.currentlyProcessing = null, this.state = Yr.IDLE, this.nextFrag();
            }, l.prototype.onMediaAttached = function() {
              this.state = Yr.IDLE;
            }, l.prototype.onError = function(s) {
              var u = s.frag;
              u && u.type !== "subtitle" || this.currentlyProcessing && (this.currentlyProcessing = null, this.nextFrag());
            }, l.prototype.tick = function() {
              var s = this;
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(function() {
                s.tick();
              }, 1), this.ticks = 0);
            }, l.prototype.doTick = function() {
              var s = this;
              switch (this.state) {
                case Yr.IDLE:
                  var u = this.tracks, f = this.currentTrackId, E = this.vttFragSNsProcessed[f], w = this.vttFragQueues[f], R = this.currentlyProcessing ? this.currentlyProcessing.sn : -1, C = function(F) {
                    return E.indexOf(F.sn) > -1;
                  }, k = function(F) {
                    return w.some(function(te) {
                      return te.sn === F.sn;
                    });
                  };
                  if (!u)
                    break;
                  var P;
                  if (f < u.length && (P = u[f].details), typeof P > "u")
                    break;
                  P.fragments.forEach(function(U) {
                    C(U) || U.sn === R || k(U) || (U.decryptdata && U.decryptdata.uri != null && U.decryptdata.key == null ? (d.b.log("Loading key for " + U.sn), s.state = Yr.KEY_LOADING, s.hls.trigger(p.a.KEY_LOADING, { frag: U })) : (U.trackId = f, w.push(U), s.nextFrag()));
                  });
              }
            }, l.prototype.onSubtitleTracksUpdated = function(s) {
              var u = this;
              d.b.log("subtitle tracks updated"), this.tracks = s.subtitleTracks, this.clearVttFragQueues(), this.vttFragSNsProcessed = {}, this.tracks.forEach(function(f) {
                u.vttFragSNsProcessed[f.id] = [];
              });
            }, l.prototype.onSubtitleTrackSwitch = function(s) {
              this.currentTrackId = s.id, this.clearVttFragQueues();
            }, l.prototype.onSubtitleTrackLoaded = function() {
              this.tick();
            }, l.prototype.onKeyLoaded = function() {
              this.state === Yr.KEY_LOADING && (this.state = Yr.IDLE, this.tick());
            }, l.prototype.onFragLoaded = function(s) {
              var u = this.fragCurrent, f = s.frag.decryptdata, E = s.frag, w = this.hls;
              if (this.state === Yr.FRAG_LOADING && u && s.frag.type === "subtitle" && u.sn === s.frag.sn && s.payload.byteLength > 0 && f != null && f.key != null && f.method === "AES-128") {
                var R;
                try {
                  R = performance.now();
                } catch {
                  R = Date.now();
                }
                this.decrypter.decrypt(s.payload, f.key.buffer, f.iv.buffer, function(C) {
                  var k;
                  try {
                    k = performance.now();
                  } catch {
                    k = Date.now();
                  }
                  w.trigger(p.a.FRAG_DECRYPTED, { frag: E, payload: C, stats: { tstart: R, tdecrypt: k } });
                });
              }
            }, l;
          }(O), Jy = Yy, xr = {
            autoStartLoad: !0,
            // used by stream-controller
            startPosition: -1,
            // used by stream-controller
            defaultAudioCodec: void 0,
            // used by stream-controller
            debug: !1,
            // used by logger
            capLevelOnFPSDrop: !1,
            // used by fps-controller
            capLevelToPlayerSize: !1,
            // used by cap-level-controller
            initialLiveManifestSize: 1,
            // used by stream-controller
            maxBufferLength: 30,
            // used by stream-controller
            maxBufferSize: 60 * 1e3 * 1e3,
            // used by stream-controller
            maxBufferHole: 0.5,
            // used by stream-controller
            maxSeekHole: 2,
            // used by stream-controller
            lowBufferWatchdogPeriod: 0.5,
            // used by stream-controller
            highBufferWatchdogPeriod: 3,
            // used by stream-controller
            nudgeOffset: 0.1,
            // used by stream-controller
            nudgeMaxRetry: 3,
            // used by stream-controller
            maxFragLookUpTolerance: 0.25,
            // used by stream-controller
            liveSyncDurationCount: 3,
            // used by stream-controller
            liveMaxLatencyDurationCount: 1 / 0,
            // used by stream-controller
            liveSyncDuration: void 0,
            // used by stream-controller
            liveMaxLatencyDuration: void 0,
            // used by stream-controller
            liveDurationInfinity: !1,
            // used by buffer-controller
            maxMaxBufferLength: 600,
            // used by stream-controller
            enableWorker: !0,
            // used by demuxer
            enableSoftwareAES: !0,
            // used by decrypter
            manifestLoadingTimeOut: 1e4,
            // used by playlist-loader
            manifestLoadingMaxRetry: 1,
            // used by playlist-loader
            manifestLoadingRetryDelay: 1e3,
            // used by playlist-loader
            manifestLoadingMaxRetryTimeout: 64e3,
            // used by playlist-loader
            startLevel: void 0,
            // used by level-controller
            levelLoadingTimeOut: 1e4,
            // used by playlist-loader
            levelLoadingMaxRetry: 4,
            // used by playlist-loader
            levelLoadingRetryDelay: 1e3,
            // used by playlist-loader
            levelLoadingMaxRetryTimeout: 64e3,
            // used by playlist-loader
            fragLoadingTimeOut: 2e4,
            // used by fragment-loader
            fragLoadingMaxRetry: 6,
            // used by fragment-loader
            fragLoadingRetryDelay: 1e3,
            // used by fragment-loader
            fragLoadingMaxRetryTimeout: 64e3,
            // used by fragment-loader
            fragLoadingLoopThreshold: 3,
            // used by stream-controller
            startFragPrefetch: !1,
            // used by stream-controller
            fpsDroppedMonitoringPeriod: 5e3,
            // used by fps-controller
            fpsDroppedMonitoringThreshold: 0.2,
            // used by fps-controller
            appendErrorMaxRetry: 3,
            // used by buffer-controller
            loader: ty,
            //loader: FetchLoader,
            fLoader: void 0,
            pLoader: void 0,
            xhrSetup: void 0,
            fetchSetup: void 0,
            abrController: kn,
            bufferController: Wr,
            capLevelController: gr,
            fpsController: Jm,
            stretchShortVideoTrack: !1,
            // used by mp4-remuxer
            maxAudioFramesDrift: 1,
            // used by mp4-remuxer
            forceKeyFrameOnDiscontinuity: !0,
            // used by ts-demuxer
            abrEwmaFastLive: 3,
            // used by abr-controller
            abrEwmaSlowLive: 9,
            // used by abr-controller
            abrEwmaFastVoD: 3,
            // used by abr-controller
            abrEwmaSlowVoD: 9,
            // used by abr-controller
            abrEwmaDefaultEstimate: 5e5,
            // 500 kbps  // used by abr-controller
            abrBandWidthFactor: 0.95,
            // used by abr-controller
            abrBandWidthUpFactor: 0.7,
            // used by abr-controller
            abrMaxWithRealBitrate: !1,
            // used by abr-controller
            maxStarvationDelay: 4,
            // used by abr-controller
            maxLoadingDelay: 4,
            // used by abr-controller
            minAutoBitrate: 0
            // used by hls
          };
          xr.subtitleStreamController = Jy, xr.subtitleTrackController = zy, xr.timelineController = Vy, xr.cueHandler = c, xr.enableCEA708Captions = !0, xr.enableWebVTT = !0, xr.captionsTextTrack1Label = "English", xr.captionsTextTrack1LanguageCode = "en", xr.captionsTextTrack2Label = "Spanish", xr.captionsTextTrack2LanguageCode = "es", xr.audioStreamController = py, xr.audioTrackController = oy;
          var gd = /* @__PURE__ */ function() {
            function g(l, o) {
              for (var s = 0; s < o.length; s++) {
                var u = o[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(l, u.key, u);
              }
            }
            return function(l, o, s) {
              return o && g(l.prototype, o), s && g(l, s), l;
            };
          }();
          function Qy(g, l) {
            if (!(g instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          var eb = function() {
            g.isSupported = function() {
              return zt();
            }, gd(g, null, [{
              key: "version",
              get: function() {
                return "0.8.9";
              }
            }, {
              key: "Events",
              get: function() {
                return p.a;
              }
            }, {
              key: "ErrorTypes",
              get: function() {
                return y.b;
              }
            }, {
              key: "ErrorDetails",
              get: function() {
                return y.a;
              }
            }, {
              key: "DefaultConfig",
              get: function() {
                return g.defaultConfig ? g.defaultConfig : xr;
              },
              set: function(o) {
                g.defaultConfig = o;
              }
            }]);
            function g() {
              var l = this, o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              Qy(this, g);
              var s = g.DefaultConfig;
              if ((o.liveSyncDurationCount || o.liveMaxLatencyDurationCount) && (o.liveSyncDuration || o.liveMaxLatencyDuration))
                throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
              for (var u in s)
                u in o || (o[u] = s[u]);
              if (o.liveMaxLatencyDurationCount !== void 0 && o.liveMaxLatencyDurationCount <= o.liveSyncDurationCount)
                throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
              if (o.liveMaxLatencyDuration !== void 0 && (o.liveMaxLatencyDuration <= o.liveSyncDuration || o.liveSyncDuration === void 0))
                throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
              Object(d.a)(o.debug), this.config = o, this._autoLevelCapping = -1;
              var f = this.observer = new rr.a();
              f.trigger = function(dt) {
                for (var _e = arguments.length, Pt = Array(_e > 1 ? _e - 1 : 0), it = 1; it < _e; it++)
                  Pt[it - 1] = arguments[it];
                f.emit.apply(f, [dt, dt].concat(Pt));
              }, f.off = function(dt) {
                for (var _e = arguments.length, Pt = Array(_e > 1 ? _e - 1 : 0), it = 1; it < _e; it++)
                  Pt[it - 1] = arguments[it];
                f.removeListener.apply(f, [dt].concat(Pt));
              }, this.on = f.on.bind(f), this.off = f.off.bind(f), this.trigger = f.trigger.bind(f);
              var E = this.abrController = new o.abrController(this), w = new o.bufferController(this), R = new o.capLevelController(this), C = new o.fpsController(this), k = new vt(this), P = new ot(this), U = new pr(this), F = new br(this), te = this.levelController = new Rt(this), he = this.streamController = new Ye(this), xe = [te, he], ge = o.audioStreamController;
              ge && xe.push(new ge(this)), this.networkControllers = xe;
              var Ce = [k, P, U, E, w, R, C, F];
              if (ge = o.audioTrackController, ge) {
                var Se = new ge(this);
                this.audioTrackController = Se, Ce.push(Se);
              }
              if (ge = o.subtitleTrackController, ge) {
                var Pe = new ge(this);
                this.subtitleTrackController = Pe, Ce.push(Pe);
              }
              [o.subtitleStreamController, o.timelineController].forEach(function(Xe) {
                Xe && Ce.push(new Xe(l));
              }), this.coreComponents = Ce;
            }
            return g.prototype.destroy = function() {
              d.b.log("destroy"), this.trigger(p.a.DESTROYING), this.detachMedia(), this.coreComponents.concat(this.networkControllers).forEach(function(o) {
                o.destroy();
              }), this.url = null, this.observer.removeAllListeners(), this._autoLevelCapping = -1;
            }, g.prototype.attachMedia = function(o) {
              d.b.log("attachMedia"), this.media = o, this.trigger(p.a.MEDIA_ATTACHING, { media: o });
            }, g.prototype.detachMedia = function() {
              d.b.log("detachMedia"), this.trigger(p.a.MEDIA_DETACHING), this.media = null;
            }, g.prototype.loadSource = function(o) {
              o = m.a.buildAbsoluteURL(window.location.href, o, { alwaysNormalize: !0 }), d.b.log("loadSource:" + o), this.url = o, this.trigger(p.a.MANIFEST_LOADING, { url: o });
            }, g.prototype.startLoad = function() {
              var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
              d.b.log("startLoad(" + o + ")"), this.networkControllers.forEach(function(s) {
                s.startLoad(o);
              });
            }, g.prototype.stopLoad = function() {
              d.b.log("stopLoad"), this.networkControllers.forEach(function(o) {
                o.stopLoad();
              });
            }, g.prototype.swapAudioCodec = function() {
              d.b.log("swapAudioCodec"), this.streamController.swapAudioCodec();
            }, g.prototype.recoverMediaError = function() {
              d.b.log("recoverMediaError");
              var o = this.media;
              this.detachMedia(), this.attachMedia(o);
            }, gd(g, [{
              key: "levels",
              get: function() {
                return this.levelController.levels;
              }
              /** Return current playback quality level **/
            }, {
              key: "currentLevel",
              get: function() {
                return this.streamController.currentLevel;
              },
              set: function(o) {
                d.b.log("set currentLevel:" + o), this.loadLevel = o, this.streamController.immediateLevelSwitch();
              }
              /** Return next playback quality level (quality level of next fragment) **/
            }, {
              key: "nextLevel",
              get: function() {
                return this.streamController.nextLevel;
              },
              set: function(o) {
                d.b.log("set nextLevel:" + o), this.levelController.manualLevel = o, this.streamController.nextLevelSwitch();
              }
              /** Return the quality level of current/last loaded fragment **/
            }, {
              key: "loadLevel",
              get: function() {
                return this.levelController.level;
              },
              set: function(o) {
                d.b.log("set loadLevel:" + o), this.levelController.manualLevel = o;
              }
              /** Return the quality level of next loaded fragment **/
            }, {
              key: "nextLoadLevel",
              get: function() {
                return this.levelController.nextLoadLevel;
              },
              set: function(o) {
                this.levelController.nextLoadLevel = o;
              }
              /** Return first level (index of first level referenced in manifest)
              **/
            }, {
              key: "firstLevel",
              get: function() {
                return Math.max(this.levelController.firstLevel, this.minAutoLevel);
              },
              set: function(o) {
                d.b.log("set firstLevel:" + o), this.levelController.firstLevel = o;
              }
              /** Return start level (level of first fragment that will be played back)
                  if not overrided by user, first level appearing in manifest will be used as start level
                  if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
              **/
            }, {
              key: "startLevel",
              get: function() {
                return this.levelController.startLevel;
              },
              set: function(o) {
                d.b.log("set startLevel:" + o);
                var s = this;
                o !== -1 && (o = Math.max(o, s.minAutoLevel)), s.levelController.startLevel = o;
              }
              /** Return the capping/max level value that could be used by automatic level selection algorithm **/
            }, {
              key: "autoLevelCapping",
              get: function() {
                return this._autoLevelCapping;
              },
              set: function(o) {
                d.b.log("set autoLevelCapping:" + o), this._autoLevelCapping = o;
              }
              /* check if we are in automatic level selection mode */
            }, {
              key: "autoLevelEnabled",
              get: function() {
                return this.levelController.manualLevel === -1;
              }
              /* return manual level */
            }, {
              key: "manualLevel",
              get: function() {
                return this.levelController.manualLevel;
              }
              /* return min level selectable in auto mode according to config.minAutoBitrate */
            }, {
              key: "minAutoLevel",
              get: function() {
                for (var o = this, s = o.levels, u = o.config.minAutoBitrate, f = s ? s.length : 0, E = 0; E < f; E++) {
                  var w = s[E].realBitrate ? Math.max(s[E].realBitrate, s[E].bitrate) : s[E].bitrate;
                  if (w > u)
                    return E;
                }
                return 0;
              }
              /* return max level selectable in auto mode according to autoLevelCapping */
            }, {
              key: "maxAutoLevel",
              get: function() {
                var o = this, s = o.levels, u = o.autoLevelCapping, f = void 0;
                return u === -1 && s && s.length ? f = s.length - 1 : f = u, f;
              }
              // return next auto level
            }, {
              key: "nextAutoLevel",
              get: function() {
                var o = this;
                return Math.min(Math.max(o.abrController.nextAutoLevel, o.minAutoLevel), o.maxAutoLevel);
              },
              set: function(o) {
                var s = this;
                s.abrController.nextAutoLevel = Math.max(s.minAutoLevel, o);
              }
              /** get alternate audio tracks list from playlist **/
            }, {
              key: "audioTracks",
              get: function() {
                var o = this.audioTrackController;
                return o ? o.audioTracks : [];
              }
              /** get index of the selected audio track (index in audio track lists) **/
            }, {
              key: "audioTrack",
              get: function() {
                var o = this.audioTrackController;
                return o ? o.audioTrack : -1;
              },
              set: function(o) {
                var s = this.audioTrackController;
                s && (s.audioTrack = o);
              }
            }, {
              key: "liveSyncPosition",
              get: function() {
                return this.streamController.liveSyncPosition;
              }
              /** get alternate subtitle tracks list from playlist **/
            }, {
              key: "subtitleTracks",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleTracks : [];
              }
              /** get index of the selected subtitle track (index in subtitle track lists) **/
            }, {
              key: "subtitleTrack",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleTrack : -1;
              },
              set: function(o) {
                var s = this.subtitleTrackController;
                s && (s.subtitleTrack = o);
              }
            }, {
              key: "subtitleDisplay",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleDisplay : !1;
              },
              set: function(o) {
                var s = this.subtitleTrackController;
                s && (s.subtitleDisplay = o);
              }
            }]), g;
          }();
          i.default = eb;
        },
        /* 9 */
        /***/
        function(r, i, a) {
          function c(y) {
            var d = {};
            function A(K) {
              if (d[K])
                return d[K].exports;
              var O = d[K] = {
                /******/
                i: K,
                /******/
                l: !1,
                /******/
                exports: {}
                /******/
              };
              return y[K].call(O.exports, O, O.exports, A), O.l = !0, O.exports;
            }
            A.m = y, A.c = d, A.i = function(K) {
              return K;
            }, A.d = function(K, O, z) {
              A.o(K, O) || Object.defineProperty(K, O, {
                /******/
                configurable: !1,
                /******/
                enumerable: !0,
                /******/
                get: z
                /******/
              });
            }, A.n = function(K) {
              var O = K && K.__esModule ? (
                /******/
                function() {
                  return K.default;
                }
              ) : (
                /******/
                function() {
                  return K;
                }
              );
              return A.d(O, "a", O), O;
            }, A.o = function(K, O) {
              return Object.prototype.hasOwnProperty.call(K, O);
            }, A.p = "/", A.oe = function(K) {
              throw console.error(K), K;
            };
            var B = A(A.s = ENTRY_MODULE);
            return B.default || B;
          }
          function h(y) {
            return (y + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
          }
          function m(y) {
            var d = [], A = y.toString(), B = A.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
            if (!B) return d;
            for (var K = B[1], O = new RegExp("(\\\\n|\\W)" + h(K) + "\\((/\\*.*?\\*/)?s?.*?([\\.|\\-|\\w|/|@]+).*?\\)", "g"), z; z = O.exec(A); )
              d.push(z[3]);
            return d;
          }
          function p(y, d) {
            for (var A = [d], B = [], K = {}; A.length; ) {
              var O = A.pop();
              if (!(K[O] || !y[O])) {
                K[O] = !0, B.push(O);
                var z = m(y[O]);
                A = A.concat(z);
              }
            }
            return B;
          }
          r.exports = function(y, d) {
            d = d || {};
            var A = a.m, B = d.all ? Object.keys(A) : p(A, y), K = "(" + c.toString().replace("ENTRY_MODULE", JSON.stringify(y)) + ")({" + B.map(function(V) {
              return "" + JSON.stringify(V) + ": " + A[V].toString();
            }).join(",") + "})(self);", O = new window.Blob([K], { type: "text/javascript" });
            if (d.bare)
              return O;
            var z = window.URL || window.webkitURL || window.mozURL || window.msURL, X = z.createObjectURL(O), H = new window.Worker(X);
            return H.objectURL = X, H;
          };
        },
        /* 10 */
        /***/
        function(r, i, a) {
          Object.defineProperty(i, "__esModule", { value: !0 });
          var c = a(7), h = a(1), m = a(0), p = a(5), y = a.n(p), d = function(B) {
            var K = new y.a();
            K.trigger = function(X) {
              for (var H = arguments.length, V = Array(H > 1 ? H - 1 : 0), G = 1; G < H; G++)
                V[G - 1] = arguments[G];
              K.emit.apply(K, [X, X].concat(V));
            }, K.off = function(X) {
              for (var H = arguments.length, V = Array(H > 1 ? H - 1 : 0), G = 1; G < H; G++)
                V[G - 1] = arguments[G];
              K.removeListener.apply(K, [X].concat(V));
            };
            var O = function(X, H) {
              B.postMessage({ event: X, data: H });
            };
            B.addEventListener("message", function(z) {
              var X = z.data;
              switch (X.cmd) {
                case "init":
                  var H = JSON.parse(X.config);
                  B.demuxer = new c.a(K, X.typeSupported, H, X.vendor);
                  try {
                    Object(m.a)(H.debug === !0);
                  } catch {
                    console.warn("demuxerWorker: unable to enable logs");
                  }
                  O("init", null);
                  break;
                case "demux":
                  B.demuxer.push(X.data, X.decryptdata, X.initSegment, X.audioCodec, X.videoCodec, X.timeOffset, X.discontinuity, X.trackSwitch, X.contiguous, X.duration, X.accurateTimeOffset, X.defaultInitPTS);
                  break;
              }
            }), K.on(h.a.FRAG_DECRYPTED, O), K.on(h.a.FRAG_PARSING_INIT_SEGMENT, O), K.on(h.a.FRAG_PARSED, O), K.on(h.a.ERROR, O), K.on(h.a.FRAG_PARSING_METADATA, O), K.on(h.a.FRAG_PARSING_USERDATA, O), K.on(h.a.INIT_PTS_FOUND, O), K.on(h.a.FRAG_PARSING_DATA, function(z, X) {
              var H = [], V = { event: z, data: X };
              X.data1 && (V.data1 = X.data1.buffer, H.push(X.data1.buffer), delete X.data1), X.data2 && (V.data2 = X.data2.buffer, H.push(X.data2.buffer), delete X.data2), B.postMessage(V, H);
            });
          };
          i.default = d;
        }
        /******/
      ]).default
    );
  });
})(Hm);
var mK = Hm.exports;
const Ec = /* @__PURE__ */ kb(mK), Zm = ({
  post: t,
  reason: e,
  isRoot: r
}) => {
  if (t.$type === "app.bsky.graph.defs#listView")
    return {
      username: t.creator.displayName,
      handle: t.creator.handle,
      avatar: t.creator.avatar,
      text: [{
        val: t.description,
        setInnerHtml: !1
      }],
      createdAt: t.indexedAt,
      uri: t.uri,
      images: [],
      card: null,
      replyPost: null,
      isRepost: !1,
      repostBy: null
    };
  const i = t.record.facets || [], a = t.record.text, c = new Pc.RichText({
    text: a,
    facets: i
  }), h = [];
  for (const d of c.segments())
    d.isLink() ? h.push({
      val: `<a href="${d.link?.uri}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : d.isMention() ? h.push({
      val: `<a href="https://bsky.app/profile/${d.mention?.did}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : d.isTag() ? h.push({
      val: `<a href="https://bsky.app/hashtag/${d.tag?.tag}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : h.push({
      val: d.text,
      setInnerHtml: !1
    });
  const m = t.embed?.$type === "app.bsky.embed.record#view" ? t.embed.record : t.embed?.record?.record?.$type === "app.bsky.embed.record#viewRecord" && t.embed.record.record, p = m && {
    ...m,
    record: m.value || m.record,
    embed: (m?.embeds || [])[0]
  }, y = t.author || t.creator;
  return {
    username: y.displayName,
    handle: y.handle,
    avatar: y.avatar,
    // todo fallback
    text: h,
    createdAt: t.record.createdAt,
    uri: t.uri,
    images: [...t.embed?.images || [], ...t.embed?.media?.images || [], ...[t.embed?.media?.external].filter(Boolean).map((d) => ({
      ...d,
      alt: d.title,
      thumb: d.uri
    }))],
    video: t.embed?.$type === "app.bsky.embed.video#view" && t.embed,
    card: t.embed?.$type === "app.bsky.embed.external#view" && t.embed?.external,
    replyPost: r && p && Zm({
      post: p,
      reason: {
        $type: "",
        by: {
          displayName: ""
        }
      },
      isRoot: !1
    }),
    isRepost: e?.$type === "app.bsky.feed.defs#reasonRepost",
    repostBy: e?.by?.displayName
  };
}, vc = (t) => (t.feed || []).map((e) => Zm({
  ...e,
  isRoot: !0
})), kf = (t) => {
  const e = t.lastIndexOf("/");
  return e !== -1 ? t.substring(e + 1) : t;
}, yK = (t) => {
  const e = /* @__PURE__ */ new Date(), r = 60 * 1e3, i = r * 60, a = i * 24, c = a * 30, h = a * 365, m = e.getTime() - t.getTime();
  return m < r ? Math.floor(m / 1e3) + "s" : m < i ? Math.floor(m / r) + "m" : m < a ? Math.floor(m / i) + "h" : m < c ? Math.floor(m / a) + "d" : m < h ? Math.floor(m / c) + " mo" : Math.floor(m / h) + " yr";
}, bK = async (t, e) => {
  if (!("IntersectionObserver" in window)) {
    console.error("IntersectionObserver not supported");
    return;
  }
  if (!e) {
    console.error("Video element not found");
    return;
  }
  const r = {
    root: null,
    // Viewport is the root by default
    threshold: 0.5
    // 50% of the video must be visible to trigger playback
  }, i = async (c, h) => {
    c.forEach((m) => {
      if (m.isIntersecting) {
        if (Ec.isSupported()) {
          var p = new Ec();
          p.loadSource(t.playlist), p.attachMedia(e), p.on(Ec.Events.MANIFEST_PARSED, () => {
            e.play();
          });
        } else e.canPlayType("application/vnd.apple.mpegurl") && (e.src = t.playlist, e.addEventListener("loadedmetadata", () => {
          e.play();
        }));
        h.unobserve(e);
      }
    });
  };
  new IntersectionObserver(i, r).observe(e);
};
var gK = /* @__PURE__ */ tr('<article class="p-4 border-b border-slate-300 dark:border-slate-800"><div class="flex gap-2"><div class=w-full><div class="flex max-w-[calc(100vw-96px)] items-center"><a class="text-ellipsis overflow-hidden whitespace-nowrap hover:underline dark:text-white"><span class="font-bold dark:text-white"></span><span> </span><span class="text-slate-500 dark:text-slate-400 text-sm">@</span></a><span class="text-slate-500 dark:text-slate-400 text-sm"><span class=mx-1>·</span><a class=hover:underline></a></span></div><p class="whitespace-pre-wrap dark:text-white">'), xK = /* @__PURE__ */ tr('<p class="flex gap-1 items-center ml-10 text-slate-600 dark:text-slate-400"><svg viewBox="0 0 576 512"height=16 width=16 tabindex=-1 class=mr-1><path fill=currentColor d="M272 416c17.7 0 32-14.3 32-32s-14.3-32-32-32H160c-17.7 0-32-14.3-32-32V192h32c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-64-64c-12.5-12.5-32.8-12.5-45.3 0l-64 64c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l32 0 0 128c0 53 43 96 96 96H272zM304 96c-17.7 0-32 14.3-32 32s14.3 32 32 32l112 0c17.7 0 32 14.3 32 32l0 128H416c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l64 64c12.5 12.5 32.8 12.5 45.3 0l64-64c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8l-32 0V192c0-53-43-96-96-96L304 96z"></path></svg><span class="text-sm text-slate-500 font-semibold">Reposted by '), EK = /* @__PURE__ */ tr('<img alt="profile picture"class="w-14 h-14 rounded-full">'), vK = /* @__PURE__ */ tr('<img alt="profile picture"class="w-4 h-4 mr-1 rounded-full">'), Df = /* @__PURE__ */ tr("<span>"), RK = /* @__PURE__ */ tr("<div>"), AK = /* @__PURE__ */ tr("<a><img class=rounded-md>"), _K = /* @__PURE__ */ tr('<div class="mt-4 w-full"><video width=100% class="rounded-md w-full h-full object-cover"preload=none>'), wK = /* @__PURE__ */ tr('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block"><div class=p-3><p class="text-slate-500 dark:text-slate-400 text-sm"></p><p class="font-bold dark:text-white mb-1"></p><p class="whitespace-pre-wrap dark:text-white">'), TK = /* @__PURE__ */ tr('<img class=rounded-t-md alt="Post Thumbnail">'), CK = /* @__PURE__ */ tr('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block">');
const Wm = ({
  linkTarget: t = "_self",
  post: e,
  handleModalContent: r,
  isCard: i = !1,
  dateFormat: a,
  loadImages: c = !1
}) => {
  let h;
  return mb(() => {
    e.video && e.video.cid && bK(e.video, h);
  }), (() => {
    var m = gK(), p = m.firstChild, y = p.firstChild, d = y.firstChild, A = d.firstChild, B = A.firstChild, K = B.nextSibling, O = K.nextSibling;
    O.firstChild;
    var z = A.nextSibling, X = z.firstChild, H = X.nextSibling, V = d.nextSibling;
    return et(m, (() => {
      var G = Kr(() => !!e.isRepost);
      return () => G() && (() => {
        var Z = xK(), ae = Z.firstChild, se = ae.nextSibling;
        return se.firstChild, et(se, () => e.repostBy, null), Z;
      })();
    })(), p), et(p, !i && (() => {
      var G = EK();
      return Er(() => Bt(G, "src", e.avatar)), G;
    })(), y), et(d, i && (() => {
      var G = vK();
      return Er(() => Bt(G, "src", e.avatar)), G;
    })(), A), Bt(A, "target", t), Bt(A, "rel", t === "_blank" ? "noopeener" : ""), et(B, () => e.username), et(O, () => e.handle, null), Bt(H, "target", t), Bt(H, "rel", t === "_blank" ? "noopeener" : ""), et(H, (() => {
      var G = Kr(() => !!(a && a.type === "absolute"));
      return () => G() ? new Date(e.createdAt).toLocaleDateString(a.locale, a.options) : yK(new Date(e.createdAt));
    })()), et(V, () => e.text.map((G) => G.setInnerHtml ? (() => {
      var Z = Df();
      return Er(() => Z.innerHTML = G.val), Z;
    })() : (() => {
      var Z = Df();
      return et(Z, () => G.val), Z;
    })())), et(y, (() => {
      var G = Kr(() => !!(e.images.length > 0 && c));
      return () => G() && (() => {
        var Z = RK();
        return et(Z, () => e.images.map((ae) => (() => {
          var se = AK(), be = se.firstChild;
          return se.$$click = (me) => r(me, ae), Bt(se, "target", t), Bt(se, "rel", t === "_blank" ? "noopeener" : ""), Er((me) => {
            var Ae = `https://bsky.app/profile/${e.handle}/post/${kf(e.uri)}`, Be = ae.thumb, Ue = ae.alt;
            return Ae !== me.e && Bt(se, "href", me.e = Ae), Be !== me.t && Bt(be, "src", me.t = Be), Ue !== me.a && Bt(be, "alt", me.a = Ue), me;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          }), se;
        })())), Er(() => qf(Z, e.images.length > 1 ? "mt-4 grid grid-cols-2 gap-2" : "mt-4")), Z;
      })();
    })(), null), et(y, (() => {
      var G = Kr(() => !!e.video);
      return () => G() && (() => {
        var Z = _K(), ae = Z.firstChild, se = h;
        return typeof se == "function" ? zf(se, ae) : h = ae, ae.autoplay = !1, ae.controls = !0, ae.muted = !0, Er(() => Bt(ae, "poster", e.video.thumbnail)), Z;
      })();
    })(), null), et(y, (() => {
      var G = Kr(() => !!e.card);
      return () => G() && (() => {
        var Z = wK(), ae = Z.firstChild, se = ae.firstChild, be = se.nextSibling, me = be.nextSibling;
        return et(Z, (() => {
          var Ae = Kr(() => !!e.card.thumb);
          return () => Ae() && (() => {
            var Be = TK();
            return Er(() => Bt(Be, "src", e.card.thumb)), Be;
          })();
        })(), ae), et(se, () => new URL(e.card.uri).hostname), et(be, () => e.card.title), et(me, () => e.card.description), Er(() => Bt(Z, "href", e.card.uri)), Z;
      })();
    })(), null), et(y, (() => {
      var G = Kr(() => !!e.replyPost);
      return () => G() && (() => {
        var Z = CK();
        return et(Z, $f(Wm, Rb({
          linkTarget: t,
          handleModalContent: r
        }, {
          get post() {
            return e.replyPost;
          },
          isCard: !0
        }))), Er(() => Bt(Z, "href", e.card.uri)), Z;
      })();
    })(), null), Er((G) => {
      var Z = `https://bsky.app/profile/${e.handle}`, ae = `https://bsky.app/profile/${e.handle}/post/${kf(e.uri)}`;
      return Z !== G.e && Bt(A, "href", G.e = Z), ae !== G.t && Bt(H, "href", G.t = ae), G;
    }, {
      e: void 0,
      t: void 0
    }), m;
  })();
};
Gf(["click"]);
var SK = /* @__PURE__ */ tr('<section><dialog class="backdrop:bg-gray-800 backdrop:opacity-90"><form class="fixed top-5 right-5"><button type=submit aria-label=close formmethod=dialog formnovalidate class="bg-gray-900 rounded-full w-10 h-10 text-white flex items-center justify-center">X'), Pf = /* @__PURE__ */ tr("<style>"), LK = /* @__PURE__ */ tr("<div class=w-full>"), kK = /* @__PURE__ */ tr('<article class="w-full flex gap-2 p-4 border-b border-slate-300 dark:border-slate-800 animate-pulse"><div class="bg-slate-200 w-14 h-14 rounded-full dark:bg-slate-800"></div><div class="flex-1 space-y-2 py-1"><div class="grid grid-cols-4 gap-4"><div class="h-2 bg-slate-200 rounded col-span-2 dark:bg-slate-800"></div></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800">'), DK = /* @__PURE__ */ tr('<div class="mt-8 mb-16"><button id=bsky-load-more class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Load More Posts');
const PK = ({
  username: t,
  feed: e,
  limit: r = 10,
  mode: i = "",
  linkTarget: a = "_self",
  linkImage: c = !1,
  customStyles: h = "",
  disableStyles: m = !1,
  search: p,
  loadMore: y = !1,
  dateFormat: d
}) => {
  const [A, B] = ra(!1), [K, O] = ra([]), [z] = ra(r), [X, H] = ra(void 0);
  Kf(() => {
    B(!0), V();
  }, [t, e, p, z]);
  const V = async (se) => {
    t ? xc.app.bsky.feed.getAuthorFeed({
      limit: z(),
      actor: t,
      filter: "posts_no_replies",
      cursor: se
    }).then(({
      success: be,
      data: me
    }) => {
      if (be) {
        const Ae = vc(me);
        ae(Ae), B(!1), H(me.cursor);
      }
    }) : e ? xc.app.bsky.feed.getFeed({
      limit: z(),
      feed: e,
      cursor: se
    }).then(({
      success: be,
      data: me
    }) => {
      if (be) {
        const Ae = vc(me);
        ae(Ae), B(!1), H(me.cursor);
      }
    }) : p && xc.app.bsky.feed.searchPosts({
      limit: z(),
      q: p,
      cursor: se
    }).then(({
      success: be,
      data: me
    }) => {
      if (be) {
        const Ae = {
          ...me,
          feed: me.posts.map((Ue) => ({
            post: Ue
          }))
        }, Be = vc(Ae);
        ae(Be), B(!1), H(me.cursor);
      }
    });
  }, G = (se, be) => {
  }, Z = () => {
    B(!0), V(X());
  }, ae = (se) => {
    const be = [...K(), ...se];
    O(be);
  };
  return [!m && (() => {
    var se = Pf();
    return et(se, Lb), se;
  })(), h && (() => {
    var se = Pf();
    return et(se, h), se;
  })(), (() => {
    var se = SK(), be = se.firstChild;
    return qf(se, `${i} max-w-screen-sm mx-auto flex flex-col items-center`), et(se, (() => {
      var me = Kr(() => K().length > 0);
      return () => me() && K().map((Ae, Be) => (() => {
        var Ue = LK();
        return Bt(Ue, "id", `post-${Be}`), et(Ue, $f(Wm, {
          post: Ae,
          handleModalContent: G,
          linkTarget: a,
          dateFormat: d
        })), Ue;
      })());
    })(), be), et(se, (() => {
      var me = Kr(() => !!A());
      return () => me() && Array.from(Array(r)).map(() => kK());
    })(), be), zf((me) => me, be), et(se, (() => {
      var me = Kr(() => !!(y && X()));
      return () => me() && (() => {
        var Ae = DK(), Be = Ae.firstChild;
        return Be.$$click = Z, Ae;
      })();
    })(), null), se;
  })()];
};
Gf(["click"]);
Sb("bsky-embed", {
  username: "",
  feed: "",
  limit: 10,
  mode: "",
  linkTarget: "_self",
  linkImage: !1,
  customStyles: "",
  disableStyles: !1,
  search: "",
  loadMore: !1,
  dateFormat: {}
}, PK);
